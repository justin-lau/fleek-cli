"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedType = exports2.ZodParsedType = exports2.objectUtil = exports2.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util = exports2.util || (exports2.util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil = exports2.objectUtil || (exports2.objectUtil = {}));
    exports2.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return exports2.ZodParsedType.undefined;
        case "string":
          return exports2.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports2.ZodParsedType.nan : exports2.ZodParsedType.number;
        case "boolean":
          return exports2.ZodParsedType.boolean;
        case "function":
          return exports2.ZodParsedType.function;
        case "bigint":
          return exports2.ZodParsedType.bigint;
        case "symbol":
          return exports2.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports2.ZodParsedType.array;
          }
          if (data === null) {
            return exports2.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports2.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports2.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports2.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports2.ZodParsedType.date;
          }
          return exports2.ZodParsedType.object;
        default:
          return exports2.ZodParsedType.unknown;
      }
    };
    exports2.getParsedType = getParsedType;
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/ZodError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodError = exports2.quotelessJson = exports2.ZodIssueCode = void 0;
    var util_1 = require_util();
    exports2.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports2.quotelessJson = quotelessJson;
    var ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports2.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/locales/en.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports2.default = errorMap;
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/errors.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getErrorMap = exports2.setErrorMap = exports2.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports2.defaultErrorMap = en_1.default;
    var overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    exports2.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    exports2.getErrorMap = getErrorMap;
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/parseUtil.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsync = exports2.isValid = exports2.isDirty = exports2.isAborted = exports2.OK = exports2.DIRTY = exports2.INVALID = exports2.ParseStatus = exports2.addIssueToContext = exports2.EMPTY_PATH = exports2.makeIssue = void 0;
    var errors_1 = require_errors();
    var en_1 = __importDefault(require_en());
    var makeIssue = (params) => {
      const { data, path: path3, errorMaps, issueData } = params;
      const fullPath = [...path3, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    exports2.makeIssue = makeIssue;
    exports2.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const issue = (0, exports2.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          (0, errors_1.getErrorMap)(),
          en_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports2.addIssueToContext = addIssueToContext;
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports2.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports2.INVALID;
          if (value.status === "aborted")
            return exports2.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports2.ParseStatus = ParseStatus;
    exports2.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports2.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports2.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports2.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports2.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports2.isValid = isValid;
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports2.isAsync = isAsync;
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/typeAliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/helpers/errorUtil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil = exports2.errorUtil || (exports2.errorUtil = {}));
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.date = exports2.boolean = exports2.bigint = exports2.array = exports2.any = exports2.coerce = exports2.ZodFirstPartyTypeKind = exports2.late = exports2.ZodSchema = exports2.Schema = exports2.custom = exports2.ZodReadonly = exports2.ZodPipeline = exports2.ZodBranded = exports2.BRAND = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = exports2.ZodTransformer = exports2.ZodEffects = exports2.ZodPromise = exports2.ZodNativeEnum = exports2.ZodEnum = exports2.ZodLiteral = exports2.ZodLazy = exports2.ZodFunction = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.ZodArray = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodDate = exports2.ZodBoolean = exports2.ZodBigInt = exports2.ZodNumber = exports2.ZodString = exports2.ZodType = void 0;
    exports2.NEVER = exports2.void = exports2.unknown = exports2.union = exports2.undefined = exports2.tuple = exports2.transformer = exports2.symbol = exports2.string = exports2.strictObject = exports2.set = exports2.record = exports2.promise = exports2.preprocess = exports2.pipeline = exports2.ostring = exports2.optional = exports2.onumber = exports2.oboolean = exports2.object = exports2.number = exports2.nullable = exports2.null = exports2.never = exports2.nativeEnum = exports2.nan = exports2.map = exports2.literal = exports2.lazy = exports2.intersection = exports2.instanceof = exports2.function = exports2.enum = exports2.effect = exports2.discriminatedUnion = void 0;
    var errors_1 = require_errors();
    var errorUtil_1 = require_errorUtil();
    var parseUtil_1 = require_parseUtil();
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var ParseInputLazyPath = class {
      constructor(parent, value, path3, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path3;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports2.ZodType = ZodType;
    exports2.Schema = ZodType;
    exports2.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[a-z][a-z0-9]*$/;
    var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex;
    var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP(ip, version) {
      if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(
            ctx2,
            {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: util_1.ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports2.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports2.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    };
    exports2.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports2.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodArray = ZodArray;
    ZodArray.create = (schema2, params) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema2) {
      if (schema2 instanceof ZodObject) {
        const newShape = {};
        for (const key in schema2.shape) {
          const fieldSchema = schema2.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema2._def,
          shape: () => newShape
        });
      } else if (schema2 instanceof ZodArray) {
        return new ZodArray({
          ...schema2._def,
          type: deepPartialify(schema2.element)
        });
      } else if (schema2 instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodTuple) {
        return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
      } else {
        return schema2;
      }
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b2, _c, _d;
              const defaultError = (_c = (_b2 = (_a = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    };
    exports2.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports2.ZodUnion = ZodUnion;
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports2.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports2.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports2.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports2.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports2.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports2.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return _ZodEnum.create(values);
      }
      exclude(values) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    exports2.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports2.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports2.ZodPromise = ZodPromise;
    ZodPromise.create = (schema2, params) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    };
    exports2.ZodEffects = ZodEffects;
    exports2.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema2, effect, params) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports2.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports2.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports2.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports2.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports2.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports2.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if ((0, parseUtil_1.isValid)(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    exports2.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    var custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b2;
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b2 = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    exports2.custom = custom;
    exports2.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind = exports2.ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => (0, exports2.custom)((data) => data instanceof cls, params);
    exports2.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports2.string = stringType;
    var numberType = ZodNumber.create;
    exports2.number = numberType;
    var nanType = ZodNaN.create;
    exports2.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports2.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports2.boolean = booleanType;
    var dateType = ZodDate.create;
    exports2.date = dateType;
    var symbolType = ZodSymbol.create;
    exports2.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports2.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports2.null = nullType;
    var anyType = ZodAny.create;
    exports2.any = anyType;
    var unknownType = ZodUnknown.create;
    exports2.unknown = unknownType;
    var neverType = ZodNever.create;
    exports2.never = neverType;
    var voidType = ZodVoid.create;
    exports2.void = voidType;
    var arrayType = ZodArray.create;
    exports2.array = arrayType;
    var objectType = ZodObject.create;
    exports2.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports2.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports2.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports2.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports2.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports2.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports2.record = recordType;
    var mapType = ZodMap.create;
    exports2.map = mapType;
    var setType = ZodSet.create;
    exports2.set = setType;
    var functionType = ZodFunction.create;
    exports2.function = functionType;
    var lazyType = ZodLazy.create;
    exports2.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports2.literal = literalType;
    var enumType = ZodEnum.create;
    exports2.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports2.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports2.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports2.effect = effectsType;
    exports2.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports2.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports2.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports2.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports2.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports2.ostring = ostring;
    var onumber = () => numberType().optional();
    exports2.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports2.oboolean = oboolean;
    exports2.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    exports2.NEVER = parseUtil_1.INVALID;
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/external.js
var require_external = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/external.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors(), exports2);
    __exportStar(require_parseUtil(), exports2);
    __exportStar(require_typeAliases(), exports2);
    __exportStar(require_util(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_ZodError(), exports2);
  }
});

// node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external());
    exports2.z = z;
    __exportStar(require_external(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = "0.9.8";
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseError = void 0;
    var version_js_1 = require_version();
    var BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version_js_1.version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    };
    exports2.BaseError = BaseError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/narrow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.narrow = void 0;
    function narrow(value) {
      return value;
    }
    exports2.narrow = narrow;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTupleRegex = exports2.integerRegex = exports2.bytesRegex = exports2.execTyped = void 0;
    function execTyped(regex, string) {
      const match = regex.exec(string);
      return match?.groups;
    }
    exports2.execTyped = execTyped;
    exports2.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports2.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    exports2.isTupleRegex = /^\(.+?\).*?$/;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js
var require_formatAbiParameter = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbiParameter = void 0;
    var regex_js_1 = require_regex();
    var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    function formatAbiParameter(abiParameter) {
      let type = abiParameter.type;
      if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
        type = "(";
        const length = abiParameter.components.length;
        for (let i = 0; i < length; i++) {
          const component = abiParameter.components[i];
          type += formatAbiParameter(component);
          if (i < length - 1)
            type += ", ";
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ""}`;
        return formatAbiParameter({
          ...abiParameter,
          type
        });
      }
      if ("indexed" in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
      if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
      return type;
    }
    exports2.formatAbiParameter = formatAbiParameter;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js
var require_formatAbiParameters = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbiParameters = void 0;
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    function formatAbiParameters(abiParameters) {
      let params = "";
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i !== length - 1)
          params += ", ";
      }
      return params;
    }
    exports2.formatAbiParameters = formatAbiParameters;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js
var require_formatAbiItem = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbiItem = void 0;
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    function formatAbiItem(abiItem) {
      if (abiItem.type === "function")
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})` : ""}`;
      else if (abiItem.type === "event")
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "error")
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "constructor")
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
      else if (abiItem.type === "fallback")
        return "fallback()";
      return "receive() external payable";
    }
    exports2.formatAbiItem = formatAbiItem;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbi.js
var require_formatAbi = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/formatAbi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbi = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem();
    function formatAbi(abi) {
      const signatures = [];
      const length = abi.length;
      for (let i = 0; i < length; i++) {
        const abiItem = abi[i];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
      }
      return signatures;
    }
    exports2.formatAbi = formatAbi;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.functionModifiers = exports2.eventModifiers = exports2.modifiers = exports2.isReceiveSignature = exports2.isFallbackSignature = exports2.execConstructorSignature = exports2.isConstructorSignature = exports2.execStructSignature = exports2.isStructSignature = exports2.execFunctionSignature = exports2.isFunctionSignature = exports2.execEventSignature = exports2.isEventSignature = exports2.execErrorSignature = exports2.isErrorSignature = void 0;
    var regex_js_1 = require_regex();
    var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isErrorSignature(signature) {
      return errorSignatureRegex.test(signature);
    }
    exports2.isErrorSignature = isErrorSignature;
    function execErrorSignature(signature) {
      return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
    }
    exports2.execErrorSignature = execErrorSignature;
    var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isEventSignature(signature) {
      return eventSignatureRegex.test(signature);
    }
    exports2.isEventSignature = isEventSignature;
    function execEventSignature(signature) {
      return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
    }
    exports2.execEventSignature = execEventSignature;
    var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    function isFunctionSignature(signature) {
      return functionSignatureRegex.test(signature);
    }
    exports2.isFunctionSignature = isFunctionSignature;
    function execFunctionSignature(signature) {
      return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
    }
    exports2.execFunctionSignature = execFunctionSignature;
    var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
    function isStructSignature(signature) {
      return structSignatureRegex.test(signature);
    }
    exports2.isStructSignature = isStructSignature;
    function execStructSignature(signature) {
      return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
    }
    exports2.execStructSignature = execStructSignature;
    var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    function isConstructorSignature(signature) {
      return constructorSignatureRegex.test(signature);
    }
    exports2.isConstructorSignature = isConstructorSignature;
    function execConstructorSignature(signature) {
      return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
    }
    exports2.execConstructorSignature = execConstructorSignature;
    var fallbackSignatureRegex = /^fallback\(\)$/;
    function isFallbackSignature(signature) {
      return fallbackSignatureRegex.test(signature);
    }
    exports2.isFallbackSignature = isFallbackSignature;
    var receiveSignatureRegex = /^receive\(\) external payable$/;
    function isReceiveSignature(signature) {
      return receiveSignatureRegex.test(signature);
    }
    exports2.isReceiveSignature = isReceiveSignature;
    exports2.modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    exports2.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    exports2.functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownSolidityTypeError = exports2.UnknownTypeError = exports2.InvalidAbiItemError = void 0;
    var errors_js_1 = require_errors2();
    var InvalidAbiItemError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human.html#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    };
    exports2.InvalidAbiItemError = InvalidAbiItemError;
    var UnknownTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    };
    exports2.UnknownTypeError = UnknownTypeError;
    var UnknownSolidityTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    };
    exports2.UnknownSolidityTypeError = UnknownSolidityTypeError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidAbiTypeParameterError = exports2.InvalidFunctionModifierError = exports2.InvalidModifierError = exports2.SolidityProtectedKeywordError = exports2.InvalidParameterError = exports2.InvalidAbiParametersError = exports2.InvalidAbiParameterError = void 0;
    var errors_js_1 = require_errors2();
    var InvalidAbiParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Failed to parse ABI parameter.", {
          details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameter-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParameterError"
        });
      }
    };
    exports2.InvalidAbiParameterError = InvalidAbiParameterError;
    var InvalidAbiParametersError = class extends errors_js_1.BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    };
    exports2.InvalidAbiParametersError = InvalidAbiParametersError;
    var InvalidParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    };
    exports2.InvalidParameterError = InvalidParameterError;
    var SolidityProtectedKeywordError = class extends errors_js_1.BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    };
    exports2.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
    var InvalidModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    };
    exports2.InvalidModifierError = InvalidModifierError;
    var InvalidFunctionModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    };
    exports2.InvalidFunctionModifierError = InvalidFunctionModifierError;
    var InvalidAbiTypeParameterError = class extends errors_js_1.BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    };
    exports2.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidStructSignatureError = exports2.UnknownSignatureError = exports2.InvalidSignatureError = void 0;
    var errors_js_1 = require_errors2();
    var InvalidSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature, type }) {
        super(`Invalid ${type} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    };
    exports2.InvalidSignatureError = InvalidSignatureError;
    var UnknownSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    };
    exports2.UnknownSignatureError = UnknownSignatureError;
    var InvalidStructSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    };
    exports2.InvalidStructSignatureError = InvalidStructSignatureError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/struct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CircularReferenceError = void 0;
    var errors_js_1 = require_errors2();
    var CircularReferenceError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    };
    exports2.CircularReferenceError = CircularReferenceError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidParenthesisError = void 0;
    var errors_js_1 = require_errors2();
    var InvalidParenthesisError = class extends errors_js_1.BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    };
    exports2.InvalidParenthesisError = InvalidParenthesisError;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parameterCache = exports2.getParameterCacheKey = void 0;
    function getParameterCacheKey(param, type) {
      if (type)
        return `${type}:${param}`;
      return param;
    }
    exports2.getParameterCacheKey = getParameterCacheKey;
    exports2.parameterCache = /* @__PURE__ */ new Map([
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidDataLocation = exports2.isSolidityKeyword = exports2.isSolidityType = exports2.splitParameters = exports2.parseAbiParameter = exports2.parseSignature = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var splitParameters_js_1 = require_splitParameters();
    var cache_js_1 = require_cache();
    var signatures_js_1 = require_signatures();
    function parseSignature(signature, structs = {}) {
      if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "function" });
        const inputParams = splitParameters(match.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i = 0; i < inputLength; i++) {
          inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
        const outputs = [];
        if (match.returns) {
          const outputParams = splitParameters(match.returns);
          const outputLength = outputParams.length;
          for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
              modifiers: signatures_js_1.functionModifiers,
              structs,
              type: "function"
            }));
          }
        }
        return {
          name: match.name,
          type: "function",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs,
          outputs
        };
      }
      if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match = (0, signatures_js_1.execEventSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "event" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: "event"
          }));
        }
        return { name: match.name, type: "event", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "error" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
        }
        return { name: match.name, type: "error", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "constructor" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
        }
        return {
          type: "constructor",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs: abiParameters
        };
      }
      if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: "fallback" };
      if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
          type: "receive",
          stateMutability: "payable"
        };
      throw new signature_js_1.UnknownSignatureError({ signature });
    }
    exports2.parseSignature = parseSignature;
    var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var dynamicIntegerRegex = /^u?int$/;
    function parseAbiParameter(param, options) {
      const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
      if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
      const isTuple = regex_js_1.isTupleRegex.test(param);
      const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
      if (!match)
        throw new abiParameter_js_1.InvalidParameterError({ param });
      if (match.name && isSolidityKeyword(match.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
      const name = match.name ? { name: match.name } : {};
      const indexed = match.modifier === "indexed" ? { indexed: true } : {};
      const structs = options?.structs ?? {};
      let type;
      let components = {};
      if (isTuple) {
        type = "tuple";
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
      } else if (match.type in structs) {
        type = "tuple";
        components = { components: structs[match.type] };
      } else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
      } else {
        type = match.type;
        if (!(options?.type === "struct") && !isSolidityType(type))
          throw new abiItem_js_1.UnknownSolidityTypeError({ type });
      }
      if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
          throw new abiParameter_js_1.InvalidModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
        if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
          throw new abiParameter_js_1.InvalidFunctionModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
      }
      const abiParameter = {
        type: `${type}${match.array ?? ""}`,
        ...name,
        ...indexed,
        ...components
      };
      cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
      return abiParameter;
    }
    exports2.parseAbiParameter = parseAbiParameter;
    function splitParameters(params, result = [], current = "", depth = 0) {
      if (params === "") {
        if (current === "")
          return result;
        if (depth !== 0)
          throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
      }
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
          case ",":
            return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
          case "(":
            return splitParameters(tail, result, `${current}${char}`, depth + 1);
          case ")":
            return splitParameters(tail, result, `${current}${char}`, depth - 1);
          default:
            return splitParameters(tail, result, `${current}${char}`, depth);
        }
      }
      return [];
    }
    exports2.splitParameters = splitParameters;
    function isSolidityType(type) {
      return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
    }
    exports2.isSolidityType = isSolidityType;
    var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    function isSolidityKeyword(name) {
      return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
    }
    exports2.isSolidityKeyword = isSolidityKeyword;
    function isValidDataLocation(type, isArray) {
      return isArray || type === "bytes" || type === "string" || type === "tuple";
    }
    exports2.isValidDataLocation = isValidDataLocation;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseStructs = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var struct_js_1 = require_struct();
    var signatures_js_1 = require_signatures();
    var utils_js_1 = require_utils();
    function parseStructs(signatures) {
      const shallowStructs = {};
      const signaturesLength = signatures.length;
      for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
          continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "struct" });
        const properties = match.properties.split(";");
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
          const property = properties[k];
          const trimmed = property.trim();
          if (!trimmed)
            continue;
          const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
            type: "struct"
          });
          components.push(abiParameter);
        }
        if (!components.length)
          throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
      }
      const resolvedStructs = {};
      const entries = Object.entries(shallowStructs);
      const entriesLength = entries.length;
      for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
      }
      return resolvedStructs;
    }
    exports2.parseStructs = parseStructs;
    var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
      const components = [];
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
          components.push(abiParameter);
        else {
          const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
          if (!match?.type)
            throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
          const { array, type } = match;
          if (type in structs) {
            if (ancestors.has(type))
              throw new struct_js_1.CircularReferenceError({ type });
            components.push({
              ...abiParameter,
              type: `tuple${array ?? ""}`,
              components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
            });
          } else {
            if ((0, utils_js_1.isSolidityType)(type))
              components.push(abiParameter);
            else
              throw new abiItem_js_1.UnknownTypeError({ type });
          }
        }
      }
      return components;
    }
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAbi = void 0;
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbi(signatures) {
      const structs = (0, structs_js_1.parseStructs)(signatures);
      const abi = [];
      const length = signatures.length;
      for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
      }
      return abi;
    }
    exports2.parseAbi = parseAbi;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAbiItem = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbiItem(signature) {
      let abiItem;
      if (typeof signature === "string")
        abiItem = (0, utils_js_1.parseSignature)(signature);
      else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
          const signature_ = signature[i];
          if ((0, signatures_js_1.isStructSignature)(signature_))
            continue;
          abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
          break;
        }
      }
      if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
      return abiItem;
    }
    exports2.parseAbiItem = parseAbiItem;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAbiParameter = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbiParameter(param) {
      let abiParameter;
      if (typeof param === "string")
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
          modifiers: signatures_js_1.modifiers
        });
      else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
          const signature = param[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
          break;
        }
      }
      if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
      return abiParameter;
    }
    exports2.parseAbiParameter = parseAbiParameter;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAbiParameters = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    function parseAbiParameters(params) {
      const abiParameters = [];
      if (typeof params === "string") {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
        }
      } else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
          const signature = params[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          const parameters = (0, utils_js_1.splitParameters)(signature);
          const length2 = parameters.length;
          for (let k = 0; k < length2; k++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
          }
        }
      }
      if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
      return abiParameters;
    }
    exports2.parseAbiParameters = parseAbiParameters;
  }
});

// node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/abitype@0.9.8_typescript@4.9.3_zod@3.22.4/node_modules/abitype/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CircularReferenceError = exports2.InvalidParenthesisError = exports2.UnknownSignatureError = exports2.InvalidSignatureError = exports2.InvalidStructSignatureError = exports2.InvalidAbiParameterError = exports2.InvalidAbiParametersError = exports2.InvalidParameterError = exports2.SolidityProtectedKeywordError = exports2.InvalidModifierError = exports2.InvalidFunctionModifierError = exports2.InvalidAbiTypeParameterError = exports2.UnknownSolidityTypeError = exports2.InvalidAbiItemError = exports2.UnknownTypeError = exports2.parseAbiParameters = exports2.parseAbiParameter = exports2.parseAbiItem = exports2.parseAbi = exports2.formatAbiParameters = exports2.formatAbiParameter = exports2.formatAbiItem = exports2.formatAbi = exports2.narrow = exports2.BaseError = void 0;
    var errors_js_1 = require_errors2();
    Object.defineProperty(exports2, "BaseError", { enumerable: true, get: function() {
      return errors_js_1.BaseError;
    } });
    var narrow_js_1 = require_narrow();
    Object.defineProperty(exports2, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var formatAbi_js_1 = require_formatAbi();
    Object.defineProperty(exports2, "formatAbi", { enumerable: true, get: function() {
      return formatAbi_js_1.formatAbi;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem();
    Object.defineProperty(exports2, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    Object.defineProperty(exports2, "formatAbiParameter", { enumerable: true, get: function() {
      return formatAbiParameter_js_1.formatAbiParameter;
    } });
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    Object.defineProperty(exports2, "formatAbiParameters", { enumerable: true, get: function() {
      return formatAbiParameters_js_1.formatAbiParameters;
    } });
    var parseAbi_js_1 = require_parseAbi();
    Object.defineProperty(exports2, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = require_parseAbiItem();
    Object.defineProperty(exports2, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = require_parseAbiParameter();
    Object.defineProperty(exports2, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = require_parseAbiParameters();
    Object.defineProperty(exports2, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
    var abiItem_js_1 = require_abiItem();
    Object.defineProperty(exports2, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownTypeError;
    } });
    Object.defineProperty(exports2, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports2, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownSolidityTypeError;
    } });
    var abiParameter_js_1 = require_abiParameter();
    Object.defineProperty(exports2, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports2, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports2, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports2, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports2, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports2, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports2, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParameterError;
    } });
    var signature_js_1 = require_signature();
    Object.defineProperty(exports2, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports2, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports2, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_1.UnknownSignatureError;
    } });
    var splitParameters_js_1 = require_splitParameters();
    Object.defineProperty(exports2, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_1.InvalidParenthesisError;
    } });
    var struct_js_1 = require_struct();
    Object.defineProperty(exports2, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_1.CircularReferenceError;
    } });
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/getAction.js
var require_getAction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/getAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAction = void 0;
    function getAction(client, action, name) {
      return (params) => client[action.name || name]?.(params) ?? action(client, params);
    }
    exports2.getAction = getAction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/formatAbiItem.js
var require_formatAbiItem2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/formatAbiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbiParams = exports2.formatAbiItem = void 0;
    var abi_js_1 = require_abi();
    function formatAbiItem(abiItem, { includeName = false } = {}) {
      if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
      return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
    }
    exports2.formatAbiItem = formatAbiItem;
    function formatAbiParams(params, { includeName = false } = {}) {
      if (!params)
        return "";
      return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
    }
    exports2.formatAbiParams = formatAbiParams;
    function formatAbiParam(param, { includeName }) {
      if (param.type.startsWith("tuple")) {
        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
      }
      return param.type + (includeName && param.name ? ` ${param.name}` : "");
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isHex.js
var require_isHex = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHex = void 0;
    function isHex(value, { strict = true } = {}) {
      if (!value)
        return false;
      if (typeof value !== "string")
        return false;
      return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
    }
    exports2.isHex = isHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/size.js
var require_size = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/size.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.size = void 0;
    var isHex_js_1 = require_isHex();
    function size(value) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
      return value.length;
    }
    exports2.size = size;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/version.js
var require_version2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = "1.21.3";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getVersion = exports2.getUrl = exports2.getContractAddress = void 0;
    var version_js_1 = require_version2();
    var getContractAddress = (address) => address;
    exports2.getContractAddress = getContractAddress;
    var getUrl = (url) => url;
    exports2.getUrl = getUrl;
    var getVersion = () => `viem@${version_js_1.version}`;
    exports2.getVersion = getVersion;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/base.js
var require_base = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseError = void 0;
    var utils_js_1 = require_utils2();
    var BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, utils_js_1.getVersion)()
        });
        const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [
            `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    };
    exports2.BaseError = BaseError;
    function walk(err, fn) {
      if (fn?.(err))
        return err;
      if (err && typeof err === "object" && "cause" in err)
        return walk(err.cause, fn);
      return fn ? null : err;
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/abi.js
var require_abi = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/abi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsupportedPackedAbiType = exports2.InvalidDefinitionTypeError = exports2.InvalidArrayError = exports2.InvalidAbiDecodingTypeError = exports2.InvalidAbiEncodingTypeError = exports2.DecodeLogTopicsMismatch = exports2.DecodeLogDataMismatch = exports2.BytesSizeMismatchError = exports2.AbiItemAmbiguityError = exports2.AbiFunctionSignatureNotFoundError = exports2.AbiFunctionOutputsNotFoundError = exports2.AbiFunctionNotFoundError = exports2.AbiEventNotFoundError = exports2.AbiEventSignatureNotFoundError = exports2.AbiEventSignatureEmptyTopicsError = exports2.AbiErrorSignatureNotFoundError = exports2.AbiErrorNotFoundError = exports2.AbiErrorInputsNotFoundError = exports2.AbiEncodingLengthMismatchError = exports2.AbiEncodingBytesSizeMismatchError = exports2.AbiEncodingArrayLengthMismatchError = exports2.AbiDecodingZeroDataError = exports2.AbiDecodingDataSizeTooSmallError = exports2.AbiDecodingDataSizeInvalidError = exports2.AbiConstructorParamsNotFoundError = exports2.AbiConstructorNotFoundError = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var size_js_1 = require_size();
    var base_js_1 = require_base();
    var AbiConstructorNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "A constructor was not found on the ABI.",
          "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorNotFoundError"
        });
      }
    };
    exports2.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
    var AbiConstructorParamsNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
          "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorParamsNotFoundError"
        });
      }
    };
    exports2.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
    var AbiDecodingDataSizeInvalidError = class extends base_js_1.BaseError {
      constructor({ data, size }) {
        super([
          `Data size of ${size} bytes is invalid.`,
          "Size must be in increments of 32 bytes (size % 32 === 0)."
        ].join("\n"), { metaMessages: [`Data: ${data} (${size} bytes)`] });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeInvalidError"
        });
      }
    };
    exports2.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
    var AbiDecodingDataSizeTooSmallError = class extends base_js_1.BaseError {
      constructor({ data, params, size }) {
        super([`Data size of ${size} bytes is too small for given parameters.`].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports2.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
    var AbiDecodingZeroDataError = class extends base_js_1.BaseError {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingZeroDataError"
        });
      }
    };
    exports2.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
    var AbiEncodingArrayLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    exports2.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
    var AbiEncodingBytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    exports2.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
    var AbiEncodingLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    exports2.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
    var AbiErrorInputsNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath }) {
        super([
          `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
          "Cannot encode error result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the inputs exist on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorInputsNotFoundError"
        });
      }
    };
    exports2.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
    var AbiErrorNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath } = {}) {
        super([
          `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorNotFoundError"
        });
      }
    };
    exports2.AbiErrorNotFoundError = AbiErrorNotFoundError;
    var AbiErrorSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded error signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorSignatureNotFoundError"
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.signature = signature;
      }
    };
    exports2.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
    var AbiEventSignatureEmptyTopicsError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super("Cannot extract event signature from empty topics.", {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureEmptyTopicsError"
        });
      }
    };
    exports2.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
    var AbiEventSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded event signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureNotFoundError"
        });
      }
    };
    exports2.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
    var AbiEventNotFoundError = class extends base_js_1.BaseError {
      constructor(eventName, { docsPath } = {}) {
        super([
          `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventNotFoundError"
        });
      }
    };
    exports2.AbiEventNotFoundError = AbiEventNotFoundError;
    var AbiFunctionNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    exports2.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
    var AbiFunctionOutputsNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath }) {
        super([
          `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
          "Cannot decode function result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionOutputsNotFoundError"
        });
      }
    };
    exports2.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
    var AbiFunctionSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded function signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionSignatureNotFoundError"
        });
      }
    };
    exports2.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
    var AbiItemAmbiguityError = class extends base_js_1.BaseError {
      constructor(x, y) {
        super("Found ambiguous types in overloaded ABI items.", {
          metaMessages: [
            `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
            `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
            "",
            "These types encode differently and cannot be distinguished at runtime.",
            "Remove one of the ambiguous items in the ABI."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiItemAmbiguityError"
        });
      }
    };
    exports2.AbiItemAmbiguityError = AbiItemAmbiguityError;
    var BytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BytesSizeMismatchError"
        });
      }
    };
    exports2.BytesSizeMismatchError = BytesSizeMismatchError;
    var DecodeLogDataMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, data, params, size }) {
        super([
          `Data size of ${size} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports2.DecodeLogDataMismatch = DecodeLogDataMismatch;
    var DecodeLogTopicsMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
      }
    };
    exports2.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
    var InvalidAbiEncodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    exports2.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
    var InvalidAbiDecodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid decoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiDecodingType"
        });
      }
    };
    exports2.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
    var InvalidArrayError = class extends base_js_1.BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    exports2.InvalidArrayError = InvalidArrayError;
    var InvalidDefinitionTypeError = class extends base_js_1.BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
    exports2.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
    var UnsupportedPackedAbiType = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedPackedAbiType"
        });
      }
    };
    exports2.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/log.js
var require_log = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilterTypeNotSupportedError = void 0;
    var base_js_1 = require_base();
    var FilterTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
    exports2.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/data.js
var require_data = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SizeExceedsPaddingSizeError = exports2.SliceOffsetOutOfBoundsError = void 0;
    var base_js_1 = require_base();
    var SliceOffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ offset, position, size }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    exports2.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
    var SizeExceedsPaddingSizeError = class extends base_js_1.BaseError {
      constructor({ size, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
    exports2.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/pad.js
var require_pad = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/pad.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.padBytes = exports2.padHex = exports2.pad = void 0;
    var data_js_1 = require_data();
    function pad(hexOrBytes, { dir, size = 32 } = {}) {
      if (typeof hexOrBytes === "string")
        return padHex(hexOrBytes, { dir, size });
      return padBytes(hexOrBytes, { dir, size });
    }
    exports2.pad = pad;
    function padHex(hex_, { dir, size = 32 } = {}) {
      if (size === null)
        return hex_;
      const hex = hex_.replace("0x", "");
      if (hex.length > size * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: Math.ceil(hex.length / 2),
          targetSize: size,
          type: "hex"
        });
      return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
    }
    exports2.padHex = padHex;
    function padBytes(bytes, { dir, size = 32 } = {}) {
      if (size === null)
        return bytes;
      if (bytes.length > size)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: bytes.length,
          targetSize: size,
          type: "bytes"
        });
      const paddedBytes = new Uint8Array(size);
      for (let i = 0; i < size; i++) {
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
      }
      return paddedBytes;
    }
    exports2.padBytes = padBytes;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/encoding.js
var require_encoding = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SizeOverflowError = exports2.OffsetOutOfBoundsError = exports2.InvalidHexValueError = exports2.InvalidHexBooleanError = exports2.InvalidBytesBooleanError = exports2.IntegerOutOfRangeError = exports2.DataLengthTooShortError = exports2.DataLengthTooLongError = void 0;
    var base_js_1 = require_base();
    var DataLengthTooLongError = class extends base_js_1.BaseError {
      constructor({ consumed, length }) {
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooLongError"
        });
      }
    };
    exports2.DataLengthTooLongError = DataLengthTooLongError;
    var DataLengthTooShortError = class extends base_js_1.BaseError {
      constructor({ length, dataLength }) {
        super(`Data length (${dataLength - 1}) is shorter than consumed bytes length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooShortError"
        });
      }
    };
    exports2.DataLengthTooShortError = DataLengthTooShortError;
    var IntegerOutOfRangeError = class extends base_js_1.BaseError {
      constructor({ max, min, signed, size, value }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    exports2.IntegerOutOfRangeError = IntegerOutOfRangeError;
    var InvalidBytesBooleanError = class extends base_js_1.BaseError {
      constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidBytesBooleanError"
        });
      }
    };
    exports2.InvalidBytesBooleanError = InvalidBytesBooleanError;
    var InvalidHexBooleanError = class extends base_js_1.BaseError {
      constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexBooleanError"
        });
      }
    };
    exports2.InvalidHexBooleanError = InvalidHexBooleanError;
    var InvalidHexValueError = class extends base_js_1.BaseError {
      constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexValueError"
        });
      }
    };
    exports2.InvalidHexValueError = InvalidHexValueError;
    var OffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ nextOffset, offset }) {
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffsetOutOfBoundsError"
        });
      }
    };
    exports2.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
    var SizeOverflowError = class extends base_js_1.BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
    exports2.SizeOverflowError = SizeOverflowError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/trim.js
var require_trim = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/trim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.trim = void 0;
    function trim(hexOrBytes, { dir = "left" } = {}) {
      let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
      let sliceLength = 0;
      for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
          sliceLength++;
        else
          break;
      }
      data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
      if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right")
          data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
      }
      return data;
    }
    exports2.trim = trim;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromHex.js
var require_fromHex = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToString = exports2.hexToNumber = exports2.hexToBool = exports2.hexToBigInt = exports2.fromHex = exports2.assertSize = void 0;
    var encoding_js_1 = require_encoding();
    var size_js_1 = require_size();
    var trim_js_1 = require_trim();
    var toBytes_js_1 = require_toBytes();
    function assertSize(hexOrBytes, { size }) {
      if ((0, size_js_1.size)(hexOrBytes) > size)
        throw new encoding_js_1.SizeOverflowError({
          givenSize: (0, size_js_1.size)(hexOrBytes),
          maxSize: size
        });
    }
    exports2.assertSize = assertSize;
    function fromHex(hex, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return hexToNumber(hex, opts);
      if (to === "bigint")
        return hexToBigInt(hex, opts);
      if (to === "string")
        return hexToString(hex, opts);
      if (to === "boolean")
        return hexToBool(hex, opts);
      return (0, toBytes_js_1.hexToBytes)(hex, opts);
    }
    exports2.fromHex = fromHex;
    function hexToBigInt(hex, opts = {}) {
      const { signed } = opts;
      if (opts.size)
        assertSize(hex, { size: opts.size });
      const value = BigInt(hex);
      if (!signed)
        return value;
      const size = (hex.length - 2) / 2;
      const max = (1n << BigInt(size) * 8n - 1n) - 1n;
      if (value <= max)
        return value;
      return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
    }
    exports2.hexToBigInt = hexToBigInt;
    function hexToBool(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
      }
      if ((0, trim_js_1.trim)(hex) === "0x00")
        return false;
      if ((0, trim_js_1.trim)(hex) === "0x01")
        return true;
      throw new encoding_js_1.InvalidHexBooleanError(hex);
    }
    exports2.hexToBool = hexToBool;
    function hexToNumber(hex, opts = {}) {
      return Number(hexToBigInt(hex, opts));
    }
    exports2.hexToNumber = hexToNumber;
    function hexToString(hex, opts = {}) {
      let bytes = (0, toBytes_js_1.hexToBytes)(hex);
      if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports2.hexToString = hexToString;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toHex.js
var require_toHex = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToHex = exports2.numberToHex = exports2.bytesToHex = exports2.boolToHex = exports2.toHex = void 0;
    var encoding_js_1 = require_encoding();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function toHex(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToHex(value, opts);
      if (typeof value === "string") {
        return stringToHex(value, opts);
      }
      if (typeof value === "boolean")
        return boolToHex(value, opts);
      return bytesToHex(value, opts);
    }
    exports2.toHex = toHex;
    function boolToHex(value, opts = {}) {
      const hex = `0x${Number(value)}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
      }
      return hex;
    }
    exports2.boolToHex = boolToHex;
    function bytesToHex(value, opts = {}) {
      let string = "";
      for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
      }
      const hex = `0x${string}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    function numberToHex(value_, opts = {}) {
      const { signed, size } = opts;
      const value = BigInt(value_);
      let maxValue;
      if (size) {
        if (signed)
          maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else
          maxValue = 2n ** (BigInt(size) * 8n) - 1n;
      } else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
      }
      const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
      if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new encoding_js_1.IntegerOutOfRangeError({
          max: maxValue ? `${maxValue}${suffix}` : void 0,
          min: `${minValue}${suffix}`,
          signed,
          size,
          value: `${value_}${suffix}`
        });
      }
      const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
      if (size)
        return (0, pad_js_1.pad)(hex, { size });
      return hex;
    }
    exports2.numberToHex = numberToHex;
    var encoder = new TextEncoder();
    function stringToHex(value_, opts = {}) {
      const value = encoder.encode(value_);
      return bytesToHex(value, opts);
    }
    exports2.stringToHex = stringToHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toBytes.js
var require_toBytes = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toBytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToBytes = exports2.numberToBytes = exports2.hexToBytes = exports2.boolToBytes = exports2.toBytes = void 0;
    var base_js_1 = require_base();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var encoder = new TextEncoder();
    function toBytes(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToBytes(value, opts);
      if (typeof value === "boolean")
        return boolToBytes(value, opts);
      if ((0, isHex_js_1.isHex)(value))
        return hexToBytes(value, opts);
      return stringToBytes(value, opts);
    }
    exports2.toBytes = toBytes;
    function boolToBytes(value, opts = {}) {
      const bytes = new Uint8Array(1);
      bytes[0] = Number(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { size: opts.size });
      }
      return bytes;
    }
    exports2.boolToBytes = boolToBytes;
    var charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
    function charCodeToBase16(char) {
      if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
      if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
      if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
      return void 0;
    }
    function hexToBytes(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      let hexString = hex.slice(2);
      if (hexString.length % 2)
        hexString = `0${hexString}`;
      const length = hexString.length / 2;
      const bytes = new Uint8Array(length);
      for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === void 0 || nibbleRight === void 0) {
          throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
      }
      return bytes;
    }
    exports2.hexToBytes = hexToBytes;
    function numberToBytes(value, opts) {
      const hex = (0, toHex_js_1.numberToHex)(value, opts);
      return hexToBytes(hex);
    }
    exports2.numberToBytes = numberToBytes;
    function stringToBytes(value, opts = {}) {
      const bytes = encoder.encode(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { dir: "right", size: opts.size });
      }
      return bytes;
    }
    exports2.stringToBytes = stringToBytes;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/normalizeSignature.js
var require_normalizeSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/normalizeSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeSignature = void 0;
    var base_js_1 = require_base();
    function normalizeSignature(signature) {
      let active = true;
      let current = "";
      let level = 0;
      let result = "";
      let valid = false;
      for (let i = 0; i < signature.length; i++) {
        const char = signature[i];
        if (["(", ")", ","].includes(char))
          active = true;
        if (char === "(")
          level++;
        if (char === ")")
          level--;
        if (!active)
          continue;
        if (level === 0) {
          if (char === " " && ["event", "function", ""].includes(result))
            result = "";
          else {
            result += char;
            if (char === ")") {
              valid = true;
              break;
            }
          }
          continue;
        }
        if (char === " ") {
          if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
            current = "";
            active = false;
          }
          continue;
        }
        result += char;
        current += char;
      }
      if (!valid)
        throw new base_js_1.BaseError("Unable to normalize signature.");
      return result;
    }
    exports2.normalizeSignature = normalizeSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getFunctionSignature.js
var require_getFunctionSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getFunctionSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFunctionSignature = void 0;
    var abitype_1 = require_cjs();
    var normalizeSignature_js_1 = require_normalizeSignature();
    var getFunctionSignature = (fn_) => {
      const fn = (() => {
        if (typeof fn_ === "string")
          return fn_;
        return (0, abitype_1.formatAbiItem)(fn_);
      })();
      return (0, normalizeSignature_js_1.normalizeSignature)(fn);
    };
    exports2.getFunctionSignature = getFunctionSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getEventSignature.js
var require_getEventSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getEventSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEventSignature = void 0;
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    var getEventSignature = (fn) => {
      return (0, getFunctionSignature_js_1.getFunctionSignature)(fn);
    };
    exports2.getEventSignature = getEventSignature;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports2.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports2.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports2.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports2.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports2.exists = exists;
    function output2(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports2.output = output2;
    var assert = { number, bool, bytes, hash, exists, output: output2 };
    exports2.default = assert;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports2.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports2.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports2.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("node:crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    var crypto_1 = require_cryptoNode();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports2.rotr = rotr;
    exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports2.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    exports2.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports2.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports2.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports2.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports2.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports2.randomBytes = randomBytes2;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = exports2.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils3();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _256n = /* @__PURE__ */ BigInt(256);
    var _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t2 = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t2);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t2 = 0; t2 < 24; t2++) {
          const shift = SHA3_ROTL[t2];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t2];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports2.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports2.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports2.sha3_224 = gen(6, 144, 224 / 8);
    exports2.sha3_256 = gen(6, 136, 256 / 8);
    exports2.sha3_384 = gen(6, 104, 384 / 8);
    exports2.sha3_512 = gen(6, 72, 512 / 8);
    exports2.keccak_224 = gen(1, 144, 224 / 8);
    exports2.keccak_256 = gen(1, 136, 256 / 8);
    exports2.keccak_384 = gen(1, 104, 384 / 8);
    exports2.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports2.shake128 = genShake(31, 168, 128 / 8);
    exports2.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/keccak256.js
var require_keccak256 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/keccak256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.keccak256 = void 0;
    var sha3_1 = require_sha3();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function keccak256(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports2.keccak256 = keccak256;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getEventSelector.js
var require_getEventSelector = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getEventSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEventSelector = void 0;
    var toBytes_js_1 = require_toBytes();
    var getEventSignature_js_1 = require_getEventSignature();
    var keccak256_js_1 = require_keccak256();
    var hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    var getEventSelector = (fn) => hash((0, getEventSignature_js_1.getEventSignature)(fn));
    exports2.getEventSelector = getEventSelector;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/address.js
var require_address = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidAddressError = void 0;
    var base_js_1 = require_base();
    var InvalidAddressError = class extends base_js_1.BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
    exports2.InvalidAddressError = InvalidAddressError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/isAddress.js
var require_isAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/isAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAddress = void 0;
    var addressRegex = /^0x[a-fA-F0-9]{40}$/;
    function isAddress(address) {
      return addressRegex.test(address);
    }
    exports2.isAddress = isAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/concat.js
var require_concat = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatHex = exports2.concatBytes = exports2.concat = void 0;
    function concat(values) {
      if (typeof values[0] === "string")
        return concatHex(values);
      return concatBytes(values);
    }
    exports2.concat = concat;
    function concatBytes(values) {
      let length = 0;
      for (const arr of values) {
        length += arr.length;
      }
      const result = new Uint8Array(length);
      let offset = 0;
      for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }
    exports2.concatBytes = concatBytes;
    function concatHex(values) {
      return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
    }
    exports2.concatHex = concatHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/slice.js
var require_slice = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/slice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sliceHex = exports2.sliceBytes = exports2.slice = void 0;
    var data_js_1 = require_data();
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function slice(value, start, end, { strict } = {}) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex(value, start, end, {
          strict
        });
      return sliceBytes(value, start, end, {
        strict
      });
    }
    exports2.slice = slice;
    function assertStartOffset(value, start) {
      if (typeof start === "number" && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: start,
          position: "start",
          size: (0, size_js_1.size)(value)
        });
    }
    function assertEndOffset(value, start, end) {
      if (typeof start === "number" && typeof end === "number" && (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: end,
          position: "end",
          size: (0, size_js_1.size)(value)
        });
      }
    }
    function sliceBytes(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = value_.slice(start, end);
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports2.sliceBytes = sliceBytes;
    function sliceHex(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports2.sliceHex = sliceHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js
var require_encodeAbiParameters = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArrayComponents = exports2.encodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var toHex_js_1 = require_toHex();
    function encodeAbiParameters(params, values) {
      if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: params.length,
          givenLength: values.length
        });
      const preparedParams = prepareParams({
        params,
        values
      });
      const data = encodeParams(preparedParams);
      if (data.length === 0)
        return "0x";
      return data;
    }
    exports2.encodeAbiParameters = encodeAbiParameters;
    function prepareParams({ params, values }) {
      const preparedParams = [];
      for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
      }
      return preparedParams;
    }
    function prepareParam({ param, value }) {
      const arrayComponents = getArrayComponents(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, { length, param: { ...param, type } });
      }
      if (param.type === "tuple") {
        return encodeTuple(value, {
          param
        });
      }
      if (param.type === "address") {
        return encodeAddress(value);
      }
      if (param.type === "bool") {
        return encodeBool(value);
      }
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber(value, { signed });
      }
      if (param.type.startsWith("bytes")) {
        return encodeBytes(value, { param });
      }
      if (param.type === "string") {
        return encodeString(value);
      }
      throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
      });
    }
    function encodeParams(preparedParams) {
      let staticSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
          staticSize += 32;
        else
          staticSize += (0, size_js_1.size)(encoded);
      }
      const staticParams = [];
      const dynamicParams = [];
      let dynamicSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
          staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
          dynamicParams.push(encoded);
          dynamicSize += (0, size_js_1.size)(encoded);
        } else {
          staticParams.push(encoded);
        }
      }
      return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
    }
    function encodeAddress(value) {
      if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
    }
    function encodeArray(value, { length, param }) {
      const dynamic = length === null;
      if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
      if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
          expectedLength: length,
          givenLength: value.length,
          type: `${param.type}[${length}]`
        });
      let dynamicChild = false;
      const preparedParams = [];
      for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam({ param, value: value[i] });
        if (preparedParam.dynamic)
          dynamicChild = true;
        preparedParams.push(preparedParam);
      }
      if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
          const length2 = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
          return {
            dynamic: true,
            encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length2, data]) : length2
          };
        }
        if (dynamicChild)
          return { dynamic: true, encoded: data };
      }
      return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function encodeBytes(value, { param }) {
      const [, paramSize] = param.type.split("bytes");
      const bytesSize = (0, size_js_1.size)(value);
      if (!paramSize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
          value_ = (0, pad_js_1.padHex)(value_, {
            dir: "right",
            size: Math.ceil((value.length - 2) / 2 / 32) * 32
          });
        return {
          dynamic: true,
          encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_])
        };
      }
      if (bytesSize !== parseInt(paramSize))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
          expectedSize: parseInt(paramSize),
          value
        });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: "right" }) };
    }
    function encodeBool(value) {
      return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
    }
    function encodeNumber(value, { signed }) {
      return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
          size: 32,
          signed
        })
      };
    }
    function encodeString(value) {
      const hexValue = (0, toHex_js_1.stringToHex)(value);
      const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
      const parts = [];
      for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
          (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
          ...parts
        ])
      };
    }
    function encodeTuple(value, { param }) {
      let dynamic = false;
      const preparedParams = [];
      for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
          param: param_,
          value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
          dynamic = true;
      }
      return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function getArrayComponents(type) {
      const matches = type.match(/^(.*)\[(\d+)?\]$/);
      return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
    }
    exports2.getArrayComponents = getArrayComponents;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getFunctionSelector.js
var require_getFunctionSelector = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/getFunctionSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFunctionSelector = void 0;
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    var keccak256_js_1 = require_keccak256();
    var hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    var getFunctionSelector = (fn) => (0, slice_js_1.slice)(hash((0, getFunctionSignature_js_1.getFunctionSignature)(fn)), 0, 4);
    exports2.getFunctionSelector = getFunctionSelector;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/getAbiItem.js
var require_getAbiItem = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/getAbiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAmbiguousTypes = exports2.isArgOfType = exports2.getAbiItem = void 0;
    var abi_js_1 = require_abi();
    var isHex_js_1 = require_isHex();
    var getEventSelector_js_1 = require_getEventSelector();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var isAddress_js_1 = require_isAddress();
    function getAbiItem({ abi, args = [], name }) {
      const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
      const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
          if (abiItem.type === "function")
            return (0, getFunctionSelector_js_1.getFunctionSelector)(abiItem) === name;
          if (abiItem.type === "event")
            return (0, getEventSelector_js_1.getEventSelector)(abiItem) === name;
          return false;
        }
        return "name" in abiItem && abiItem.name === name;
      });
      if (abiItems.length === 0)
        return void 0;
      if (abiItems.length === 1)
        return abiItems[0];
      let matchedAbiItem = void 0;
      for (const abiItem of abiItems) {
        if (!("inputs" in abiItem))
          continue;
        if (!args || args.length === 0) {
          if (!abiItem.inputs || abiItem.inputs.length === 0)
            return abiItem;
          continue;
        }
        if (!abiItem.inputs)
          continue;
        if (abiItem.inputs.length === 0)
          continue;
        if (abiItem.inputs.length !== args.length)
          continue;
        const matched = args.every((arg, index) => {
          const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
          if (!abiParameter)
            return false;
          return isArgOfType(arg, abiParameter);
        });
        if (matched) {
          if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
            const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
            if (ambiguousTypes)
              throw new abi_js_1.AbiItemAmbiguityError({
                abiItem,
                type: ambiguousTypes[0]
              }, {
                abiItem: matchedAbiItem,
                type: ambiguousTypes[1]
              });
          }
          matchedAbiItem = abiItem;
        }
      }
      if (matchedAbiItem)
        return matchedAbiItem;
      return abiItems[0];
    }
    exports2.getAbiItem = getAbiItem;
    function isArgOfType(arg, abiParameter) {
      const argType = typeof arg;
      const abiParameterType = abiParameter.type;
      switch (abiParameterType) {
        case "address":
          return (0, isAddress_js_1.isAddress)(arg);
        case "bool":
          return argType === "boolean";
        case "function":
          return argType === "string";
        case "string":
          return argType === "string";
        default: {
          if (abiParameterType === "tuple" && "components" in abiParameter)
            return Object.values(abiParameter.components).every((component, index) => {
              return isArgOfType(Object.values(arg)[index], component);
            });
          if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
            return argType === "number" || argType === "bigint";
          if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
            return argType === "string" || arg instanceof Uint8Array;
          if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
            return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
              ...abiParameter,
              type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
            }));
          }
          return false;
        }
      }
    }
    exports2.isArgOfType = isArgOfType;
    function getAmbiguousTypes(sourceParameters, targetParameters, args) {
      for (const parameterIndex in sourceParameters) {
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
          return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [sourceParameter.type, targetParameter.type];
        const ambiguous = (() => {
          if (types.includes("address") && types.includes("bytes20"))
            return true;
          if (types.includes("address") && types.includes("string"))
            return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
          if (types.includes("address") && types.includes("bytes"))
            return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
          return false;
        })();
        if (ambiguous)
          return types;
      }
      return;
    }
    exports2.getAmbiguousTypes = getAmbiguousTypes;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeEventTopics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeEventTopics = void 0;
    var abi_js_1 = require_abi();
    var log_js_1 = require_log();
    var toBytes_js_1 = require_toBytes();
    var getEventSelector_js_1 = require_getEventSelector();
    var keccak256_js_1 = require_keccak256();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeEventTopics({ abi, eventName, args }) {
      let abiItem = abi[0];
      if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: eventName
        });
        if (!abiItem)
          throw new abi_js_1.AbiEventNotFoundError(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
          });
      }
      if (abiItem.type !== "event")
        throw new abi_js_1.AbiEventNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
      let topics = [];
      if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
        if (args_.length > 0) {
          topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
        }
      }
      return [signature, ...topics];
    }
    exports2.encodeEventTopics = encodeEventTopics;
    function encodeArg({ param, value }) {
      if (param.type === "string" || param.type === "bytes")
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
      if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFilterRequestScope = void 0;
    function createFilterRequestScope(client, { method }) {
      const requestMap = {};
      if (client.transport.type === "fallback")
        client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
          if (status === "success" && method === method_)
            requestMap[id] = transport.request;
        });
      return (id) => requestMap[id] || client.request;
    }
    exports2.createFilterRequestScope = createFilterRequestScope;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createContractEventFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createContractEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi,
        args,
        eventName
      }) : void 0;
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            topics
          }
        ]
      });
      return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: "event"
      };
    }
    exports2.createContractEventFilter = createContractEventFilter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/accounts/utils/parseAccount.js
var require_parseAccount = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/accounts/utils/parseAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAccount = void 0;
    function parseAccount(account) {
      if (typeof account === "string")
        return { address: account, type: "json-rpc" };
      return account;
    }
    exports2.parseAccount = parseAccount;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeFunctionData.js
var require_encodeFunctionData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeFunctionData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeFunctionData({ abi, args, functionName }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionData"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      const data = "inputs" in abiItem && abiItem.inputs ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? []) : void 0;
      return (0, concat_js_1.concatHex)([signature, data ?? "0x"]);
    }
    exports2.encodeFunctionData = encodeFunctionData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/solidity.js
var require_solidity = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/solidity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.solidityPanic = exports2.solidityError = exports2.panicReasons = void 0;
    exports2.panicReasons = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    };
    exports2.solidityError = {
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    };
    exports2.solidityPanic = {
      inputs: [
        {
          name: "reason",
          type: "uint256"
        }
      ],
      name: "Panic",
      type: "error"
    };
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/getAddress.js
var require_getAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/getAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAddress = exports2.checksumAddress = void 0;
    var address_js_1 = require_address();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var isAddress_js_1 = require_isAddress();
    function checksumAddress(address_, chainId) {
      const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
      const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), "bytes");
      const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
      for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
          address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
          address[i + 1] = address[i + 1].toUpperCase();
        }
      }
      return `0x${address.join("")}`;
    }
    exports2.checksumAddress = checksumAddress;
    function getAddress(address, chainId) {
      if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
      return checksumAddress(address, chainId);
    }
    exports2.getAddress = getAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js
var require_decodeAbiParameters = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var getAddress_js_1 = require_getAddress();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    function decodeAbiParameters(params, data) {
      if (data === "0x" && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
      if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
          data,
          params,
          size: (0, size_js_1.size)(data)
        });
      return decodeParams({
        data,
        params
      });
    }
    exports2.decodeAbiParameters = decodeAbiParameters;
    function decodeParams({ data, params }) {
      const decodedValues = [];
      let position = 0;
      for (let i = 0; i < params.length; i++) {
        if (position >= (0, size_js_1.size)(data))
          throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data,
            params,
            size: (0, size_js_1.size)(data)
          });
        const param = params[i];
        const { consumed, value } = decodeParam({ data, param, position });
        decodedValues.push(value);
        position += consumed;
      }
      return decodedValues;
    }
    function decodeParam({ data, param, position }) {
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
          length,
          param: { ...param, type },
          position
        });
      }
      if (param.type === "tuple") {
        return decodeTuple(data, { param, position });
      }
      if (param.type === "string") {
        return decodeString(data, { position });
      }
      if (param.type.startsWith("bytes")) {
        return decodeBytes(data, { param, position });
      }
      const value = (0, slice_js_1.slice)(data, position, position + 32, { strict: true });
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        return decodeNumber(value, { param });
      }
      if (param.type === "address") {
        return decodeAddress(value);
      }
      if (param.type === "bool") {
        return decodeBool(value);
      }
      throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
      });
    }
    function decodeAddress(value) {
      return { consumed: 32, value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20)) };
    }
    function decodeArray(data, { param, length, position }) {
      if (!length) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length2 = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length2; ++i) {
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset + 32),
            param,
            position: consumed2
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      if (hasDynamicChild(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length; ++i) {
          const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param,
            position: dynamicChild ? consumed2 : i * 32
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      let consumed = 0;
      const value = [];
      for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam({
          data,
          param,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
      }
      return { value, consumed };
    }
    function decodeBool(value) {
      return { consumed: 32, value: (0, fromHex_js_1.hexToBool)(value) };
    }
    function decodeBytes(data, { param, position }) {
      const [_, size] = param.type.split("bytes");
      if (!size) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        if (length === 0)
          return { consumed: 32, value: "0x" };
        const value2 = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {
          strict: true
        });
        return { consumed: 32, value: value2 };
      }
      const value = (0, slice_js_1.slice)(data, position, position + parseInt(size), {
        strict: true
      });
      return { consumed: 32, value };
    }
    function decodeNumber(value, { param }) {
      const signed = param.type.startsWith("int");
      const size = parseInt(param.type.split("int")[1] || "256");
      return {
        consumed: 32,
        value: size > 48 ? (0, fromHex_js_1.hexToBigInt)(value, { signed }) : (0, fromHex_js_1.hexToNumber)(value, { signed })
      };
    }
    function decodeString(data, { position }) {
      const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
      const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "" };
      const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, { strict: true })));
      return { consumed: 32, value };
    }
    function decodeTuple(data, { param, position }) {
      const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
      const value = hasUnnamedChild ? [] : {};
      let consumed = 0;
      if (hasDynamicChild(param)) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        for (let i = 0; i < param.components.length; ++i) {
          const component = param.components[i];
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param: component,
            position: consumed
          });
          consumed += decodedChild.consumed;
          value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
      }
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
          data,
          param: component,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
      }
      return { consumed, value };
    }
    function hasDynamicChild(param) {
      const { type } = param;
      if (type === "string")
        return true;
      if (type === "bytes")
        return true;
      if (type.endsWith("[]"))
        return true;
      if (type === "tuple")
        return param.components?.some(hasDynamicChild);
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
      return false;
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeErrorResult.js
var require_decodeErrorResult = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeErrorResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeErrorResult = void 0;
    var solidity_js_1 = require_solidity();
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeErrorResult({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      if (signature === "0x")
        throw new abi_js_1.AbiDecodingZeroDataError();
      const abi_ = [...abi || [], solidity_js_1.solidityError, solidity_js_1.solidityPanic];
      const abiItem = abi_.find((x) => x.type === "error" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeErrorResult"
        });
      return {
        abiItem,
        args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : void 0,
        errorName: abiItem.name
      };
    }
    exports2.decodeErrorResult = decodeErrorResult;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = void 0;
    var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js
var require_formatAbiItemWithArgs = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatAbiItemWithArgs = void 0;
    var stringify_js_1 = require_stringify();
    function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
      if (!("name" in abiItem))
        return;
      if (!("inputs" in abiItem))
        return;
      if (!abiItem.inputs)
        return;
      return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`).join(", ")})`;
    }
    exports2.formatAbiItemWithArgs = formatAbiItemWithArgs;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/unit.js
var require_unit = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/unit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.weiUnits = exports2.gweiUnits = exports2.etherUnits = void 0;
    exports2.etherUnits = {
      gwei: 9,
      wei: 18
    };
    exports2.gweiUnits = {
      ether: -9,
      wei: 9
    };
    exports2.weiUnits = {
      ether: -18,
      gwei: -9
    };
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatUnits.js
var require_formatUnits = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatUnits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatUnits = void 0;
    function formatUnits(value, decimals) {
      let display = value.toString();
      const negative = display.startsWith("-");
      if (negative)
        display = display.slice(1);
      display = display.padStart(decimals, "0");
      let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
      ];
      fraction = fraction.replace(/(0+)$/, "");
      return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
    }
    exports2.formatUnits = formatUnits;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatEther.js
var require_formatEther = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatEther.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatEther = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatEther(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
    }
    exports2.formatEther = formatEther;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatGwei.js
var require_formatGwei = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/formatGwei.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatGwei = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatGwei(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
    }
    exports2.formatGwei = formatGwei;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/transaction.js
var require_transaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WaitForTransactionReceiptTimeoutError = exports2.TransactionReceiptNotFoundError = exports2.TransactionNotFoundError = exports2.TransactionExecutionError = exports2.InvalidStorageKeySizeError = exports2.InvalidSerializedTransactionError = exports2.InvalidSerializedTransactionTypeError = exports2.InvalidSerializableTransactionError = exports2.InvalidLegacyVError = exports2.FeeConflictError = exports2.prettyPrint = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    function prettyPrint(args) {
      const entries = Object.entries(args).map(([key, value]) => {
        if (value === void 0 || value === false)
          return null;
        return [key, value];
      }).filter(Boolean);
      const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
      return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
    }
    exports2.prettyPrint = prettyPrint;
    var FeeConflictError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeConflictError"
        });
      }
    };
    exports2.FeeConflictError = FeeConflictError;
    var InvalidLegacyVError = class extends base_js_1.BaseError {
      constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidLegacyVError"
        });
      }
    };
    exports2.InvalidLegacyVError = InvalidLegacyVError;
    var InvalidSerializableTransactionError = class extends base_js_1.BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializableTransactionError"
        });
      }
    };
    exports2.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
    var InvalidSerializedTransactionTypeError = class extends base_js_1.BaseError {
      constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionType"
        });
        Object.defineProperty(this, "serializedType", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedType = serializedType;
      }
    };
    exports2.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
    var InvalidSerializedTransactionError = class extends base_js_1.BaseError {
      constructor({ attributes, serializedTransaction, type }) {
        const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
          metaMessages: [
            `Serialized Transaction: "${serializedTransaction}"`,
            missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionError"
        });
        Object.defineProperty(this, "serializedTransaction", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
      }
    };
    exports2.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
    var InvalidStorageKeySizeError = class extends base_js_1.BaseError {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStorageKeySizeError"
        });
      }
    };
    exports2.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
    var TransactionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint({
          chain: chain && `${chain?.name} (id: ${chain?.id})`,
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Request Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionExecutionError"
        });
        this.cause = cause;
      }
    };
    exports2.TransactionExecutionError = TransactionExecutionError;
    var TransactionNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber, blockTag, hash, index }) {
        let identifier = "Transaction";
        if (blockTag && index !== void 0)
          identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== void 0)
          identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== void 0)
          identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
          identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionNotFoundError"
        });
      }
    };
    exports2.TransactionNotFoundError = TransactionNotFoundError;
    var TransactionReceiptNotFoundError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionReceiptNotFoundError"
        });
      }
    };
    exports2.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
    var WaitForTransactionReceiptTimeoutError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WaitForTransactionReceiptTimeoutError"
        });
      }
    };
    exports2.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/contract.js
var require_contract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/contract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RawContractError = exports2.ContractFunctionZeroDataError = exports2.ContractFunctionRevertedError = exports2.ContractFunctionExecutionError = exports2.CallExecutionError = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var solidity_js_1 = require_solidity();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    var getAbiItem_js_1 = require_getAbiItem();
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction();
    var utils_js_1 = require_utils2();
    var CallExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CallExecutionError"
        });
        this.cause = cause;
      }
    };
    exports2.CallExecutionError = CallExecutionError;
    var ContractFunctionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        const functionWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
          function: functionWithParams,
          args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
          sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Contract Call:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "args", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "functionName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sender", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
      }
    };
    exports2.ContractFunctionExecutionError = ContractFunctionExecutionError;
    var ContractFunctionRevertedError = class extends base_js_1.BaseError {
      constructor({ abi, data, functionName, message }) {
        let cause;
        let decodedData = void 0;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
          try {
            decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = solidity_js_1.panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } catch (err) {
            cause = err;
          }
        } else if (message)
          reason = message;
        let signature;
        if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
          signature = cause.signature;
          metaMessages = [
            `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ];
        }
        super(reason && reason !== "execution reverted" || signature ? [
          `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
          reason || signature
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
          cause,
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reason", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
      }
    };
    exports2.ContractFunctionRevertedError = ContractFunctionRevertedError;
    var ContractFunctionZeroDataError = class extends base_js_1.BaseError {
      constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
          metaMessages: [
            "This could be due to any of the following:",
            `  - The contract does not have the function "${functionName}",`,
            "  - The parameters passed to the contract function may be invalid, or",
            "  - The address is not a contract."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionZeroDataError"
        });
      }
    };
    exports2.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
    var RawContractError = class extends base_js_1.BaseError {
      constructor({ data, message }) {
        super(message || "");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
      }
    };
    exports2.RawContractError = RawContractError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutError = exports2.RpcRequestError = exports2.WebSocketRequestError = exports2.HttpRequestError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils2();
    var HttpRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, headers, status, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${(0, utils_js_1.getUrl)(url)}`,
            body && `Request body: ${(0, stringify_js_1.stringify)(body)}`
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    exports2.HttpRequestError = HttpRequestError;
    var WebSocketRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, url }) {
        super("WebSocket request failed.", {
          details,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebSocketRequestError"
        });
      }
    };
    exports2.WebSocketRequestError = WebSocketRequestError;
    var RpcRequestError = class extends base_js_1.BaseError {
      constructor({ body, error, url }) {
        super("RPC Request failed.", {
          cause: error,
          details: error.message,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error.code;
      }
    };
    exports2.RpcRequestError = RpcRequestError;
    var TimeoutError = class extends base_js_1.BaseError {
      constructor({ body, url }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TimeoutError"
        });
      }
    };
    exports2.TimeoutError = TimeoutError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/rpc.js
var require_rpc = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/rpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownRpcError = exports2.SwitchChainError = exports2.ChainDisconnectedError = exports2.ProviderDisconnectedError = exports2.UnsupportedProviderMethodError = exports2.UnauthorizedProviderError = exports2.UserRejectedRequestError = exports2.JsonRpcVersionUnsupportedError = exports2.LimitExceededRpcError = exports2.MethodNotSupportedRpcError = exports2.TransactionRejectedRpcError = exports2.ResourceUnavailableRpcError = exports2.ResourceNotFoundRpcError = exports2.InvalidInputRpcError = exports2.InternalRpcError = exports2.InvalidParamsRpcError = exports2.MethodNotFoundRpcError = exports2.InvalidRequestRpcError = exports2.ParseRpcError = exports2.ProviderRpcError = exports2.RpcError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var unknownErrorCode = -1;
    var RpcError = class extends base_js_1.BaseError {
      constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath,
          metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode;
      }
    };
    exports2.RpcError = RpcError;
    var ProviderRpcError = class extends RpcError {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    exports2.ProviderRpcError = ProviderRpcError;
    var ParseRpcError = class _ParseRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ParseRpcError.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ParseRpcError"
        });
      }
    };
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    exports2.ParseRpcError = ParseRpcError;
    var InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidRequestRpcError.code,
          shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidRequestRpcError"
        });
      }
    };
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    exports2.InvalidRequestRpcError = InvalidRequestRpcError;
    var MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _MethodNotFoundRpcError.code,
          shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    exports2.MethodNotFoundRpcError = MethodNotFoundRpcError;
    var InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidParamsRpcError.code,
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParamsRpcError"
        });
      }
    };
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    exports2.InvalidParamsRpcError = InvalidParamsRpcError;
    var InternalRpcError = class _InternalRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InternalRpcError.code,
          shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InternalRpcError"
        });
      }
    };
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    exports2.InternalRpcError = InternalRpcError;
    var InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidInputRpcError.code,
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidInputRpcError"
        });
      }
    };
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    exports2.InvalidInputRpcError = InvalidInputRpcError;
    var ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceNotFoundRpcError.code,
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    exports2.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
    var ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceUnavailableRpcError.code,
          shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceUnavailableRpcError"
        });
      }
    };
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    exports2.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
    var TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _TransactionRejectedRpcError.code,
          shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionRejectedRpcError"
        });
      }
    };
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    exports2.TransactionRejectedRpcError = TransactionRejectedRpcError;
    var MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _MethodNotSupportedRpcError.code,
          shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotSupportedRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    exports2.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
    var LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _LimitExceededRpcError.code,
          shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "LimitExceededRpcError"
        });
      }
    };
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    exports2.LimitExceededRpcError = LimitExceededRpcError;
    var JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _JsonRpcVersionUnsupportedError.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "JsonRpcVersionUnsupportedError"
        });
      }
    };
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    exports2.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
    var UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UserRejectedRequestError.code,
          shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UserRejectedRequestError"
        });
      }
    };
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    exports2.UserRejectedRequestError = UserRejectedRequestError;
    var UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnauthorizedProviderError.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnauthorizedProviderError"
        });
      }
    };
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    exports2.UnauthorizedProviderError = UnauthorizedProviderError;
    var UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnsupportedProviderMethodError.code,
          shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedProviderMethodError"
        });
      }
    };
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    exports2.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
    var ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ProviderDisconnectedError.code,
          shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderDisconnectedError"
        });
      }
    };
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    exports2.ProviderDisconnectedError = ProviderDisconnectedError;
    var ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ChainDisconnectedError.code,
          shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDisconnectedError"
        });
      }
    };
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    exports2.ChainDisconnectedError = ChainDisconnectedError;
    var SwitchChainError = class _SwitchChainError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _SwitchChainError.code,
          shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SwitchChainError"
        });
      }
    };
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    exports2.SwitchChainError = SwitchChainError;
    var UnknownRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          shortMessage: "An unknown RPC error occurred."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownRpcError"
        });
      }
    };
    exports2.UnknownRpcError = UnknownRpcError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getContractError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getContractError = void 0;
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var rpc_js_1 = require_rpc();
    var EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
      const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
      const cause = (() => {
        if (err instanceof abi_js_1.AbiDecodingZeroDataError)
          return new contract_js_1.ContractFunctionZeroDataError({ functionName });
        if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1.InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
          return new contract_js_1.ContractFunctionRevertedError({
            abi,
            data: typeof data === "object" ? data.data : data,
            functionName,
            message: shortMessage ?? message
          });
        }
        return err;
      })();
      return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
      });
    }
    exports2.getContractError = getContractError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/account.js
var require_account = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/account.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountNotFoundError = void 0;
    var base_js_1 = require_base();
    var AccountNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
    exports2.AccountNotFoundError = AccountNotFoundError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/estimateGas.js
var require_estimateGas = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/estimateGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EstimateGasExecutionError = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction();
    var EstimateGasExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
    exports2.EstimateGasExecutionError = EstimateGasExecutionError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownNodeError = exports2.TipAboveFeeCapError = exports2.TransactionTypeNotSupportedError = exports2.IntrinsicGasTooLowError = exports2.IntrinsicGasTooHighError = exports2.InsufficientFundsError = exports2.NonceMaxValueError = exports2.NonceTooLowError = exports2.NonceTooHighError = exports2.FeeCapTooLowError = exports2.FeeCapTooHighError = exports2.ExecutionRevertedError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var ExecutionRevertedError = class extends base_js_1.BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    exports2.ExecutionRevertedError = ExecutionRevertedError;
    var FeeCapTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooHigh"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    exports2.FeeCapTooHighError = FeeCapTooHighError;
    var FeeCapTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooLow"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    exports2.FeeCapTooLowError = FeeCapTooLowError;
    var NonceTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooHighError"
        });
      }
    };
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    exports2.NonceTooHighError = NonceTooHighError;
    var NonceTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooLowError"
        });
      }
    };
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    exports2.NonceTooLowError = NonceTooLowError;
    var NonceMaxValueError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceMaxValueError"
        });
      }
    };
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    exports2.NonceMaxValueError = NonceMaxValueError;
    var InsufficientFundsError = class extends base_js_1.BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds/
    });
    exports2.InsufficientFundsError = InsufficientFundsError;
    var IntrinsicGasTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    exports2.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
    var IntrinsicGasTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    exports2.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
    var TransactionTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    exports2.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
    var TipAboveFeeCapError = class extends base_js_1.BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    exports2.TipAboveFeeCapError = TipAboveFeeCapError;
    var UnknownNodeError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownNodeError"
        });
      }
    };
    exports2.UnknownNodeError = UnknownNodeError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getNodeError.js
var require_getNodeError = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getNodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNodeError = exports2.containsNodeError = void 0;
    var base_js_1 = require_base();
    var node_js_1 = require_node();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    function containsNodeError(err) {
      return err instanceof rpc_js_1.TransactionRejectedRpcError || err instanceof rpc_js_1.InvalidInputRpcError || err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code;
    }
    exports2.containsNodeError = containsNodeError;
    function getNodeError(err, args) {
      const message = (err.details || "").toLowerCase();
      const executionRevertedError = err.walk((e) => e.code === node_js_1.ExecutionRevertedError.code);
      if (executionRevertedError instanceof base_js_1.BaseError) {
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: executionRevertedError.details
        });
      }
      if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: err.details
        });
      if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
      if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
      if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
      if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
      if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
      if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
      if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
      if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas,
          maxPriorityFeePerGas: args?.maxPriorityFeePerGas
        });
      return new node_js_1.UnknownNodeError({
        cause: err
      });
    }
    exports2.getNodeError = getNodeError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getEstimateGasError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEstimateGasError = void 0;
    var estimateGas_js_1 = require_estimateGas();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getEstimateGasError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports2.getEstimateGasError = getEstimateGasError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/extract.js
var require_extract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/extract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extract = void 0;
    function extract(value_, { format }) {
      if (!format)
        return {};
      const value = {};
      function extract_(formatted2) {
        const keys = Object.keys(formatted2);
        for (const key of keys) {
          if (key in value_)
            value[key] = value_[key];
          if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
            extract_(formatted2[key]);
        }
      }
      const formatted = format(value_ || {});
      extract_(formatted);
      return value;
    }
    exports2.extract = extract;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/formatter.js
var require_formatter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/formatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineFormatter = void 0;
    function defineFormatter(type, format) {
      return ({ exclude, format: overrides }) => {
        return {
          exclude,
          format: (args) => {
            const formatted = format(args);
            if (exclude) {
              for (const key of exclude) {
                delete formatted[key];
              }
            }
            return {
              ...formatted,
              ...overrides(args)
            };
          },
          type
        };
      };
    }
    exports2.defineFormatter = defineFormatter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transactionRequest.js
var require_transactionRequest = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transactionRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineTransactionRequest = exports2.formatTransactionRequest = exports2.rpcTransactionType = void 0;
    var toHex_js_1 = require_toHex();
    var formatter_js_1 = require_formatter();
    exports2.rpcTransactionType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2"
    };
    function formatTransactionRequest(transactionRequest) {
      return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gas) : void 0,
        gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gasPrice) : void 0,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxPriorityFeePerGas) : void 0,
        nonce: typeof transactionRequest.nonce !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.nonce) : void 0,
        type: typeof transactionRequest.type !== "undefined" ? exports2.rpcTransactionType[transactionRequest.type] : void 0,
        value: typeof transactionRequest.value !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.value) : void 0
      };
    }
    exports2.formatTransactionRequest = formatTransactionRequest;
    exports2.defineTransactionRequest = (0, formatter_js_1.defineFormatter)("transactionRequest", formatTransactionRequest);
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/assertRequest.js
var require_assertRequest = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/assertRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var address_js_1 = require_address();
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    function assertRequest(args) {
      const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
        throw new transaction_js_1.FeeConflictError();
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports2.assertRequest = assertRequest;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/fee.js
var require_fee = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/fee.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxFeePerGasTooLowError = exports2.Eip1559FeesNotSupportedError = exports2.BaseFeeScalarError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var BaseFeeScalarError = class extends base_js_1.BaseError {
      constructor() {
        super("`baseFeeMultiplier` must be greater than 1.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseFeeScalarError"
        });
      }
    };
    exports2.BaseFeeScalarError = BaseFeeScalarError;
    var Eip1559FeesNotSupportedError = class extends base_js_1.BaseError {
      constructor() {
        super("Chain does not support EIP-1559 fees.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Eip1559FeesNotSupportedError"
        });
      }
    };
    exports2.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
    var MaxFeePerGasTooLowError = class extends base_js_1.BaseError {
      constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MaxFeePerGasTooLowError"
        });
      }
    };
    exports2.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/block.js
var require_block = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlockNotFoundError = void 0;
    var base_js_1 = require_base();
    var BlockNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
    exports2.BlockNotFoundError = BlockNotFoundError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineTransaction = exports2.formatTransaction = exports2.transactionType = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    exports2.transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction(transaction) {
      const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : void 0,
        gas: transaction.gas ? BigInt(transaction.gas) : void 0,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : void 0,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? exports2.transactionType[transaction.type] : void 0,
        typeHex: transaction.type ? transaction.type : void 0,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        v: transaction.v ? BigInt(transaction.v) : void 0
      };
      transaction_.yParity = (() => {
        if (transaction.yParity)
          return Number(transaction.yParity);
        if (typeof transaction_.v === "bigint") {
          if (transaction_.v === 0n || transaction_.v === 27n)
            return 0;
          if (transaction_.v === 1n || transaction_.v === 28n)
            return 1;
          if (transaction_.v >= 35n)
            return transaction_.v % 2n === 0n ? 1 : 0;
        }
        return void 0;
      })();
      if (transaction_.type === "legacy") {
        delete transaction_.accessList;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
        delete transaction_.yParity;
      }
      if (transaction_.type === "eip2930") {
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
      }
      return transaction_;
    }
    exports2.formatTransaction = formatTransaction;
    exports2.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction);
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/block.js
var require_block2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineBlock = exports2.formatBlock = void 0;
    var formatter_js_1 = require_formatter();
    var transaction_js_1 = require_transaction2();
    function formatBlock(block) {
      const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
      });
      return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : void 0,
        timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
      };
    }
    exports2.formatBlock = formatBlock;
    exports2.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock);
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlock.js
var require_getBlock = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlock = void 0;
    var block_js_1 = require_block();
    var toHex_js_1 = require_toHex();
    var block_js_2 = require_block2();
    async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
      const blockTag = blockTag_ ?? "latest";
      const includeTransactions = includeTransactions_ ?? false;
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let block = null;
      if (blockHash) {
        block = await client.request({
          method: "eth_getBlockByHash",
          params: [blockHash, includeTransactions]
        });
      } else {
        block = await client.request({
          method: "eth_getBlockByNumber",
          params: [blockNumberHex || blockTag, includeTransactions]
        });
      }
      if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
      const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
      return format(block);
    }
    exports2.getBlock = getBlock;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getGasPrice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGasPrice = void 0;
    async function getGasPrice(client) {
      const gasPrice = await client.request({
        method: "eth_gasPrice"
      });
      return BigInt(gasPrice);
    }
    exports2.getGasPrice = getGasPrice;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js
var require_estimateMaxPriorityFeePerGas = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.internal_estimateMaxPriorityFeePerGas = exports2.estimateMaxPriorityFeePerGas = void 0;
    var fee_js_1 = require_fee();
    var fromHex_js_1 = require_fromHex();
    var getAction_js_1 = require_getAction();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateMaxPriorityFeePerGas(client, args) {
      return internal_estimateMaxPriorityFeePerGas(client, args);
    }
    exports2.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
    async function internal_estimateMaxPriorityFeePerGas(client, args) {
      const { block: block_, chain = client.chain, request } = args || {};
      if (typeof chain?.fees?.defaultPriorityFee === "function") {
        const block = block_ || await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
        return chain.fees.defaultPriorityFee({
          block,
          client,
          request
        });
      }
      if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
        return chain?.fees?.defaultPriorityFee;
      try {
        const maxPriorityFeePerGasHex = await client.request({
          method: "eth_maxPriorityFeePerGas"
        });
        return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
      } catch {
        const [block, gasPrice] = await Promise.all([
          block_ ? Promise.resolve(block_) : (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({}),
          (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({})
        ]);
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n)
          return 0n;
        return maxPriorityFeePerGas;
      }
    }
    exports2.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js
var require_estimateFeesPerGas = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.internal_estimateFeesPerGas = exports2.estimateFeesPerGas = void 0;
    var fee_js_1 = require_fee();
    var getAction_js_1 = require_getAction();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateFeesPerGas(client, args) {
      return internal_estimateFeesPerGas(client, args);
    }
    exports2.estimateFeesPerGas = estimateFeesPerGas;
    async function internal_estimateFeesPerGas(client, args) {
      const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
      const baseFeeMultiplier = await (async () => {
        if (typeof chain?.fees?.baseFeeMultiplier === "function")
          return chain.fees.baseFeeMultiplier({
            block: block_,
            client,
            request
          });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
      })();
      if (baseFeeMultiplier < 1)
        throw new fee_js_1.BaseFeeScalarError();
      const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
      const denominator = 10 ** decimals;
      const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
      const block = block_ ? block_ : await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
      if (typeof chain?.fees?.estimateFeesPerGas === "function")
        return chain.fees.estimateFeesPerGas({
          block: block_,
          client,
          multiply,
          request,
          type
        });
      if (type === "eip1559") {
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = request?.maxPriorityFeePerGas ? request.maxPriorityFeePerGas : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
          block,
          chain,
          request
        });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
          maxFeePerGas,
          maxPriorityFeePerGas
        };
      }
      const gasPrice = request?.gasPrice ?? multiply(await (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({}));
      return {
        gasPrice
      };
    }
    exports2.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
      const count = await client.request({
        method: "eth_getTransactionCount",
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
      });
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports2.getTransactionCount = getTransactionCount;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/getTransactionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    function getTransactionType(transaction) {
      if (transaction.type)
        return transaction.type;
      if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
        return "eip1559";
      if (typeof transaction.gasPrice !== "undefined") {
        if (typeof transaction.accessList !== "undefined")
          return "eip2930";
        return "legacy";
      }
      throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
    }
    exports2.getTransactionType = getTransactionType;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js
var require_prepareTransactionRequest = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareTransactionRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var getBlock_js_1 = require_getBlock();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var account_js_1 = require_account();
    var fee_js_1 = require_fee();
    var getAction_js_1 = require_getAction();
    var assertRequest_js_1 = require_assertRequest();
    var getTransactionType_js_1 = require_getTransactionType();
    async function prepareTransactionRequest(client, args) {
      const { account: account_ = client.account, chain, gas, nonce, type } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError();
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({ blockTag: "latest" });
      const request = { ...args, from: account.address };
      if (typeof nonce === "undefined")
        request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, "getTransactionCount")({
          address: account.address,
          blockTag: "pending"
        });
      if (typeof type === "undefined") {
        try {
          request.type = (0, getTransactionType_js_1.getTransactionType)(request);
        } catch {
          request.type = typeof block.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
        }
      }
      if (request.type === "eip1559") {
        const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new fee_js_1.MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
      if (typeof gas === "undefined")
        request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
          ...request,
          account: { address: account.address, type: "json-rpc" }
        });
      (0, assertRequest_js_1.assertRequest)(request);
      return request;
    }
    exports2.prepareTransactionRequest = prepareTransactionRequest;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.estimateGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    async function estimateGas(client, args) {
      const account_ = args.account ?? client.account;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/public/estimateGas"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          from: account.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        const balance = await client.request({
          method: "eth_estimateGas",
          params: block ? [request, block] : [request]
        });
        return BigInt(balance);
      } catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports2.estimateGas = estimateGas;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/estimateContractGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.estimateContractGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var estimateGas_js_1 = require_estimateGas2();
    async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
          data,
          to: address,
          ...request
        });
        return gas;
      } catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : void 0;
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/estimateContractGas",
          functionName,
          sender: account?.address
        });
      }
    }
    exports2.estimateContractGas = estimateContractGas;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeEventLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeEventLog = void 0;
    var abi_js_1 = require_abi();
    var getEventSelector_js_1 = require_getEventSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var docsPath = "/docs/contract/decodeEventLog";
    function decodeEventLog({ abi, data, strict: strict_, topics }) {
      const strict = strict_ ?? true;
      const [signature, ...argTopics] = topics;
      if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
          docsPath
        });
      const abiItem = abi.find((x) => x.type === "event" && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
          docsPath
        });
      const { name, inputs } = abiItem;
      const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
      let args = isUnnamed ? [] : {};
      const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
      for (let i = 0; i < indexedInputs.length; i++) {
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic)
          throw new abi_js_1.DecodeLogTopicsMismatch({
            abiItem,
            param
          });
        args[param.name || i] = decodeTopic({ param, value: topic });
      }
      const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
      if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") {
          try {
            const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
              if (isUnnamed)
                args = [...args, ...decodedData];
              else {
                for (let i = 0; i < nonIndexedInputs.length; i++) {
                  args[nonIndexedInputs[i].name] = decodedData[i];
                }
              }
            }
          } catch (err) {
            if (strict) {
              if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                throw new abi_js_1.DecodeLogDataMismatch({
                  abiItem,
                  data: err.data,
                  params: err.params,
                  size: err.size
                });
              throw err;
            }
          }
        } else if (strict) {
          throw new abi_js_1.DecodeLogDataMismatch({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
          });
        }
      }
      return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : void 0
      };
    }
    exports2.decodeEventLog = decodeEventLog;
    function decodeTopic({ param, value }) {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
      const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
      return decodedArg[0];
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/log.js
var require_log2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLog = void 0;
    function formatLog(log, { args, eventName } = {}) {
      return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? { args, eventName } : {}
      };
    }
    exports2.formatLog = formatLog;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getLogs.js
var require_getLogs = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getLogs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var log_js_1 = require_log2();
    async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
      const strict = strict_ ?? false;
      const events = events_ ?? (event ? [event] : void 0);
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      let logs;
      if (blockHash) {
        logs = await client.request({
          method: "eth_getLogs",
          params: [{ address, topics, blockHash }]
        });
      } else {
        logs = await client.request({
          method: "eth_getLogs",
          params: [
            {
              address,
              topics,
              fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
              toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
            }
          ]
        });
      }
      return logs.map((log) => {
        try {
          const { eventName, args: args2 } = events ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: events,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args: args2, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if (strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports2.getLogs = getLogs;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getContractEvents.js
var require_getContractEvents = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getContractEvents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getContractEvents = void 0;
    var getAbiItem_js_1 = require_getAbiItem();
    var getAction_js_1 = require_getAction();
    var getLogs_js_1 = require_getLogs();
    async function getContractEvents(client, { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict }) {
      const event = eventName ? (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName }) : void 0;
      const events = !event ? abi.filter((x) => x.type === "event") : void 0;
      return (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict
      });
    }
    exports2.getContractEvents = getContractEvents;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js
var require_decodeFunctionResult = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/decodeFunctionResult";
    function decodeFunctionResult({ abi, args, functionName, data }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, { docsPath });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
      if (values && values.length > 1)
        return values;
      if (values && values.length === 1)
        return values[0];
      return void 0;
    }
    exports2.decodeFunctionResult = decodeFunctionResult;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/abis.js
var require_abis = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/abis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.universalSignatureValidatorAbi = exports2.smartAccountAbi = exports2.addressResolverAbi = exports2.textResolverAbi = exports2.universalResolverReverseAbi = exports2.universalResolverResolveAbi = exports2.multicall3Abi = void 0;
    exports2.multicall3Abi = [
      {
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "allowFailure",
                type: "bool"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        name: "aggregate3",
        outputs: [
          {
            components: [
              {
                name: "success",
                type: "bool"
              },
              {
                name: "returnData",
                type: "bytes"
              }
            ],
            name: "returnData",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var universalResolverErrors = [
      {
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
      },
      {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
      }
    ];
    exports2.universalResolverResolveAbi = [
      ...universalResolverErrors,
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ];
    exports2.universalResolverReverseAbi = [
      ...universalResolverErrors,
      {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{ type: "bytes", name: "reverseName" }],
        outputs: [
          { type: "string", name: "resolvedName" },
          { type: "address", name: "resolvedAddress" },
          { type: "address", name: "reverseResolver" },
          { type: "address", name: "resolver" }
        ]
      }
    ];
    exports2.textResolverAbi = [
      {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "key", type: "string" }
        ],
        outputs: [{ name: "", type: "string" }]
      }
    ];
    exports2.addressResolverAbi = [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "name", type: "bytes32" }],
        outputs: [{ name: "", type: "address" }]
      },
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "coinType", type: "uint256" }
        ],
        outputs: [{ name: "", type: "bytes" }]
      }
    ];
    exports2.smartAccountAbi = [
      {
        name: "isValidSignature",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "hash", type: "bytes32" },
          { name: "signature", type: "bytes" }
        ],
        outputs: [{ name: "", type: "bytes4" }]
      }
    ];
    exports2.universalSignatureValidatorAbi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_signer",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_hash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      }
    ];
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/contract.js
var require_contract2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/contract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aggregate3Signature = void 0;
    exports2.aggregate3Signature = "0x82ad56cb";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/chain.js
var require_chain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/chain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidChainIdError = exports2.ClientChainNotConfiguredError = exports2.ChainNotFoundError = exports2.ChainMismatchError = exports2.ChainDoesNotSupportContract = void 0;
    var base_js_1 = require_base();
    var ChainDoesNotSupportContract = class extends base_js_1.BaseError {
      constructor({ blockNumber, chain, contract }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
          metaMessages: [
            "This could be due to any of the following:",
            ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
              `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
            ] : [
              `- The chain does not have the contract "${contract.name}" configured.`
            ]
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDoesNotSupportContract"
        });
      }
    };
    exports2.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
    var ChainMismatchError = class extends base_js_1.BaseError {
      constructor({ chain, currentChainId }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
          metaMessages: [
            `Current Chain ID:  ${currentChainId}`,
            `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainMismatchError"
        });
      }
    };
    exports2.ChainMismatchError = ChainMismatchError;
    var ChainNotFoundError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "No chain was provided to the request.",
          "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainNotFoundError"
        });
      }
    };
    exports2.ChainNotFoundError = ChainNotFoundError;
    var ClientChainNotConfiguredError = class extends base_js_1.BaseError {
      constructor() {
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ClientChainNotConfiguredError"
        });
      }
    };
    exports2.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
    var InvalidChainIdError = class extends base_js_1.BaseError {
      constructor({ chainId }) {
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidChainIdError"
        });
      }
    };
    exports2.InvalidChainIdError = InvalidChainIdError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/getChainContractAddress.js
var require_getChainContractAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/getChainContractAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChainContractAddress = void 0;
    var chain_js_1 = require_chain();
    function getChainContractAddress({ blockNumber, chain, contract: name }) {
      const contract = chain?.contracts?.[name];
      if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
          chain,
          contract: { name }
        });
      if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
          blockNumber,
          chain,
          contract: {
            name,
            blockCreated: contract.blockCreated
          }
        });
      return contract.address;
    }
    exports2.getChainContractAddress = getChainContractAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getCallError.js
var require_getCallError = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getCallError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCallError = void 0;
    var contract_js_1 = require_contract();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getCallError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new contract_js_1.CallExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports2.getCallError = getCallError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/createBatchScheduler.js
var require_createBatchScheduler = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/createBatchScheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBatchScheduler = void 0;
    var schedulerCache = /* @__PURE__ */ new Map();
    function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
      const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args: args2 }) => args2);
        if (args.length === 0)
          return;
        fn(args).then((data) => {
          if (sort && Array.isArray(data))
            data.sort(sort);
          for (let i = 0; i < scheduler.length; i++) {
            const { pendingPromise } = scheduler[i];
            pendingPromise.resolve?.([data[i], data]);
          }
        }).catch((err) => {
          for (let i = 0; i < scheduler.length; i++) {
            const { pendingPromise } = scheduler[i];
            pendingPromise.reject?.(err);
          }
        });
      };
      const flush = () => schedulerCache.delete(id);
      const getBatchedArgs = () => getScheduler().map(({ args }) => args);
      const getScheduler = () => schedulerCache.get(id) || [];
      const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
      return {
        flush,
        async schedule(args) {
          const pendingPromise = {};
          const promise = new Promise((resolve, reject) => {
            pendingPromise.resolve = resolve;
            pendingPromise.reject = reject;
          });
          const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
          if (split)
            exec();
          const hasActiveScheduler = getScheduler().length > 0;
          if (hasActiveScheduler) {
            setScheduler({ args, pendingPromise });
            return promise;
          }
          setScheduler({ args, pendingPromise });
          setTimeout(exec, wait);
          return promise;
        }
      };
    }
    exports2.createBatchScheduler = createBatchScheduler;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/ccip.js
var require_ccip = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/ccip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OffchainLookupSenderMismatchError = exports2.OffchainLookupResponseMalformedError = exports2.OffchainLookupError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils2();
    var OffchainLookupError = class extends base_js_1.BaseError {
      constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
        super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
          cause,
          metaMessages: [
            ...cause.metaMessages || [],
            cause.metaMessages?.length ? "" : [],
            "Offchain Gateway Call:",
            urls && [
              "  Gateway URL(s):",
              ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`)
            ],
            `  Sender: ${sender}`,
            `  Data: ${data}`,
            `  Callback selector: ${callbackSelector}`,
            `  Extra data: ${extraData}`
          ].flat()
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupError"
        });
      }
    };
    exports2.OffchainLookupError = OffchainLookupError;
    var OffchainLookupResponseMalformedError = class extends base_js_1.BaseError {
      constructor({ result, url }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
          metaMessages: [
            `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
            `Response: ${(0, stringify_js_1.stringify)(result)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupResponseMalformedError"
        });
      }
    };
    exports2.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
    var OffchainLookupSenderMismatchError = class extends base_js_1.BaseError {
      constructor({ sender, to }) {
        super("Reverted sender address does not match target contract address (`to`).", {
          metaMessages: [
            `Contract address: ${to}`,
            `OffchainLookup sender address: ${sender}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupSenderMismatchError"
        });
      }
    };
    exports2.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/isAddressEqual.js
var require_isAddressEqual = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/isAddressEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAddressEqual = void 0;
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    function isAddressEqual(a, b) {
      if (!(0, isAddress_js_1.isAddress)(a))
        throw new address_js_1.InvalidAddressError({ address: a });
      if (!(0, isAddress_js_1.isAddress)(b))
        throw new address_js_1.InvalidAddressError({ address: b });
      return a.toLowerCase() === b.toLowerCase();
    }
    exports2.isAddressEqual = isAddressEqual;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ccip.js
var require_ccip2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ccip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ccipFetch = exports2.offchainLookup = exports2.offchainLookupAbiItem = exports2.offchainLookupSignature = void 0;
    var call_js_1 = require_call();
    var ccip_js_1 = require_ccip();
    var request_js_1 = require_request();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var concat_js_1 = require_concat();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    exports2.offchainLookupSignature = "0x556f1830";
    exports2.offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
    async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
      const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports2.offchainLookupAbiItem]
      });
      const [sender, urls, callData, callbackSelector, extraData] = args;
      try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
          throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
          blockNumber,
          blockTag,
          data: (0, concat_js_1.concat)([
            callbackSelector,
            (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
          ]),
          to
        });
        return data_;
      } catch (err) {
        throw new ccip_js_1.OffchainLookupError({
          callbackSelector,
          cause: err,
          data,
          extraData,
          sender,
          urls
        });
      }
    }
    exports2.offchainLookup = offchainLookup;
    async function ccipFetch({ data, sender, urls }) {
      let error = new Error("An unknown error occurred.");
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes("{data}") ? "GET" : "POST";
        const body = method === "POST" ? { data, sender } : void 0;
        try {
          const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
            body: JSON.stringify(body),
            method
          });
          let result;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            result = (await response.json()).data;
          } else {
            result = await response.text();
          }
          if (!response.ok) {
            error = new request_js_1.HttpRequestError({
              body,
              details: result?.error ? (0, stringify_js_1.stringify)(result.error) : response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
            continue;
          }
          if (!(0, isHex_js_1.isHex)(result)) {
            error = new ccip_js_1.OffchainLookupResponseMalformedError({
              result,
              url
            });
            continue;
          }
          return result;
        } catch (err) {
          error = new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
      throw error;
    }
    exports2.ccipFetch = ccipFetch;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/call.js
var require_call = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRevertErrorData = exports2.call = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var abis_js_1 = require_abis();
    var contract_js_1 = require_contract2();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var contract_js_2 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var getCallError_js_1 = require_getCallError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var assertRequest_js_1 = require_assertRequest();
    async function call(client, args) {
      const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          from: account?.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        if (batch && shouldPerformMulticall({ request })) {
          try {
            return await scheduleMulticall(client, {
              ...request,
              blockNumber,
              blockTag
            });
          } catch (err) {
            if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract))
              throw err;
          }
        }
        const response = await client.request({
          method: "eth_call",
          params: block ? [request, block] : [request]
        });
        if (response === "0x")
          return { data: void 0 };
        return { data: response };
      } catch (err) {
        const data2 = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => require_ccip2());
        if (data2?.slice(0, 10) === offchainLookupSignature && to) {
          return { data: await offchainLookup(client, { data: data2, to }) };
        }
        throw (0, getCallError_js_1.getCallError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports2.call = call;
    function shouldPerformMulticall({ request }) {
      const { data, to, ...request_ } = request;
      if (!data)
        return false;
      if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
      if (!to)
        return false;
      if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
        return false;
      return true;
    }
    async function scheduleMulticall(client, args) {
      const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
      const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new chain_js_1.ClientChainNotConfiguredError();
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args2) {
          const size = args2.reduce((size2, { data: data2 }) => size2 + (data2.length - 2), 0);
          return size > batchSize * 2;
        },
        fn: async (requests) => {
          const calls = requests.map((request) => ({
            allowFailure: true,
            callData: request.data,
            target: request.to
          }));
          const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3"
          });
          const data2 = await client.request({
            method: "eth_call",
            params: [
              {
                data: calldata,
                to: multicallAddress
              },
              block
            ]
          });
          return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3",
            data: data2 || "0x"
          });
        }
      });
      const [{ returnData, success }] = await schedule({ data, to });
      if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
      if (returnData === "0x")
        return { data: void 0 };
      return { data: returnData };
    }
    function getRevertErrorData(err) {
      if (!(err instanceof base_js_1.BaseError))
        return void 0;
      const error = err.walk();
      return typeof error.data === "object" ? error.data.data : error.data;
    }
    exports2.getRevertErrorData = getRevertErrorData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/readContract.js
var require_readContract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/readContract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readContract = void 0;
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var call_js_1 = require_call();
    async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          data: calldata,
          to: address,
          ...callRequest
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/readContract",
          functionName
        });
      }
    }
    exports2.readContract = readContract;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/simulateContract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simulateContract = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var call_js_1 = require_call();
    async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
      const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : void 0;
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          batch: false,
          data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
          to: address,
          ...callRequest
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
        return {
          result,
          request: {
            abi,
            address,
            args,
            dataSuffix,
            functionName,
            ...callRequest
          }
        };
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports2.simulateContract = simulateContract;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/observe.js
var require_observe = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/observe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observe = exports2.cleanupCache = exports2.listenersCache = void 0;
    exports2.listenersCache = /* @__PURE__ */ new Map();
    exports2.cleanupCache = /* @__PURE__ */ new Map();
    var callbackCount = 0;
    function observe(observerId, callbacks, fn) {
      const callbackId = ++callbackCount;
      const getListeners = () => exports2.listenersCache.get(observerId) || [];
      const unsubscribe = () => {
        const listeners2 = getListeners();
        exports2.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
      };
      const unwatch = () => {
        const cleanup2 = exports2.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup2)
          cleanup2();
        unsubscribe();
      };
      const listeners = getListeners();
      exports2.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks }
      ]);
      if (listeners && listeners.length > 0)
        return unwatch;
      const emit = {};
      for (const key in callbacks) {
        emit[key] = (...args) => {
          const listeners2 = getListeners();
          if (listeners2.length === 0)
            return;
          for (const listener of listeners2)
            listener.fns[key]?.(...args);
        };
      }
      const cleanup = fn(emit);
      if (typeof cleanup === "function")
        exports2.cleanupCache.set(observerId, cleanup);
      return unwatch;
    }
    exports2.observe = observe;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/wait.js
var require_wait = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/wait.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wait = void 0;
    async function wait(time) {
      return new Promise((res) => setTimeout(res, time));
    }
    exports2.wait = wait;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/poll.js
var require_poll = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/poll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.poll = void 0;
    var wait_js_1 = require_wait();
    function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
      let active = true;
      const unwatch = () => active = false;
      const watch = async () => {
        let data = void 0;
        if (emitOnBegin)
          data = await fn({ unpoll: unwatch });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll2 = async () => {
          if (!active)
            return;
          await fn({ unpoll: unwatch });
          await (0, wait_js_1.wait)(interval);
          poll2();
        };
        poll2();
      };
      watch();
      return unwatch;
    }
    exports2.poll = poll;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withCache.js
var require_withCache = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCache = exports2.getCache = exports2.responseCache = exports2.promiseCache = void 0;
    exports2.promiseCache = /* @__PURE__ */ new Map();
    exports2.responseCache = /* @__PURE__ */ new Map();
    function getCache(cacheKey) {
      const buildCache = (cacheKey2, cache) => ({
        clear: () => cache.delete(cacheKey2),
        get: () => cache.get(cacheKey2),
        set: (data) => cache.set(cacheKey2, data)
      });
      const promise = buildCache(cacheKey, exports2.promiseCache);
      const response = buildCache(cacheKey, exports2.responseCache);
      return {
        clear: () => {
          promise.clear();
          response.clear();
        },
        promise,
        response
      };
    }
    exports2.getCache = getCache;
    async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
      const cache = getCache(cacheKey);
      const response = cache.response.get();
      if (response && cacheTime > 0) {
        const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
        if (age < cacheTime)
          return response.data;
      }
      let promise = cache.promise.get();
      if (!promise) {
        promise = fn();
        cache.promise.set(promise);
      }
      try {
        const data = await promise;
        cache.response.set({ created: /* @__PURE__ */ new Date(), data });
        return data;
      } finally {
        cache.promise.clear();
      }
    }
    exports2.withCache = withCache;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlockNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockNumber = exports2.getBlockNumberCache = void 0;
    var withCache_js_1 = require_withCache();
    var cacheKey = (id) => `blockNumber.${id}`;
    function getBlockNumberCache(id) {
      return (0, withCache_js_1.getCache)(cacheKey(id));
    }
    exports2.getBlockNumberCache = getBlockNumberCache;
    async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
      const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: "eth_blockNumber"
      }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
      return BigInt(blockNumberHex);
    }
    exports2.getBlockNumber = getBlockNumber;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFilterChanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilterChanges = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterChanges(_client, { filter }) {
      const strict = "strict" in filter && filter.strict;
      const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [filter.id]
      });
      return logs.map((log) => {
        if (typeof log === "string")
          return log;
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports2.getFilterChanges = getFilterChanges;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/uninstallFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uninstallFilter = void 0;
    async function uninstallFilter(_client, { filter }) {
      return filter.request({
        method: "eth_uninstallFilter",
        params: [filter.id]
      });
    }
    exports2.uninstallFilter = uninstallFilter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchContractEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchContractEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var log_js_1 = require_log2();
    var getAction_js_1 = require_getAction();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getContractEvents_js_1 = require_getContractEvents();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollContractEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchContractEvent",
          address,
          args,
          batch,
          client.uid,
          eventName,
          pollingInterval
        ]);
        const strict = strict_ ?? false;
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                  abi,
                  address,
                  args,
                  eventName,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              } else {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                    abi,
                    address,
                    args,
                    eventName,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber,
                    strict
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                for (const log of logs)
                  emit.onLogs([log]);
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribeContractEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
              abi,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = (0, decodeEventLog_js_1.decodeEventLog)({
                    abi,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollContractEvent() : subscribeContractEvent();
    }
    exports2.watchContractEvent = watchContractEvent;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/assertCurrentChain.js
var require_assertCurrentChain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/assertCurrentChain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertCurrentChain = void 0;
    var chain_js_1 = require_chain();
    function assertCurrentChain({ chain, currentChainId }) {
      if (!chain)
        throw new chain_js_1.ChainNotFoundError();
      if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
    }
    exports2.assertCurrentChain = assertCurrentChain;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/errors/getTransactionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionError = void 0;
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction();
    var getNodeError_js_1 = require_getNodeError();
    function getTransactionError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports2.getTransactionError = getTransactionError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getChainId.js
var require_getChainId = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getChainId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChainId = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getChainId(client) {
      const chainIdHex = await client.request({
        method: "eth_chainId"
      });
      return (0, fromHex_js_1.hexToNumber)(chainIdHex);
    }
    exports2.getChainId = getChainId;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js
var require_sendRawTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendRawTransaction = void 0;
    async function sendRawTransaction(client, { serializedTransaction }) {
      return client.request({
        method: "eth_sendRawTransaction",
        params: [serializedTransaction]
      });
    }
    exports2.sendRawTransaction = sendRawTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/sendTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    var getTransactionError_js_1 = require_getTransactionError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var getAction_js_1 = require_getAction();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    async function sendTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
          chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
          (0, assertCurrentChain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain
          });
        }
        if (account.type === "local") {
          const request2 = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, "prepareTransactionRequest")({
            account,
            accessList,
            chain,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...rest
          });
          if (!chainId)
            chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
          const serializer = chain?.serializers?.transaction;
          const serializedTransaction = await account.signTransaction({
            ...request2,
            chainId
          }, { serializer });
          return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, "sendRawTransaction")({
            serializedTransaction
          });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          accessList,
          data,
          from: account.address,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        return await client.request({
          method: "eth_sendTransaction",
          params: [request]
        });
      } catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
          ...args,
          account,
          chain: args.chain || void 0
        });
      }
    }
    exports2.sendTransaction = sendTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/writeContract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeContract = void 0;
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getAction_js_1 = require_getAction();
    var sendTransaction_js_1 = require_sendTransaction();
    async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      const hash = await (0, getAction_js_1.getAction)(client, sendTransaction_js_1.sendTransaction, "sendTransaction")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return hash;
    }
    exports2.writeContract = writeContract;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/getContract.js
var require_getContract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/getContract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEventParameters = exports2.getFunctionParameters = exports2.getContract = void 0;
    var getAction_js_1 = require_getAction();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var getContractEvents_js_1 = require_getContractEvents();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var writeContract_js_1 = require_writeContract();
    function getContract({ abi, address, publicClient, walletClient }) {
      const hasPublicClient = publicClient !== void 0 && publicClient !== null;
      const hasWalletClient = walletClient !== void 0 && walletClient !== null;
      const contract = {};
      let hasReadFunction = false;
      let hasWriteFunction = false;
      let hasEvent = false;
      for (const item of abi) {
        if (item.type === "function")
          if (item.stateMutability === "view" || item.stateMutability === "pure")
            hasReadFunction = true;
          else
            hasWriteFunction = true;
        else if (item.type === "event")
          hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
          break;
      }
      if (hasPublicClient) {
        if (hasReadFunction)
          contract.read = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(publicClient, readContract_js_1.readContract, "readContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasWriteFunction)
          contract.simulate = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(publicClient, simulateContract_js_1.simulateContract, "simulateContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasEvent) {
          contract.createEventFilter = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.getEvents = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.watchEvent = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, "watchContractEvent")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
        }
      }
      if (hasWalletClient) {
        if (hasWriteFunction)
          contract.write = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(walletClient, writeContract_js_1.writeContract, "writeContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
      }
      if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction)
          contract.estimateGas = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                const client = publicClient ?? walletClient;
                return (0, getAction_js_1.getAction)(client, estimateContractGas_js_1.estimateContractGas, "estimateContractGas")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options,
                  account: options.account ?? walletClient.account
                });
              };
            }
          });
      }
      contract.address = address;
      contract.abi = abi;
      return contract;
    }
    exports2.getContract = getContract;
    function getFunctionParameters(values) {
      const hasArgs = values.length && Array.isArray(values[0]);
      const args = hasArgs ? values[0] : [];
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports2.getFunctionParameters = getFunctionParameters;
    function getEventParameters(values, abiEvent) {
      let hasArgs = false;
      if (Array.isArray(values[0]))
        hasArgs = true;
      else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
      } else if (values.length === 2) {
        hasArgs = true;
      }
      const args = hasArgs ? values[0] : void 0;
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports2.getEventParameters = getEventParameters;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publicKeyToAddress = void 0;
    var getAddress_js_1 = require_getAddress();
    var keccak256_js_1 = require_keccak256();
    function publicKeyToAddress(publicKey) {
      const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
      return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
    }
    exports2.publicKeyToAddress = publicKeyToAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/accounts.js
var require_accounts = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/accounts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publicKeyToAddress = exports2.parseAccount = void 0;
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports2, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports2, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/uid.js
var require_uid = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/uid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uid = void 0;
    var size = 256;
    var index = size;
    var buffer;
    function uid(length = 11) {
      if (!buffer || index + length > size * 2) {
        buffer = "";
        index = 0;
        for (let i = 0; i < size; i++) {
          buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
        }
      }
      return buffer.substring(index, index++ + length);
    }
    exports2.uid = uid;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createClient.js
var require_createClient = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createClient = void 0;
    var accounts_js_1 = require_accounts();
    var uid_js_1 = require_uid();
    function createClient3(parameters) {
      const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
      const chain = parameters.chain;
      const account = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : void 0;
      const { config: config2, request, value } = parameters.transport({
        chain,
        pollingInterval
      });
      const transport = { ...config2, ...value };
      const client = {
        account,
        batch,
        cacheTime,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)()
      };
      function extend(base) {
        return (extendFn) => {
          const extended = extendFn(base);
          for (const key2 in client)
            delete extended[key2];
          const combined = { ...base, ...extended };
          return Object.assign(combined, { extend: extend(combined) });
        };
      }
      return Object.assign(client, { extend: extend(client) });
    }
    exports2.createClient = createClient3;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withRetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withRetry = void 0;
    var wait_js_1 = require_wait();
    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
      return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
          const retry = async ({ error }) => {
            const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
            if (delay)
              await (0, wait_js_1.wait)(delay);
            attemptRetry({ count: count + 1 });
          };
          try {
            const data = await fn();
            resolve(data);
          } catch (err) {
            if (count < retryCount && await shouldRetry({ count, error: err }))
              return retry({ error: err });
            reject(err);
          }
        };
        attemptRetry();
      });
    }
    exports2.withRetry = withRetry;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/buildRequest.js
var require_buildRequest = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/buildRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildRequest = exports2.isDeterministicError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    var withRetry_js_1 = require_withRetry();
    var isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof request_js_1.HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
    exports2.isDeterministicError = isDeterministicError;
    function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
      return async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            case 5e3:
              throw new rpc_js_1.UserRejectedRequestError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports2.isDeterministicError)(error)
      });
    }
    exports2.buildRequest = buildRequest;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/createTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransport = void 0;
    var buildRequest_js_1 = require_buildRequest();
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
      return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value
      };
    }
    exports2.createTransport = createTransport;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/custom.js
var require_custom = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/custom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.custom = void 0;
    var createTransport_js_1 = require_createTransport();
    function custom(provider, config2 = {}) {
      const { key = "custom", name = "Custom Provider", retryDelay } = config2;
      return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config2.retryCount ?? defaultRetryCount,
        retryDelay,
        type: "custom"
      });
    }
    exports2.custom = custom;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/fallback.js
var require_fallback = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/fallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rankTransports = exports2.fallback = void 0;
    var buildRequest_js_1 = require_buildRequest();
    var wait_js_1 = require_wait();
    var createTransport_js_1 = require_createTransport();
    function fallback(transports_, config2 = {}) {
      const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config2;
      return ({ chain, pollingInterval = 4e3, timeout }) => {
        let transports = transports_;
        let onResponse = () => {
        };
        const transport = (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const fetch2 = async (i = 0) => {
              const transport2 = transports[i]({ chain, retryCount: 0, timeout });
              try {
                const response = await transport2.request({
                  method,
                  params
                });
                onResponse({
                  method,
                  params,
                  response,
                  transport: transport2,
                  status: "success"
                });
                return response;
              } catch (err) {
                onResponse({
                  error: err,
                  method,
                  params,
                  transport: transport2,
                  status: "error"
                });
                if ((0, buildRequest_js_1.isDeterministicError)(err))
                  throw err;
                if (i === transports.length - 1)
                  throw err;
                return fetch2(i + 1);
              }
            };
            return fetch2();
          },
          retryCount,
          retryDelay,
          type: "fallback"
        }, {
          onResponse: (fn) => onResponse = fn,
          transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
        });
        if (rank) {
          const rankOptions = typeof rank === "object" ? rank : {};
          rankTransports({
            chain,
            interval: rankOptions.interval ?? pollingInterval,
            onTransports: (transports_2) => transports = transports_2,
            sampleCount: rankOptions.sampleCount,
            timeout: rankOptions.timeout,
            transports,
            weights: rankOptions.weights
          });
        }
        return transport;
      };
    }
    exports2.fallback = fallback;
    function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
      const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
      const samples = [];
      const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
          const transport_ = transport({ chain, retryCount: 0, timeout });
          const start = Date.now();
          let end;
          let success;
          try {
            await transport_.request({ method: "net_listening" });
            success = 1;
          } catch {
            success = 0;
          } finally {
            end = Date.now();
          }
          const latency = end - start;
          return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
          samples.shift();
        const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
        const scores = transports.map((_, i) => {
          const latencies = samples.map((sample2) => sample2[i].latency);
          const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
          const latencyScore = 1 - meanLatency / maxLatency;
          const successes = samples.map((sample2) => sample2[i].success);
          const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
          if (stabilityScore === 0)
            return [0, i];
          return [
            latencyWeight * latencyScore + stabilityWeight * stabilityScore,
            i
          ];
        }).sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
      };
      rankTransports_();
    }
    exports2.rankTransports = rankTransports;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/transport.js
var require_transport = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UrlRequiredError = void 0;
    var base_js_1 = require_base();
    var UrlRequiredError = class extends base_js_1.BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
    exports2.UrlRequiredError = UrlRequiredError;
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output2, offset, length) {
      for (let i = 0; i < length; i++) {
        output2[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output2, offset, length) {
          if (length < 48) _mask(source, mask, output2, offset, length);
          else bufferUtil.mask(source, mask, output2, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes2, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes2(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/.pnpm/ws@8.13.0/node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/.pnpm/ws@8.13.0/node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/.pnpm/isows@1.0.3_ws@8.13.0/node_modules/isows/_cjs/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/isows@1.0.3_ws@8.13.0/node_modules/isows/_cjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNativeWebSocket = void 0;
    function getNativeWebSocket() {
      if (typeof WebSocket !== "undefined")
        return WebSocket;
      if (typeof global.WebSocket !== "undefined")
        return global.WebSocket;
      if (typeof window.WebSocket !== "undefined")
        return window.WebSocket;
      if (typeof self.WebSocket !== "undefined")
        return self.WebSocket;
      throw new Error("`WebSocket` is not supported in this environment");
    }
    exports2.getNativeWebSocket = getNativeWebSocket;
  }
});

// node_modules/.pnpm/isows@1.0.3_ws@8.13.0/node_modules/isows/_cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/.pnpm/isows@1.0.3_ws@8.13.0/node_modules/isows/_cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebSocket = void 0;
    var WebSocket_ = require_ws();
    var utils_js_1 = require_utils4();
    exports2.WebSocket = (() => {
      try {
        return (0, utils_js_1.getNativeWebSocket)();
      } catch {
        if (WebSocket_.WebSocket)
          return WebSocket_.WebSocket;
        return WebSocket_;
      }
    })();
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/promise/withTimeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withTimeout = void 0;
    function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
      return new Promise((resolve, reject) => {
        ;
        (async () => {
          let timeoutId;
          try {
            const controller = new AbortController();
            if (timeout > 0) {
              timeoutId = setTimeout(() => {
                if (signal) {
                  controller.abort();
                } else {
                  reject(errorInstance);
                }
              }, timeout);
            }
            resolve(await fn({ signal: controller?.signal }));
          } catch (err) {
            if (err.name === "AbortError")
              reject(errorInstance);
            reject(err);
          } finally {
            clearTimeout(timeoutId);
          }
        })();
      });
    }
    exports2.withTimeout = withTimeout;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/rpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rpc = exports2.getSocket = exports2.socketsCache = void 0;
    var isows_1 = require_cjs2();
    var request_js_1 = require_request();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var withTimeout_js_1 = require_withTimeout();
    var stringify_js_1 = require_stringify();
    var id = 0;
    async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
          const response2 = await fetch(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? id++,
              ...body2
            }))) : (0, stringify_js_1.stringify)({ jsonrpc: "2.0", id: body.id ?? id++, ...body }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : void 0)
          });
          return response2;
        }, {
          errorInstance: new request_js_1.TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new request_js_1.HttpRequestError({
            body,
            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
          throw err;
        if (err instanceof request_js_1.TimeoutError)
          throw err;
        throw new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    exports2.socketsCache = /* @__PURE__ */ new Map();
    async function getSocket(url) {
      let socket = exports2.socketsCache.get(url);
      if (socket)
        return socket;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: url,
        fn: async () => {
          const webSocket2 = new isows_1.WebSocket(url);
          const requests = /* @__PURE__ */ new Map();
          const subscriptions = /* @__PURE__ */ new Map();
          const onMessage = ({ data }) => {
            const message = JSON.parse(data);
            const isSubscription = message.method === "eth_subscription";
            const id2 = isSubscription ? message.params.subscription : message.id;
            const cache = isSubscription ? subscriptions : requests;
            const callback = cache.get(id2);
            if (callback)
              callback({ data });
            if (!isSubscription)
              cache.delete(id2);
          };
          const onClose = () => {
            exports2.socketsCache.delete(url);
            webSocket2.removeEventListener("close", onClose);
            webSocket2.removeEventListener("message", onMessage);
          };
          webSocket2.addEventListener("close", onClose);
          webSocket2.addEventListener("message", onMessage);
          if (webSocket2.readyState === isows_1.WebSocket.CONNECTING) {
            await new Promise((resolve, reject) => {
              if (!webSocket2)
                return;
              webSocket2.onopen = resolve;
              webSocket2.onerror = reject;
            });
          }
          socket = Object.assign(webSocket2, {
            requests,
            subscriptions
          });
          exports2.socketsCache.set(url, socket);
          return [socket];
        }
      });
      const [_, [socket_]] = await schedule();
      return socket_;
    }
    exports2.getSocket = getSocket;
    function webSocket(socket, { body, onResponse }) {
      if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
          body,
          url: socket.url,
          details: "Socket is closed."
        });
      const id_ = id++;
      const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id)
          return;
        onResponse?.(message);
        if (body.method === "eth_subscribe" && typeof message.result === "string") {
          socket.subscriptions.set(message.result, callback);
        }
        if (body.method === "eth_unsubscribe") {
          socket.subscriptions.delete(body.params?.[0]);
        }
      };
      socket.requests.set(id_, callback);
      socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
      return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 1e4 }) {
      return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports2.rpc.webSocket(socket, {
        body,
        onResponse
      })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout
      });
    }
    exports2.rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/http.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.http = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function http(url, config2 = {}) {
      const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config2;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1e3, wait = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config2.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config2.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
              id: `${url}`,
              wait,
              shouldSplitBatch(requests) {
                return requests.length > batchSize;
              },
              fn: (body2) => rpc_js_1.rpc.http(url_, {
                body: body2,
                fetchOptions,
                timeout
              }),
              sort: (a, b) => a.id - b.id
            });
            const fn = async (body2) => batch ? schedule(body2) : [await rpc_js_1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
            const [{ error, result }] = await fn(body);
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "http"
        }, {
          fetchOptions,
          url
        });
      };
    }
    exports2.http = http;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/errors.js
var require_errors3 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullUniversalResolverError = void 0;
    var solidity_js_1 = require_solidity();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    function isNullUniversalResolverError(err, callType) {
      if (!(err instanceof base_js_1.BaseError))
        return false;
      const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
      if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
      if (cause.data?.errorName === "ResolverNotFound")
        return true;
      if (cause.data?.errorName === "ResolverWildcardNotSupported")
        return true;
      if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
        return true;
      if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
        return true;
      return false;
    }
    exports2.isNullUniversalResolverError = isNullUniversalResolverError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodedLabelToLabelhash = void 0;
    var isHex_js_1 = require_isHex();
    function encodedLabelToLabelhash(label) {
      if (label.length !== 66)
        return null;
      if (label.indexOf("[") !== 0)
        return null;
      if (label.indexOf("]") !== 65)
        return null;
      const hash = `0x${label.slice(1, 65)}`;
      if (!(0, isHex_js_1.isHex)(hash))
        return null;
      return hash;
    }
    exports2.encodedLabelToLabelhash = encodedLabelToLabelhash;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/namehash.js
var require_namehash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/namehash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.namehash = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function namehash(name) {
      let result = new Uint8Array(32).fill(0);
      if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
      const labels = name.split(".");
      for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), "bytes");
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
      }
      return (0, toHex_js_1.bytesToHex)(result);
    }
    exports2.namehash = namehash;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/encodeLabelhash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeLabelhash = void 0;
    function encodeLabelhash(hash) {
      return `[${hash.slice(2)}]`;
    }
    exports2.encodeLabelhash = encodeLabelhash;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/labelhash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.labelhash = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function labelhash(label) {
      const result = new Uint8Array(32).fill(0);
      if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
      return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
    }
    exports2.labelhash = labelhash;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/packetToBytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.packetToBytes = void 0;
    var toBytes_js_1 = require_toBytes();
    var encodeLabelhash_js_1 = require_encodeLabelhash();
    var labelhash_js_1 = require_labelhash();
    function packetToBytes(packet) {
      const value = packet.replace(/^\.|\.$/gm, "");
      if (value.length === 0)
        return new Uint8Array(1);
      const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
      let offset = 0;
      const list = value.split(".");
      for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
          encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
      }
      if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
      return bytes;
    }
    exports2.packetToBytes = packetToBytes;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnsAddress = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors3();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
          abi: abis_js_1.addressResolverAbi,
          functionName: "addr",
          ...coinType != null ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] } : { args: [(0, namehash_js_1.namehash)(name)] }
        });
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.addressResolverAbi,
          args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : void 0,
          functionName: "addr",
          data: res[0]
        });
        if (address === "0x")
          return null;
        if ((0, trim_js_1.trim)(address) === "0x00")
          return null;
        return address;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports2.getEnsAddress = getEnsAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/ens.js
var require_ens = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/ens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsAvatarUnsupportedNamespaceError = exports2.EnsAvatarUriResolutionError = exports2.EnsAvatarInvalidNftUriError = exports2.EnsAvatarInvalidMetadataError = void 0;
    var base_js_1 = require_base();
    var EnsAvatarInvalidMetadataError = class extends base_js_1.BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    exports2.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
    var EnsAvatarInvalidNftUriError = class extends base_js_1.BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    exports2.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
    var EnsAvatarUriResolutionError = class extends base_js_1.BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    exports2.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
    var EnsAvatarUnsupportedNamespaceError = class extends base_js_1.BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
    exports2.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/avatar/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/avatar/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNftTokenUri = exports2.parseNftUri = exports2.parseAvatarUri = exports2.getMetadataAvatarUri = exports2.getJsonImage = exports2.resolveAvatarUri = exports2.getGateway = exports2.isImageUri = void 0;
    var readContract_js_1 = require_readContract();
    var ens_js_1 = require_ens();
    var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
      try {
        const res = await fetch(uri, { method: "HEAD" });
        if (res.status === 200) {
          const contentType = res.headers.get("content-type");
          return contentType?.startsWith("image/");
        }
        return false;
      } catch (error) {
        if (typeof error === "object" && typeof error.response !== "undefined") {
          return false;
        }
        if (!globalThis.hasOwnProperty("Image"))
          return false;
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(true);
          };
          img.onerror = () => {
            resolve(false);
          };
          img.src = uri;
        });
      }
    }
    exports2.isImageUri = isImageUri;
    function getGateway(custom, defaultGateway) {
      if (!custom)
        return defaultGateway;
      if (custom.endsWith("/"))
        return custom.slice(0, -1);
      return custom;
    }
    exports2.getGateway = getGateway;
    function resolveAvatarUri({ uri, gatewayUrls }) {
      const isEncoded = base64Regex.test(uri);
      if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
      const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
      const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
      const networkRegexMatch = uri.match(networkRegex);
      const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
      const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
      const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
      if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
          replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
      }
      if ((isIPNS || isIPFS) && target) {
        return {
          uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      if (protocol === "ar:/" && target) {
        return {
          uri: `${arweaveGateway}/${target}${subtarget || ""}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      let parsedUri = uri.replace(dataURIRegex, "");
      if (parsedUri.startsWith("<svg")) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
      }
      if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
        return {
          uri: parsedUri,
          isOnChain: true,
          isEncoded: false
        };
      }
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports2.resolveAvatarUri = resolveAvatarUri;
    function getJsonImage(data) {
      if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
      }
      return data.image || data.image_url || data.image_data;
    }
    exports2.getJsonImage = getJsonImage;
    async function getMetadataAvatarUri({ gatewayUrls, uri }) {
      try {
        const res = await fetch(uri).then((res2) => res2.json());
        const image = await parseAvatarUri({
          gatewayUrls,
          uri: getJsonImage(res)
        });
        return image;
      } catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
      }
    }
    exports2.getMetadataAvatarUri = getMetadataAvatarUri;
    async function parseAvatarUri({ gatewayUrls, uri }) {
      const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
      if (isOnChain)
        return resolvedURI;
      const isImage = await isImageUri(resolvedURI);
      if (isImage)
        return resolvedURI;
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports2.parseAvatarUri = parseAvatarUri;
    function parseNftUri(uri_) {
      let uri = uri_;
      if (uri.startsWith("did:nft:")) {
        uri = uri.replace("did:nft:", "").replace(/_/g, "/");
      }
      const [reference, asset_namespace, tokenID] = uri.split("/");
      const [eip_namespace, chainID] = reference.split(":");
      const [erc_namespace, contractAddress] = asset_namespace.split(":");
      if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
      if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
      if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
          reason: "Contract address not found"
        });
      if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
      if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
      return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress,
        tokenID
      };
    }
    exports2.parseNftUri = parseNftUri;
    async function getNftTokenUri(client, { nft }) {
      if (nft.namespace === "erc721") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "tokenId", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "tokenURI",
          args: [BigInt(nft.tokenID)]
        });
      }
      if (nft.namespace === "erc1155") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "_id", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "uri",
          args: [BigInt(nft.tokenID)]
        });
      }
      throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }
    exports2.getNftTokenUri = getNftTokenUri;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAvatarRecord = void 0;
    var utils_js_1 = require_utils5();
    async function parseAvatarRecord(client, { gatewayUrls, record }) {
      if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
      return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
    }
    exports2.parseAvatarRecord = parseAvatarRecord;
    async function parseNftAvatarUri(client, { gatewayUrls, record }) {
      const nft = (0, utils_js_1.parseNftUri)(record);
      const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
      const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
      if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
      }
      let uriTokenId = nft.tokenID;
      if (nft.namespace === "erc1155")
        uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
      return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
      });
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsText.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnsText = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors3();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [
            (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
            (0, encodeFunctionData_js_1.encodeFunctionData)({
              abi: abis_js_1.textResolverAbi,
              functionName: "text",
              args: [(0, namehash_js_1.namehash)(name), key]
            })
          ],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.textResolverAbi,
          functionName: "text",
          data: res[0]
        });
        return record === "" ? null : record;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports2.getEnsText = getEnsText;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsAvatar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnsAvatar = void 0;
    var parseAvatarRecord_js_1 = require_parseAvatarRecord();
    var getAction_js_1 = require_getAction();
    var getEnsText_js_1 = require_getEnsText();
    async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
      const record = await (0, getAction_js_1.getAction)(client, getEnsText_js_1.getEnsText, "getEnsText")({
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
      });
      if (!record)
        return null;
      try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
      } catch {
        return null;
      }
    }
    exports2.getEnsAvatar = getEnsAvatar;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnsName = void 0;
    var abis_js_1 = require_abis();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors3();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
      try {
        const [name, resolvedAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverReverseAbi,
          functionName: "reverse",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
          blockNumber,
          blockTag
        });
        if (address.toLowerCase() !== resolvedAddress.toLowerCase())
          return null;
        return name;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
          return null;
        throw err;
      }
    }
    exports2.getEnsName = getEnsName;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/ens/getEnsResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnsResolver = void 0;
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
        address: universalResolverAddress,
        abi: [
          {
            inputs: [{ type: "bytes" }],
            name: "findResolver",
            outputs: [{ type: "address" }, { type: "bytes32" }],
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "findResolver",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag
      });
      return resolverAddress;
    }
    exports2.getEnsResolver = getEnsResolver;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createBlockFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBlockFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createBlockFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
      });
      const id = await client.request({
        method: "eth_newBlockFilter"
      });
      return { id, request: getRequest(id), type: "block" };
    }
    exports2.createBlockFilter = createBlockFilter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createEventFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
      const events = events_ ?? (event ? [event] : void 0);
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            ...topics.length ? { topics } : {}
          }
        ]
      });
      return {
        abi: events,
        args,
        eventName: event ? event.name : void 0,
        fromBlock,
        id,
        request: getRequest(id),
        strict,
        toBlock,
        type: "event"
      };
    }
    exports2.createEventFilter = createEventFilter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPendingTransactionFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createPendingTransactionFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
      });
      const id = await client.request({
        method: "eth_newPendingTransactionFilter"
      });
      return { id, request: getRequest(id), type: "transaction" };
    }
    exports2.createPendingTransactionFilter = createPendingTransactionFilter;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBalance.js
var require_getBalance = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBalance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const balance = await client.request({
        method: "eth_getBalance",
        params: [address, blockNumberHex || blockTag]
      });
      return BigInt(balance);
    }
    exports2.getBalance = getBalance;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let count;
      if (blockHash) {
        count = await client.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [blockHash]
        });
      } else {
        count = await client.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [blockNumberHex || blockTag]
        });
      }
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports2.getBlockTransactionCount = getBlockTransactionCount;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getBytecode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBytecode = void 0;
    var toHex_js_1 = require_toHex();
    async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const hex = await client.request({
        method: "eth_getCode",
        params: [address, blockNumberHex || blockTag]
      });
      if (hex === "0x")
        return void 0;
      return hex;
    }
    exports2.getBytecode = getBytecode;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/feeHistory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatFeeHistory = void 0;
    function formatFeeHistory(feeHistory) {
      return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
      };
    }
    exports2.formatFeeHistory = formatFeeHistory;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFeeHistory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeeHistory = void 0;
    var toHex_js_1 = require_toHex();
    var feeHistory_js_1 = require_feeHistory();
    async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
          (0, toHex_js_1.numberToHex)(blockCount),
          blockNumberHex || blockTag,
          rewardPercentiles
        ]
      });
      return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
    }
    exports2.getFeeHistory = getFeeHistory;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getFilterLogs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilterLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterLogs(_client, { filter }) {
      const strict = filter.strict ?? false;
      const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [filter.id]
      });
      return logs.map((log) => {
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports2.getFilterLogs = getFilterLogs;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/defineChain.js
var require_defineChain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/defineChain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineChain = void 0;
    function defineChain(chain, config2 = {}) {
      const { fees = chain.fees, formatters = chain.formatters, serializers = chain.serializers } = config2;
      return {
        ...chain,
        fees,
        formatters,
        serializers
      };
    }
    exports2.defineChain = defineChain;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/extractChain.js
var require_extractChain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/chain/extractChain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractChain = void 0;
    function extractChain({ chains, id }) {
      return chains.find((chain) => chain.id === id);
    }
    exports2.extractChain = extractChain;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/regex.js
var require_regex2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.integerRegex = exports2.bytesRegex = exports2.arrayRegex = void 0;
    exports2.arrayRegex = /^(.*)\[([0-9]*)\]$/;
    exports2.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports2.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hashTypedData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashDomain = exports2.hashTypedData = void 0;
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var typedData_js_1 = require_typedData();
    function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
      const domain = typeof domain_ === "undefined" ? {} : domain_;
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      const parts = ["0x1901"];
      if (domain)
        parts.push(hashDomain({
          domain,
          types
        }));
      if (primaryType !== "EIP712Domain") {
        parts.push(hashStruct({
          data: message,
          primaryType,
          types
        }));
      }
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
    }
    exports2.hashTypedData = hashTypedData;
    function hashDomain({ domain, types }) {
      return hashStruct({
        data: domain,
        primaryType: "EIP712Domain",
        types
      });
    }
    exports2.hashDomain = hashDomain;
    function hashStruct({ data, primaryType, types }) {
      const encoded = encodeData({
        data,
        primaryType,
        types
      });
      return (0, keccak256_js_1.keccak256)(encoded);
    }
    function encodeData({ data, primaryType, types }) {
      const encodedTypes = [{ type: "bytes32" }];
      const encodedValues = [hashType({ primaryType, types })];
      for (const field of types[primaryType]) {
        const [type, value] = encodeField({
          types,
          name: field.name,
          type: field.type,
          value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
    }
    function hashType({ primaryType, types }) {
      const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
      return (0, keccak256_js_1.keccak256)(encodedHashType);
    }
    function encodeType({ primaryType, types }) {
      let result = "";
      const unsortedDeps = findTypeDependencies({ primaryType, types });
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        result += `${type}(${types[type].map(({ name, type: t2 }) => `${t2} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
      const match = primaryType_.match(/^\w*/u);
      const primaryType = match?.[0];
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
      }
      return results;
    }
    function encodeField({ types, name, type, value }) {
      if (types[type] !== void 0) {
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types }))
        ];
      }
      if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
      }
      if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
      if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField({
          name,
          type: parsedType,
          types,
          value: item
        }));
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [{ type }, value];
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/typedData.js
var require_typedData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/typedData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.domainSeparator = exports2.getTypesForEIP712Domain = exports2.validateTypedData = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var size_js_1 = require_size();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    var hashTypedData_js_1 = require_hashTypedData();
    function validateTypedData({ domain, message, primaryType, types: types_ }) {
      const types = types_;
      const validateData = (struct, value_) => {
        for (const param of struct) {
          const { name, type: type_ } = param;
          const type = type_;
          const value = value_[name];
          const integerMatch = type.match(regex_js_1.integerRegex);
          if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
            const [_type, base, size_] = integerMatch;
            (0, toHex_js_1.numberToHex)(value, {
              signed: base === "int",
              size: parseInt(size_) / 8
            });
          }
          if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
            throw new address_js_1.InvalidAddressError({ address: value });
          const bytesMatch = type.match(regex_js_1.bytesRegex);
          if (bytesMatch) {
            const [_type, size_] = bytesMatch;
            if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
              throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size_),
                givenSize: (0, size_js_1.size)(value)
              });
          }
          const struct2 = types[type];
          if (struct2)
            validateData(struct2, value);
        }
      };
      if (types.EIP712Domain && domain)
        validateData(types.EIP712Domain, domain);
      if (primaryType !== "EIP712Domain") {
        const type = types[primaryType];
        validateData(type, message);
      }
    }
    exports2.validateTypedData = validateTypedData;
    function getTypesForEIP712Domain({ domain }) {
      return [
        typeof domain?.name === "string" && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        typeof domain?.chainId === "number" && {
          name: "chainId",
          type: "uint256"
        },
        domain?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean);
    }
    exports2.getTypesForEIP712Domain = getTypesForEIP712Domain;
    function domainSeparator({ domain }) {
      return (0, hashTypedData_js_1.hashDomain)({
        domain,
        types: {
          EIP712Domain: getTypesForEIP712Domain({ domain })
        }
      });
    }
    exports2.domainSeparator = domainSeparator;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeFunctionData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeFunctionData({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      const description = abi.find((x) => x.type === "function" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeFunctionData"
        });
      return {
        functionName: description.name,
        args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : void 0
      };
    }
    exports2.decodeFunctionData = decodeFunctionData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeDeployData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var docsPath = "/docs/contract/encodeDeployData";
    function encodeDeployData({ abi, args, bytecode }) {
      if (!args || args.length === 0)
        return bytecode;
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
      return (0, concat_js_1.concatHex)([bytecode, data]);
    }
    exports2.encodeDeployData = encodeDeployData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeErrorResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeErrorResult = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeErrorResult";
    function encodeErrorResult({ abi, errorName, args }) {
      let abiItem = abi[0];
      if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: errorName
        });
        if (!abiItem)
          throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
      }
      if (abiItem.type !== "error")
        throw new abi_js_1.AbiErrorNotFoundError(void 0, { docsPath });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      let data = "0x";
      if (args && args.length > 0) {
        if (!abiItem.inputs)
          throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
      }
      return (0, concat_js_1.concatHex)([signature, data]);
    }
    exports2.encodeErrorResult = encodeErrorResult;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeFunctionResult";
    function encodeFunctionResult({ abi, functionName, result }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionResult"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionResult"
        });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      let values = Array.isArray(result) ? result : [result];
      if (abiItem.outputs.length === 0 && !values[0])
        values = [];
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
    }
    exports2.encodeFunctionResult = encodeFunctionResult;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/encodePacked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodePacked = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function encodePacked(types, values) {
      if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: types.length,
          givenLength: values.length
        });
      const data = [];
      for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
      }
      return (0, concat_js_1.concatHex)(data);
    }
    exports2.encodePacked = encodePacked;
    function encode(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
          size: isArray ? 32 : null
        });
      }
      if (type === "string")
        return (0, toHex_js_1.stringToHex)(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
      const intMatch = type.match(regex_js_1.integerRegex);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
          size: isArray ? 32 : size,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(regex_js_1.bytesRegex);
      if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (parseInt(size) !== (value.length - 2) / 2)
          throw new abi_js_1.BytesSizeMismatchError({
            expectedSize: parseInt(size),
            givenSize: (value.length - 2) / 2
          });
        return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
      }
      const arrayMatch = type.match(regex_js_1.arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
          data.push(encode(childType, value[i], true));
        }
        if (data.length === 0)
          return "0x";
        return (0, concat_js_1.concatHex)(data);
      }
      throw new abi_js_1.UnsupportedPackedAbiType(type);
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isBytes.js
var require_isBytes = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isBytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBytes = void 0;
    function isBytes(value) {
      if (!value)
        return false;
      if (typeof value !== "object")
        return false;
      if (!("BYTES_PER_ELEMENT" in value))
        return false;
      return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
    }
    exports2.isBytes = isBytes;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/cursor.js
var require_cursor = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/errors/cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PositionOutOfBoundsError = exports2.NegativeOffsetError = void 0;
    var base_js_1 = require_base();
    var NegativeOffsetError = class extends base_js_1.BaseError {
      constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NegativeOffsetError"
        });
      }
    };
    exports2.NegativeOffsetError = NegativeOffsetError;
    var PositionOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PositionOutOfBoundsError"
        });
      }
    };
    exports2.PositionOutOfBoundsError = PositionOutOfBoundsError;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCursor = void 0;
    var cursor_js_1 = require_cursor();
    var staticCursor = {
      bytes: new Uint8Array(),
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
          throw new cursor_js_1.PositionOutOfBoundsError({
            length: this.bytes.length,
            position
          });
      },
      decrementPosition(offset) {
        if (offset < 0)
          throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
      },
      incrementPosition(offset) {
        if (offset < 0)
          throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
      },
      inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
      },
      inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
      },
      inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
      },
      inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
      },
      pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
      },
      pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
      },
      pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
      },
      pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
      },
      pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
      },
      pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
      },
      readByte() {
        const value = this.inspectByte();
        this.position++;
        return value;
      },
      readBytes(length) {
        const value = this.inspectBytes(length);
        this.position += length;
        return value;
      },
      readUint8() {
        const value = this.inspectUint8();
        this.position += 1;
        return value;
      },
      readUint16() {
        const value = this.inspectUint16();
        this.position += 2;
        return value;
      },
      readUint24() {
        const value = this.inspectUint24();
        this.position += 3;
        return value;
      },
      readUint32() {
        const value = this.inspectUint32();
        this.position += 4;
        return value;
      },
      setPosition(position) {
        this.assertPosition(position);
        this.position = position;
      }
    };
    function createCursor(bytes) {
      const cursor = Object.create(staticCursor);
      cursor.bytes = bytes;
      cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      return cursor;
    }
    exports2.createCursor = createCursor;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/toRlp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToRlp = exports2.bytesToRlp = exports2.toRlp = void 0;
    var index_js_1 = require_cjs3();
    var cursor_js_1 = require_cursor2();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function toRlp(bytes, to = "hex") {
      const encodable = getEncodable(bytes);
      const cursor = (0, cursor_js_1.createCursor)(new Uint8Array(encodable.length));
      encodable.encode(cursor);
      if (to === "hex")
        return (0, toHex_js_1.bytesToHex)(cursor.bytes);
      return cursor.bytes;
    }
    exports2.toRlp = toRlp;
    function bytesToRlp(bytes, to = "bytes") {
      return toRlp(bytes, to);
    }
    exports2.bytesToRlp = bytesToRlp;
    function hexToRlp(hex, to = "hex") {
      return toRlp(hex, to);
    }
    exports2.hexToRlp = hexToRlp;
    function getEncodable(bytes) {
      if (Array.isArray(bytes))
        return getEncodableList(bytes.map((x) => getEncodable(x)));
      return getEncodableBytes(bytes);
    }
    function getEncodableList(list) {
      const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
      const sizeOfBodyLength = getSizeOfLength(bodyLength);
      const length = (() => {
        if (bodyLength <= 55)
          return 1 + bodyLength;
        return 1 + sizeOfBodyLength + bodyLength;
      })();
      return {
        length,
        encode(cursor) {
          if (bodyLength <= 55) {
            cursor.pushByte(192 + bodyLength);
          } else {
            cursor.pushByte(192 + 55 + sizeOfBodyLength);
            if (sizeOfBodyLength === 1)
              cursor.pushUint8(bodyLength);
            else if (sizeOfBodyLength === 2)
              cursor.pushUint16(bodyLength);
            else if (sizeOfBodyLength === 3)
              cursor.pushUint24(bodyLength);
            else
              cursor.pushUint32(bodyLength);
          }
          for (const { encode } of list) {
            encode(cursor);
          }
        }
      };
    }
    function getEncodableBytes(bytesOrHex) {
      const bytes = typeof bytesOrHex === "string" ? (0, toBytes_js_1.hexToBytes)(bytesOrHex) : bytesOrHex;
      const sizeOfBytesLength = getSizeOfLength(bytes.length);
      const length = (() => {
        if (bytes.length === 1 && bytes[0] < 128)
          return 1;
        if (bytes.length <= 55)
          return 1 + bytes.length;
        return 1 + sizeOfBytesLength + bytes.length;
      })();
      return {
        length,
        encode(cursor) {
          if (bytes.length === 1 && bytes[0] < 128) {
            cursor.pushBytes(bytes);
          } else if (bytes.length <= 55) {
            cursor.pushByte(128 + bytes.length);
            cursor.pushBytes(bytes);
          } else {
            cursor.pushByte(128 + 55 + sizeOfBytesLength);
            if (sizeOfBytesLength === 1)
              cursor.pushUint8(bytes.length);
            else if (sizeOfBytesLength === 2)
              cursor.pushUint16(bytes.length);
            else if (sizeOfBytesLength === 3)
              cursor.pushUint24(bytes.length);
            else
              cursor.pushUint32(bytes.length);
            cursor.pushBytes(bytes);
          }
        }
      };
    }
    function getSizeOfLength(length) {
      if (length < 2 ** 8)
        return 1;
      if (length < 2 ** 16)
        return 2;
      if (length < 2 ** 24)
        return 3;
      if (length < 2 ** 32)
        return 4;
      throw new index_js_1.BaseError("Length is too large.");
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/address/getContractAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCreate2Address = exports2.getCreateAddress = exports2.getContractAddress = void 0;
    var concat_js_1 = require_concat();
    var isBytes_js_1 = require_isBytes();
    var pad_js_1 = require_pad();
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var toRlp_js_1 = require_toRlp();
    var keccak256_js_1 = require_keccak256();
    var getAddress_js_1 = require_getAddress();
    function getContractAddress(opts) {
      if (opts.opcode === "CREATE2")
        return getCreate2Address(opts);
      return getCreateAddress(opts);
    }
    exports2.getContractAddress = getContractAddress;
    function getCreateAddress(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
      if (nonce[0] === 0)
        nonce = new Uint8Array([]);
      return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
    }
    exports2.getCreateAddress = getCreateAddress;
    function getCreate2Address(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32
      });
      const bytecodeHash = (() => {
        if ("bytecodeHash" in opts) {
          if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
            return opts.bytecodeHash;
          return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);
        }
        return (0, keccak256_js_1.keccak256)(opts.bytecode, "bytes");
      })();
      return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
    }
    exports2.getCreate2Address = getCreate2Address;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/contract/extractFunctionParts.js
var require_extractFunctionParts = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/contract/extractFunctionParts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractFunctionType = exports2.extractFunctionParams = exports2.extractFunctionName = exports2.extractFunctionParts = void 0;
    var paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    function extractFunctionParts(def) {
      const parts = def.match(paramsRegex);
      const type = parts?.[2] || void 0;
      const name = parts?.[3];
      const params = parts?.[5] || void 0;
      return { type, name, params };
    }
    exports2.extractFunctionParts = extractFunctionParts;
    function extractFunctionName(def) {
      return extractFunctionParts(def).name;
    }
    exports2.extractFunctionName = extractFunctionName;
    function extractFunctionParams(def) {
      const params = extractFunctionParts(def).params;
      const splitParams = params?.split(",").map((x) => x.trim().split(" "));
      return splitParams?.map((param) => ({
        type: param[0],
        name: param[1] === "indexed" ? param[2] : param[1],
        ...param[1] === "indexed" ? { indexed: true } : {}
      }));
    }
    exports2.extractFunctionParams = extractFunctionParams;
    function extractFunctionType(def) {
      return extractFunctionParts(def).type;
    }
    exports2.extractFunctionType = extractFunctionType;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/transactionReceipt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineTransactionReceipt = exports2.formatTransactionReceipt = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    var log_js_1 = require_log2();
    var transaction_js_1 = require_transaction2();
    var statuses = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt(transactionReceipt) {
      return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
      };
    }
    exports2.formatTransactionReceipt = formatTransactionReceipt;
    exports2.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromBytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesToString = exports2.bytesToNumber = exports2.bytesToBool = exports2.bytesToBigInt = exports2.fromBytes = void 0;
    var encoding_js_1 = require_encoding();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function fromBytes(bytes, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return bytesToNumber(bytes, opts);
      if (to === "bigint")
        return bytesToBigInt(bytes, opts);
      if (to === "boolean")
        return bytesToBool(bytes, opts);
      if (to === "string")
        return bytesToString(bytes, opts);
      return (0, toHex_js_1.bytesToHex)(bytes, opts);
    }
    exports2.fromBytes = fromBytes;
    function bytesToBigInt(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToBigInt)(hex);
    }
    exports2.bytesToBigInt = bytesToBigInt;
    function bytesToBool(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
      }
      if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
      return Boolean(bytes[0]);
    }
    exports2.bytesToBool = bytesToBool;
    function bytesToNumber(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToNumber)(hex);
    }
    exports2.bytesToNumber = bytesToNumber;
    function bytesToString(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports2.bytesToString = bytesToString;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/encoding/fromRlp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rlpToHex = exports2.rlpToBytes = exports2.fromRlp = void 0;
    var base_js_1 = require_base();
    var encoding_js_1 = require_encoding();
    var cursor_js_1 = require_cursor2();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function fromRlp(value, to = "hex") {
      const bytes = (() => {
        if (typeof value === "string") {
          if (value.length > 3 && value.length % 2 !== 0)
            throw new encoding_js_1.InvalidHexValueError(value);
          return (0, toBytes_js_1.hexToBytes)(value);
        }
        return value;
      })();
      const cursor = (0, cursor_js_1.createCursor)(bytes);
      const result = fromRlpCursor(cursor, to);
      return result;
    }
    exports2.fromRlp = fromRlp;
    function rlpToBytes(bytes, to = "bytes") {
      return fromRlp(bytes, to);
    }
    exports2.rlpToBytes = rlpToBytes;
    function rlpToHex(hex, to = "hex") {
      return fromRlp(hex, to);
    }
    exports2.rlpToHex = rlpToHex;
    function fromRlpCursor(cursor, to = "hex") {
      if (cursor.bytes.length === 0)
        return to === "hex" ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes;
      const prefix = cursor.readByte();
      if (prefix < 128)
        cursor.decrementPosition(1);
      if (prefix < 192) {
        const length2 = readLength(cursor, prefix, 128);
        const bytes = cursor.readBytes(length2);
        return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
      }
      const length = readLength(cursor, prefix, 192);
      return readList(cursor, length, to);
    }
    function readLength(cursor, prefix, offset) {
      if (offset === 128 && prefix < 128)
        return 1;
      if (prefix <= offset + 55)
        return prefix - offset;
      if (prefix === offset + 55 + 1)
        return cursor.readUint8();
      if (prefix === offset + 55 + 2)
        return cursor.readUint16();
      if (prefix === offset + 55 + 3)
        return cursor.readUint24();
      if (prefix === offset + 55 + 4)
        return cursor.readUint32();
      throw new base_js_1.BaseError("Invalid RLP prefix");
    }
    function readList(cursor, length, to) {
      const position = cursor.position;
      const value = [];
      while (cursor.position - position < length)
        value.push(fromRlpCursor(cursor, to));
      return value;
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/isHash.js
var require_isHash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/isHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHash = void 0;
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function isHash(hash) {
      return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
    }
    exports2.isHash = isHash;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/_sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils3();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.SHA2 = SHA2;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils3();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha256 = void 0;
    var sha256_1 = require_sha256();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function sha256(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, sha256_1.sha256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports2.sha256 = sha256;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/ripemd160.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.RIPEMD160 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils3();
    var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
    var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = /* @__PURE__ */ new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = /* @__PURE__ */ new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    var rotl = (word, shift) => word << shift | word >>> 32 - shift;
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var BUF = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD160 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports2.RIPEMD160 = RIPEMD160;
    exports2.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/ripemd160.js
var require_ripemd1602 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/hash/ripemd160.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function ripemd160(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, ripemd160_1.ripemd160)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports2.ripemd160 = ripemd160;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports2.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports2.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports2.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports2.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports2.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports2.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports2.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports2.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports2.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports2.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports2.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports2.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports2.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports2.validateObject = validateObject;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
    var utils_js_1 = require_utils6();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports2.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports2.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports2.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports2.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    exports2.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports2.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports2.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports2.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports2.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports2.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports2.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports2.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports2.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports2.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports2.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports2.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports2.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports2.mapHashToField = mapHashToField;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateBasic = exports2.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils6();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports2.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports2.validateBasic = validateBasic;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapToCurveSimpleSWU = exports2.SWUFpSqrtRatio = exports2.weierstrass = exports2.weierstrassPoints = exports2.DER = void 0;
    var mod = require_modular();
    var ut = require_utils6();
    var utils_js_1 = require_utils6();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports2.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports2.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports2.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports2.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports2.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports2.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports2.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes: randomBytes2 } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports2.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports2.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createHasher = exports2.isogenyMap = exports2.hash_to_field = exports2.expand_message_xof = exports2.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils6();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports2.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports2.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    exports2.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports2.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports2.createHasher = createHasher;
  }
});

// node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils3();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCurve = exports2.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils3();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports2.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports2.createCurve = createCurve;
  }
});

// node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/secp256k1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeToCurve = exports2.hashToCurve = exports2.schnorr = exports2.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils3();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils6();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports2.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports2.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports2.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t2 = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t2, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports2.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports2.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports2.hashToCurve = (() => htf.hashToCurve)();
    exports2.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverPublicKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverPublicKey = void 0;
    var isHex_js_1 = require_isHex();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function recoverPublicKey({ hash, signature }) {
      const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
      const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
      let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
      if (v === 0 || v === 1)
        v += 27;
      const { secp256k1 } = await Promise.resolve().then(() => require_secp256k1());
      const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
      return `0x${publicKey}`;
    }
    exports2.recoverPublicKey = recoverPublicKey;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverAddress = void 0;
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    async function recoverAddress({ hash, signature }) {
      return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash, signature }));
    }
    exports2.recoverAddress = recoverAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/strings.js
var require_strings = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/strings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.presignMessagePrefix = void 0;
    exports2.presignMessagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hashMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashMessage = void 0;
    var strings_js_1 = require_strings();
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    function hashMessage(message, to_) {
      const messageBytes = (() => {
        if (typeof message === "string")
          return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
          return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
      })();
      const prefixBytes = (0, toBytes_js_1.stringToBytes)(`${strings_js_1.presignMessagePrefix}${messageBytes.length}`);
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
    }
    exports2.hashMessage = hashMessage;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverMessageAddress = void 0;
    var hashMessage_js_1 = require_hashMessage();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverMessageAddress({ message, signature }) {
      return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
    }
    exports2.recoverMessageAddress = recoverMessageAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverTypedDataAddress = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverTypedDataAddress({ domain, message, primaryType, signature, types }) {
      return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        }),
        signature
      });
    }
    exports2.recoverTypedDataAddress = recoverTypedDataAddress;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/verifyMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyMessage = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    async function verifyMessage({ address, message, signature }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
    }
    exports2.verifyMessage = verifyMessage;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/verifyTypedData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyTypedData = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    async function verifyTypedData({ address, domain, message, primaryType, signature, types }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
      }));
    }
    exports2.verifyTypedData = verifyTypedData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSerializedTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    var slice_js_1 = require_slice();
    var fromHex_js_1 = require_fromHex();
    function getSerializedTransactionType(serializedTransaction) {
      const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
      if (serializedType === "0x02")
        return "eip1559";
      if (serializedType === "0x01")
        return "eip2930";
      if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
        return "legacy";
      throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
    }
    exports2.getSerializedTransactionType = getSerializedTransactionType;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/assertTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertTransactionLegacy = exports2.assertTransactionEIP2930 = exports2.assertTransactionEIP1559 = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    function assertTransactionEIP1559(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports2.assertTransactionEIP1559 = assertTransactionEIP1559;
    function assertTransactionEIP2930(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    }
    exports2.assertTransactionEIP2930 = assertTransactionEIP2930;
    function assertTransactionLegacy(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof chainId !== "undefined" && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
      if (accessList)
        throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
    }
    exports2.assertTransactionLegacy = assertTransactionLegacy;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/parseTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAccessList = exports2.toTransactionArray = exports2.parseTransaction = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var fromRlp_js_1 = require_fromRlp();
    var isHash_js_1 = require_isHash();
    var assertTransaction_js_1 = require_assertTransaction();
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    function parseTransaction(serializedTransaction) {
      const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
      if (type === "eip1559")
        return parseTransactionEIP1559(serializedTransaction);
      if (type === "eip2930")
        return parseTransactionEIP2930(serializedTransaction);
      return parseTransactionLegacy(serializedTransaction);
    }
    exports2.parseTransaction = parseTransaction;
    function parseTransactionEIP1559(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip1559"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip1559"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
      if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionEIP2930(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip2930"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip2930"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionLegacy(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
      const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
      if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
              v: chainIdOrV_,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "legacy"
        });
      const transaction = {
        type: "legacy"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      if (transactionArray.length === 6)
        return transaction;
      const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
      if (s === "0x" && r === "0x") {
        if (chainIdOrV > 0)
          transaction.chainId = Number(chainIdOrV);
        return transaction;
      }
      const v = chainIdOrV;
      const chainId = Number((v - 35n) / 2n);
      if (chainId > 0)
        transaction.chainId = chainId;
      else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
      transaction.v = v;
      transaction.s = s;
      transaction.r = r;
      return transaction;
    }
    function toTransactionArray(serializedTransaction) {
      return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
    }
    exports2.toTransactionArray = toTransactionArray;
    function parseAccessList(accessList_) {
      const accessList = [];
      for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
          address,
          storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
        });
      }
      return accessList;
    }
    exports2.parseAccessList = parseAccessList;
    function parseEIP155Signature(transactionArray) {
      const signature = transactionArray.slice(-3);
      const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
      return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1
      };
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/serializeAccessList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeAccessList = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    function serializeAccessList(accessList) {
      if (!accessList || accessList.length === 0)
        return [];
      const serializedAccessList = [];
      for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
          if (storageKeys[j].length - 2 !== 64) {
            throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
          }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
          throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
      }
      return serializedAccessList;
    }
    exports2.serializeAccessList = serializeAccessList;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/transaction/serializeTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var assertTransaction_js_1 = require_assertTransaction();
    var getTransactionType_js_1 = require_getTransactionType();
    var serializeAccessList_js_1 = require_serializeAccessList();
    function serializeTransaction(transaction, signature) {
      const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
      if (type === "eip1559")
        return serializeTransactionEIP1559(transaction, signature);
      if (type === "eip2930")
        return serializeTransactionEIP2930(transaction, signature);
      return serializeTransactionLegacy(transaction, signature);
    }
    exports2.serializeTransaction = serializeTransaction;
    function serializeTransactionEIP1559(transaction, signature) {
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature) {
        const yParity = (() => {
          if (signature.v === 0n)
            return "0x";
          if (signature.v === 1n)
            return (0, toHex_js_1.toHex)(1);
          return signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x02",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionEIP2930(transaction, signature) {
      const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature) {
        const yParity = (() => {
          if (signature.v === 0n)
            return "0x";
          if (signature.v === 1n)
            return (0, toHex_js_1.toHex)(1);
          return signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x01",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionLegacy(transaction, signature) {
      const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x"
      ];
      if (signature) {
        const v = (() => {
          if (chainId > 0)
            return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
          if (signature.v >= 35n) {
            const inferredChainId = (signature.v - 35n) / 2n;
            if (inferredChainId > 0)
              return signature.v;
            return 27n + (signature.v === 35n ? 0n : 1n);
          }
          const v2 = 27n + (signature.v === 27n ? 0n : 1n);
          if (signature.v !== v2)
            throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
          return v2;
        })();
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(v),
          signature.r,
          signature.s
        ];
      } else if (chainId > 0) {
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(chainId),
          "0x",
          "0x"
        ];
      }
      return (0, toRlp_js_1.toRlp)(serializedTransaction);
    }
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseUnits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseUnits = void 0;
    function parseUnits(value, decimals) {
      let [integer, fraction = "0"] = value.split(".");
      const negative = integer.startsWith("-");
      if (negative)
        integer = integer.slice(1);
      fraction = fraction.replace(/(0+)$/, "");
      if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
          integer = `${BigInt(integer) + 1n}`;
        fraction = "";
      } else if (fraction.length > decimals) {
        const [left, unit, right] = [
          fraction.slice(0, decimals - 1),
          fraction.slice(decimals - 1, decimals),
          fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
          fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else
          fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
          fraction = fraction.slice(1);
          integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
      } else {
        fraction = fraction.padEnd(decimals, "0");
      }
      return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
    }
    exports2.parseUnits = parseUnits;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseEther.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEther = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseEther(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
    }
    exports2.parseEther = parseEther;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/unit/parseGwei.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGwei = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseGwei(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
    }
    exports2.parseGwei = parseGwei;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/index.js
var require_utils7 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = exports2.extractFunctionParts = exports2.extractFunctionType = exports2.extractFunctionParams = exports2.extractFunctionName = exports2.isAddressEqual = exports2.isAddress = exports2.getAddress = exports2.getCreate2Address = exports2.getCreateAddress = exports2.getContractAddress = exports2.publicKeyToAddress = exports2.parseAccount = exports2.formatAbiParams = exports2.formatAbiItem = exports2.formatAbiItemWithArgs = exports2.encodePacked = exports2.parseAbiParameters = exports2.parseAbiParameter = exports2.parseAbiItem = exports2.parseAbi = exports2.getAbiItem = exports2.encodeFunctionResult = exports2.encodeFunctionData = exports2.encodeEventTopics = exports2.encodeErrorResult = exports2.encodeDeployData = exports2.encodeAbiParameters = exports2.decodeFunctionResult = exports2.decodeFunctionData = exports2.decodeEventLog = exports2.decodeErrorResult = exports2.decodeAbiParameters = exports2.validateTypedData = exports2.stringify = exports2.rpc = exports2.getSocket = exports2.integerRegex = exports2.bytesRegex = exports2.arrayRegex = exports2.getChainContractAddress = exports2.extractChain = exports2.defineChain = exports2.assertCurrentChain = exports2.offchainLookupSignature = exports2.offchainLookupAbiItem = exports2.offchainLookup = exports2.ccipFetch = exports2.buildRequest = exports2.isDeterministicError = void 0;
    exports2.getEstimateGasError = exports2.getContractError = exports2.getCallError = exports2.getNodeError = exports2.containsNodeError = exports2.fromRlp = exports2.hexToString = exports2.hexToNumber = exports2.hexToBigInt = exports2.hexToBool = exports2.fromHex = exports2.fromBytes = exports2.bytesToString = exports2.bytesToNumber = exports2.bytesToBool = exports2.bytesToBigint = exports2.bytesToBigInt = exports2.stringToHex = exports2.numberToHex = exports2.toHex = exports2.bytesToHex = exports2.boolToHex = exports2.stringToBytes = exports2.numberToBytes = exports2.hexToBytes = exports2.toBytes = exports2.boolToBytes = exports2.toRlp = exports2.extract = exports2.formatTransactionRequest = exports2.defineTransactionRequest = exports2.defineTransactionReceipt = exports2.formatLog = exports2.transactionType = exports2.formatTransaction = exports2.defineTransaction = exports2.formatBlock = exports2.defineBlock = exports2.trim = exports2.sliceHex = exports2.sliceBytes = exports2.slice = exports2.size = exports2.padHex = exports2.padBytes = exports2.pad = exports2.isHex = exports2.isBytes = exports2.concatHex = exports2.concatBytes = void 0;
    exports2.parseGwei = exports2.parseEther = exports2.parseUnits = exports2.formatUnits = exports2.formatGwei = exports2.formatEther = exports2.serializeAccessList = exports2.serializeTransaction = exports2.prepareTransactionRequest = exports2.parseTransaction = exports2.assertTransactionLegacy = exports2.assertTransactionEIP2930 = exports2.assertTransactionEIP1559 = exports2.assertRequest = exports2.getTransactionType = exports2.getSerializedTransactionType = exports2.hashMessage = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverTypedDataAddress = exports2.recoverPublicKey = exports2.recoverMessageAddress = exports2.recoverAddress = exports2.hashTypedData = exports2.ripemd160 = exports2.sha256 = exports2.keccak256 = exports2.isHash = exports2.getFunctionSelector = exports2.getEventSelector = exports2.defineFormatter = exports2.getTransactionError = void 0;
    var buildRequest_js_1 = require_buildRequest();
    Object.defineProperty(exports2, "isDeterministicError", { enumerable: true, get: function() {
      return buildRequest_js_1.isDeterministicError;
    } });
    Object.defineProperty(exports2, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_1.buildRequest;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports2, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports2, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports2, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports2, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    Object.defineProperty(exports2, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_1.assertCurrentChain;
    } });
    var defineChain_js_1 = require_defineChain();
    Object.defineProperty(exports2, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require_extractChain();
    Object.defineProperty(exports2, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    Object.defineProperty(exports2, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_1.getChainContractAddress;
    } });
    var regex_js_1 = require_regex2();
    Object.defineProperty(exports2, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_1.arrayRegex;
    } });
    Object.defineProperty(exports2, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_1.bytesRegex;
    } });
    Object.defineProperty(exports2, "integerRegex", { enumerable: true, get: function() {
      return regex_js_1.integerRegex;
    } });
    var rpc_js_1 = require_rpc2();
    Object.defineProperty(exports2, "getSocket", { enumerable: true, get: function() {
      return rpc_js_1.getSocket;
    } });
    Object.defineProperty(exports2, "rpc", { enumerable: true, get: function() {
      return rpc_js_1.rpc;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports2, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports2, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports2, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports2, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports2, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports2, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports2, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports2, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports2, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports2, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports2, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports2, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports2, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var abitype_1 = require_cjs();
    Object.defineProperty(exports2, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports2, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports2, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports2, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports2, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    Object.defineProperty(exports2, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem2();
    Object.defineProperty(exports2, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    Object.defineProperty(exports2, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiParams;
    } });
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports2, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports2, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports2, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports2, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    Object.defineProperty(exports2, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports2, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports2, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports2, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports2, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports2, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports2, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports2, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports2, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports2, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports2, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports2, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports2, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports2, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports2, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var block_js_1 = require_block2();
    Object.defineProperty(exports2, "defineBlock", { enumerable: true, get: function() {
      return block_js_1.defineBlock;
    } });
    Object.defineProperty(exports2, "formatBlock", { enumerable: true, get: function() {
      return block_js_1.formatBlock;
    } });
    var transaction_js_1 = require_transaction2();
    Object.defineProperty(exports2, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_1.defineTransaction;
    } });
    Object.defineProperty(exports2, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_1.formatTransaction;
    } });
    Object.defineProperty(exports2, "transactionType", { enumerable: true, get: function() {
      return transaction_js_1.transactionType;
    } });
    var log_js_1 = require_log2();
    Object.defineProperty(exports2, "formatLog", { enumerable: true, get: function() {
      return log_js_1.formatLog;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports2, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports2, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports2, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var extract_js_1 = require_extract();
    Object.defineProperty(exports2, "extract", { enumerable: true, get: function() {
      return extract_js_1.extract;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports2, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports2, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports2, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    Object.defineProperty(exports2, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports2, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports2, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports2, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports2, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports2, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    Object.defineProperty(exports2, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports2, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports2, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports2, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports2, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports2, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports2, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports2, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports2, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports2, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports2, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports2, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports2, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports2, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getNodeError_js_1 = require_getNodeError();
    Object.defineProperty(exports2, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.containsNodeError;
    } });
    Object.defineProperty(exports2, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.getNodeError;
    } });
    var getCallError_js_1 = require_getCallError();
    Object.defineProperty(exports2, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports2, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    Object.defineProperty(exports2, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_1 = require_getTransactionError();
    Object.defineProperty(exports2, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_1.getTransactionError;
    } });
    var formatter_js_1 = require_formatter();
    Object.defineProperty(exports2, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_1.defineFormatter;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports2, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports2, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports2, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var sha256_js_1 = require_sha2562();
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require_ripemd1602();
    Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports2, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports2, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports2, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports2, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports2, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports2, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports2, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports2, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports2, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    Object.defineProperty(exports2, "prepareTransactionRequest", { enumerable: true, get: function() {
      return prepareTransactionRequest_js_1.prepareTransactionRequest;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports2, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports2, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports2, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/proof.js
var require_proof = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/formatters/proof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatProof = void 0;
    var index_js_1 = require_utils7();
    function formatStorageProof(storageProof) {
      return storageProof.map((proof) => ({
        ...proof,
        value: BigInt(proof.value)
      }));
    }
    function formatProof(proof) {
      return {
        ...proof,
        balance: proof.balance ? BigInt(proof.balance) : void 0,
        nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : void 0,
        storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
      };
    }
    exports2.formatProof = formatProof;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getProof.js
var require_getProof = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getProof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProof = void 0;
    var toHex_js_1 = require_toHex();
    var proof_js_1 = require_proof();
    async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
      const blockTag = blockTag_ ?? "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const proof = await client.request({
        method: "eth_getProof",
        params: [address, storageKeys, blockNumberHex || blockTag]
      });
      return (0, proof_js_1.formatProof)(proof);
    }
    exports2.getProof = getProof;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getStorageAt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const data = await client.request({
        method: "eth_getStorageAt",
        params: [address, slot, blockNumberHex || blockTag]
      });
      return data;
    }
    exports2.getStorageAt = getStorageAt;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var toHex_js_1 = require_toHex();
    var transaction_js_2 = require_transaction2();
    async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index }) {
      const blockTag = blockTag_ || "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let transaction = null;
      if (hash) {
        transaction = await client.request({
          method: "eth_getTransactionByHash",
          params: [hash]
        });
      } else if (blockHash) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [blockHash, (0, toHex_js_1.numberToHex)(index)]
        });
      } else if (blockNumberHex || blockTag) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)]
        });
      }
      if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
          blockHash,
          blockNumber,
          blockTag,
          hash,
          index
        });
      const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
      return format(transaction);
    }
    exports2.getTransaction = getTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionConfirmations = void 0;
    var getAction_js_1 = require_getAction();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getTransaction_js_1 = require_getTransaction();
    async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
      const [blockNumber, transaction] = await Promise.all([
        (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({}),
        hash ? (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getBlockNumber")({ hash }) : void 0
      ]);
      const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
      if (!transactionBlockNumber)
        return 0n;
      return blockNumber - transactionBlockNumber + 1n;
    }
    exports2.getTransactionConfirmations = getTransactionConfirmations;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/getTransactionReceipt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    async function getTransactionReceipt(client, { hash }) {
      const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [hash]
      });
      if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
      const format = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
      return format(receipt);
    }
    exports2.getTransactionReceipt = getTransactionReceipt;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/multicall.js
var require_multicall = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/multicall.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multicall = void 0;
    var abis_js_1 = require_abis();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function multicall(client, args) {
      const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
      const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const chunkedCalls = [[]];
      let currentChunk = 0;
      let currentChunkSize = 0;
      for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args: args2, functionName } = contracts[i];
        try {
          const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi,
            args: args2,
            functionName
          });
          currentChunkSize += (callData.length - 2) / 2;
          if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
            currentChunk++;
            currentChunkSize = (callData.length - 2) / 2;
            chunkedCalls[currentChunk] = [];
          }
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData,
              target: address
            }
          ];
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData: "0x",
              target: address
            }
          ];
        }
      }
      const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: "aggregate3"
      })));
      const results = [];
      for (let i = 0; i < aggregate3Results.length; i++) {
        const result = aggregate3Results[i];
        if (result.status === "rejected") {
          if (!allowFailure)
            throw result.reason;
          for (let j = 0; j < chunkedCalls[i].length; j++) {
            results.push({
              status: "failure",
              error: result.reason,
              result: void 0
            });
          }
          continue;
        }
        const aggregate3Result = result.value;
        for (let j = 0; j < aggregate3Result.length; j++) {
          const { returnData, success } = aggregate3Result[j];
          const { callData } = chunkedCalls[i][j];
          const { abi, address, functionName, args: args2 } = contracts[results.length];
          try {
            if (callData === "0x")
              throw new abi_js_1.AbiDecodingZeroDataError();
            if (!success)
              throw new contract_js_1.RawContractError({ data: returnData });
            const result2 = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
              abi,
              args: args2,
              data: returnData,
              functionName
            });
            results.push(allowFailure ? { result: result2, status: "success" } : result2);
          } catch (err) {
            const error = (0, getContractError_js_1.getContractError)(err, {
              abi,
              address,
              args: args2,
              docsPath: "/docs/contract/multicall",
              functionName
            });
            if (!allowFailure)
              throw error;
            results.push({ error, result: void 0, status: "failure" });
          }
        }
      }
      if (results.length !== contracts.length)
        throw new base_js_1.BaseError("multicall results mismatch");
      return results;
    }
    exports2.multicall = multicall;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/contracts.js
var require_contracts = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/contracts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.universalSignatureValidatorByteCode = void 0;
    exports2.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/data/isBytesEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBytesEqual = void 0;
    var utils_1 = require_utils6();
    var toBytes_js_1 = require_toBytes();
    var isHex_js_1 = require_isHex();
    function isBytesEqual(a_, b_) {
      const a = (0, isHex_js_1.isHex)(a_) ? (0, toBytes_js_1.toBytes)(a_) : a_;
      const b = (0, isHex_js_1.isHex)(b_) ? (0, toBytes_js_1.toBytes)(b_) : b_;
      return (0, utils_1.equalBytes)(a, b);
    }
    exports2.isBytesEqual = isBytesEqual;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyHash = void 0;
    var abis_js_1 = require_abis();
    var contracts_js_1 = require_contracts();
    var contract_js_1 = require_contract();
    var isBytesEqual_js_1 = require_isBytesEqual();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils7();
    var call_js_1 = require_call();
    async function verifyHash(client, { address, hash, signature, ...callRequest }) {
      const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          data: (0, index_js_1.encodeDeployData)({
            abi: abis_js_1.universalSignatureValidatorAbi,
            args: [address, hash, signatureHex],
            bytecode: contracts_js_1.universalSignatureValidatorByteCode
          }),
          ...callRequest
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
      } catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
          return false;
        }
        throw error;
      }
    }
    exports2.verifyHash = verifyHash;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyMessage = void 0;
    var index_js_1 = require_utils7();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyMessage(client, { address, message, signature, ...callRequest }) {
      const hash = (0, index_js_1.hashMessage)(message);
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports2.verifyMessage = verifyMessage;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/verifyTypedData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyTypedData = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
      const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports2.verifyTypedData = verifyTypedData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchBlockNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchBlockNumber = void 0;
    var fromHex_js_1 = require_fromHex();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlockNumber_js_1 = require_getBlockNumber();
    function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlockNumber;
      const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlockNumber",
          client.uid,
          emitOnBegin,
          emitMissed,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
            if (prevBlockNumber) {
              if (blockNumber === prevBlockNumber)
                return;
              if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                  emit.onBlockNumber(i, prevBlockNumber);
                  prevBlockNumber = i;
                }
              }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }
    exports2.watchBlockNumber = watchBlockNumber;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.waitForTransactionReceipt = void 0;
    var block_js_1 = require_block();
    var transaction_js_1 = require_transaction();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var withRetry_js_1 = require_withRetry();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
      const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash]);
      let transaction;
      let replacedTransaction;
      let receipt;
      let retrying = false;
      return new Promise((resolve, reject) => {
        if (timeout)
          setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
          const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, "watchBlockNumber")({
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
              if (retrying)
                return;
              let blockNumber = blockNumber_;
              const done = (fn) => {
                _unwatch();
                fn();
                _unobserve();
              };
              try {
                if (receipt) {
                  if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                    return;
                  done(() => emit.resolve(receipt));
                  return;
                }
                if (!transaction) {
                  retrying = true;
                  await (0, withRetry_js_1.withRetry)(async () => {
                    transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getTransaction")({ hash });
                    if (transaction.blockNumber)
                      blockNumber = transaction.blockNumber;
                  }, {
                    delay: ({ count }) => ~~(1 << count) * 200,
                    retryCount: 6
                  });
                  retrying = false;
                }
                receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({ hash });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                done(() => emit.resolve(receipt));
              } catch (err) {
                if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                  try {
                    replacedTransaction = transaction;
                    retrying = true;
                    const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                      blockNumber,
                      includeTransactions: true
                    }), {
                      delay: ({ count }) => ~~(1 << count) * 200,
                      retryCount: 6,
                      shouldRetry: ({ error }) => error instanceof block_js_1.BlockNotFoundError
                    });
                    retrying = false;
                    const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                    if (!replacementTransaction)
                      return;
                    receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({
                      hash: replacementTransaction.hash
                    });
                    if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                      return;
                    let reason = "replaced";
                    if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                      reason = "repriced";
                    } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                      reason = "cancelled";
                    }
                    done(() => {
                      emit.onReplaced?.({
                        reason,
                        replacedTransaction,
                        transaction: replacementTransaction,
                        transactionReceipt: receipt
                      });
                      emit.resolve(receipt);
                    });
                  } catch (err_) {
                    done(() => emit.reject(err_));
                  }
                } else {
                  done(() => emit.reject(err));
                }
              }
            }
          });
        });
      });
    }
    exports2.waitForTransactionReceipt = waitForTransactionReceipt;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchBlocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchBlocks = void 0;
    var block_js_1 = require_block2();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const includeTransactions = includeTransactions_ ?? false;
      let prevBlock;
      const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlocks",
          client.uid,
          emitMissed,
          emitOnBegin,
          includeTransactions,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
              blockTag,
              includeTransactions
            });
            if (block.number && prevBlock?.number) {
              if (block.number === prevBlock.number)
                return;
              if (block.number - prevBlock.number > 1 && emitMissed) {
                for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                  const block2 = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                    blockNumber: i,
                    includeTransactions
                  });
                  emit.onBlock(block2, prevBlock);
                  prevBlock = block2;
                }
              }
            }
            if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
              emit.onBlock(block, prevBlock);
              prevBlock = block;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                const block = format(data.result);
                onBlock(block, prevBlock);
                prevBlock = block;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlocks() : subscribeBlocks();
    }
    exports2.watchBlocks = watchBlocks;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils7();
    var createEventFilter_js_1 = require_createEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const strict = strict_ ?? false;
      const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchEvent",
          address,
          args,
          batch,
          client.uid,
          event,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, "createEventFilter")({
                  address,
                  args,
                  event,
                  events,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              } else {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
                    address,
                    args,
                    event,
                    events,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                for (const log of logs)
                  emit.onLogs([log]);
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const events_ = events ?? (event ? [event] : void 0);
            let topics = [];
            if (events_) {
              topics = [
                events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                  abi: [event2],
                  eventName: event2.name,
                  args
                }))
              ];
              if (event)
                topics = topics[0];
            }
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                    abi: events_,
                    data: log.data,
                    topics: log.topics,
                    strict
                  });
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: args2,
                    eventName
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollEvent() : subscribeEvent();
    }
    exports2.watchEvent = watchEvent;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/public/watchPendingTransactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchPendingTransactions = void 0;
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchPendingTransactions",
          client.uid,
          batch,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
          let filter;
          const unwatch = (0, poll_js_1.poll)(async () => {
            try {
              if (!filter) {
                try {
                  filter = await (0, getAction_js_1.getAction)(client, createPendingTransactionFilter_js_1.createPendingTransactionFilter, "createPendingTransactionFilter")({});
                  return;
                } catch (err) {
                  unwatch();
                  throw err;
                }
              }
              const hashes = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              if (hashes.length === 0)
                return;
              if (batch)
                emit.onTransactions(hashes);
              else
                for (const hash of hashes)
                  emit.onTransactions([hash]);
            } catch (err) {
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newPendingTransactions"],
              onData(data) {
                if (!active)
                  return;
                const transaction = data.result;
                onTransactions([transaction]);
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
    }
    exports2.watchPendingTransactions = watchPendingTransactions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/public.js
var require_public = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publicActions = void 0;
    var getEnsAddress_js_1 = require_getEnsAddress();
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    var getEnsName_js_1 = require_getEnsName();
    var getEnsResolver_js_1 = require_getEnsResolver();
    var getEnsText_js_1 = require_getEnsText();
    var call_js_1 = require_call();
    var createBlockFilter_js_1 = require_createBlockFilter();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var createEventFilter_js_1 = require_createEventFilter();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBalance_js_1 = require_getBalance();
    var getBlock_js_1 = require_getBlock();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
    var getBytecode_js_1 = require_getBytecode();
    var getChainId_js_1 = require_getChainId();
    var getContractEvents_js_1 = require_getContractEvents();
    var getFeeHistory_js_1 = require_getFeeHistory();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getFilterLogs_js_1 = require_getFilterLogs();
    var getGasPrice_js_1 = require_getGasPrice();
    var getLogs_js_1 = require_getLogs();
    var getProof_js_1 = require_getProof();
    var getStorageAt_js_1 = require_getStorageAt();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var multicall_js_1 = require_multicall();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var uninstallFilter_js_1 = require_uninstallFilter();
    var verifyMessage_js_1 = require_verifyMessage2();
    var verifyTypedData_js_1 = require_verifyTypedData2();
    var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    var watchBlocks_js_1 = require_watchBlocks();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var watchEvent_js_1 = require_watchEvent();
    var watchPendingTransactions_js_1 = require_watchPendingTransactions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    function publicActions(client) {
      return {
        call: (args) => (0, call_js_1.call)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        getProof: (args) => (0, getProof_js_1.getProof)(client, args),
        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
      };
    }
    exports2.publicActions = publicActions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createPublicClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPublicClient = void 0;
    var createClient_js_1 = require_createClient();
    var public_js_1 = require_public();
    function createPublicClient(parameters) {
      const { key = "public", name = "Public Client" } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "publicClient"
      });
      return client.extend(public_js_1.publicActions);
    }
    exports2.createPublicClient = createPublicClient;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/dropTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropTransaction = void 0;
    async function dropTransaction(client, { hash }) {
      await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash]
      });
    }
    exports2.dropTransaction = dropTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/dumpState.js
var require_dumpState = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/dumpState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dumpState = void 0;
    async function dumpState(client) {
      return client.request({
        method: `${client.mode}_dumpState`
      });
    }
    exports2.dumpState = dumpState;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getAutomine.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAutomine = void 0;
    async function getAutomine(client) {
      if (client.mode === "ganache")
        return await client.request({
          method: "eth_mining"
        });
      return await client.request({
        method: `${client.mode}_getAutomine`
      });
    }
    exports2.getAutomine = getAutomine;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getTxpoolContent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTxpoolContent = void 0;
    async function getTxpoolContent(client) {
      return await client.request({
        method: "txpool_content"
      });
    }
    exports2.getTxpoolContent = getTxpoolContent;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/getTxpoolStatus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTxpoolStatus = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getTxpoolStatus(client) {
      const { pending, queued } = await client.request({
        method: "txpool_status"
      });
      return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued)
      };
    }
    exports2.getTxpoolStatus = getTxpoolStatus;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/impersonateAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.impersonateAccount = void 0;
    async function impersonateAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address]
      });
    }
    exports2.impersonateAccount = impersonateAccount;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/increaseTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.increaseTime = void 0;
    var toHex_js_1 = require_toHex();
    async function increaseTime(client, { seconds }) {
      return await client.request({
        method: "evm_increaseTime",
        params: [(0, toHex_js_1.numberToHex)(seconds)]
      });
    }
    exports2.increaseTime = increaseTime;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/inspectTxpool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspectTxpool = void 0;
    async function inspectTxpool(client) {
      return await client.request({
        method: "txpool_inspect"
      });
    }
    exports2.inspectTxpool = inspectTxpool;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/loadState.js
var require_loadState = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/loadState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadState = void 0;
    async function loadState(client, { state }) {
      await client.request({
        method: `${client.mode}_loadState`,
        params: [state]
      });
    }
    exports2.loadState = loadState;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/mine.js
var require_mine = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/mine.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mine = void 0;
    var toHex_js_1 = require_toHex();
    async function mine(client, { blocks, interval }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_mine",
          params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
        });
      else
        await client.request({
          method: `${client.mode}_mine`,
          params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
        });
    }
    exports2.mine = mine;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeBlockTimestampInterval = void 0;
    async function removeBlockTimestampInterval(client) {
      await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
      });
    }
    exports2.removeBlockTimestampInterval = removeBlockTimestampInterval;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/reset.js
var require_reset = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/reset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reset = void 0;
    async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
      await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
      });
    }
    exports2.reset = reset;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/revert.js
var require_revert = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/revert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.revert = void 0;
    async function revert(client, { id }) {
      await client.request({
        method: "evm_revert",
        params: [id]
      });
    }
    exports2.revert = revert;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendUnsignedTransaction = void 0;
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    async function sendUnsignedTransaction(client, args) {
      const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const hash = await client.request({
        method: "eth_sendUnsignedTransaction",
        params: [request]
      });
      return hash;
    }
    exports2.sendUnsignedTransaction = sendUnsignedTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setAutomine.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setAutomine = void 0;
    async function setAutomine(client, enabled) {
      if (client.mode === "ganache") {
        if (enabled)
          await client.request({ method: "miner_start" });
        else
          await client.request({ method: "miner_stop" });
      } else
        await client.request({
          method: "evm_setAutomine",
          params: [enabled]
        });
    }
    exports2.setAutomine = setAutomine;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBalance.js
var require_setBalance = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBalance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function setBalance(client, { address, value }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_setAccountBalance",
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
      else
        await client.request({
          method: `${client.mode}_setBalance`,
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
    }
    exports2.setBalance = setBalance;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBlockGasLimit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setBlockGasLimit = void 0;
    var toHex_js_1 = require_toHex();
    async function setBlockGasLimit(client, { gasLimit }) {
      await client.request({
        method: "evm_setBlockGasLimit",
        params: [(0, toHex_js_1.numberToHex)(gasLimit)]
      });
    }
    exports2.setBlockGasLimit = setBlockGasLimit;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setBlockTimestampInterval = void 0;
    async function setBlockTimestampInterval(client, { interval }) {
      const interval_ = (() => {
        if (client.mode === "hardhat")
          return interval * 1e3;
        return interval;
      })();
      await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval_]
      });
    }
    exports2.setBlockTimestampInterval = setBlockTimestampInterval;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setCode.js
var require_setCode = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCode = void 0;
    async function setCode(client, { address, bytecode }) {
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
    }
    exports2.setCode = setCode;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setCoinbase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCoinbase = void 0;
    async function setCoinbase(client, { address }) {
      await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address]
      });
    }
    exports2.setCoinbase = setCoinbase;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setIntervalMining.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setIntervalMining = void 0;
    async function setIntervalMining(client, { interval }) {
      const interval_ = (() => {
        if (client.mode === "hardhat")
          return interval * 1e3;
        return interval;
      })();
      await client.request({
        method: "evm_setIntervalMining",
        params: [interval_]
      });
    }
    exports2.setIntervalMining = setIntervalMining;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setLoggingEnabled.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setLoggingEnabled = void 0;
    async function setLoggingEnabled(client, enabled) {
      await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled]
      });
    }
    exports2.setLoggingEnabled = setLoggingEnabled;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setMinGasPrice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setMinGasPrice = void 0;
    var toHex_js_1 = require_toHex();
    async function setMinGasPrice(client, { gasPrice }) {
      await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)]
      });
    }
    exports2.setMinGasPrice = setMinGasPrice;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setNextBlockBaseFeePerGas = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
      await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
      });
    }
    exports2.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setNextBlockTimestamp = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockTimestamp(client, { timestamp }) {
      await client.request({
        method: "evm_setNextBlockTimestamp",
        params: [(0, toHex_js_1.numberToHex)(timestamp)]
      });
    }
    exports2.setNextBlockTimestamp = setNextBlockTimestamp;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNonce.js
var require_setNonce = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setNonce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setNonce = void 0;
    var toHex_js_1 = require_toHex();
    async function setNonce(client, { address, nonce }) {
      await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)]
      });
    }
    exports2.setNonce = setNonce;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setRpcUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRpcUrl = void 0;
    async function setRpcUrl(client, jsonRpcUrl) {
      await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl]
      });
    }
    exports2.setRpcUrl = setRpcUrl;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/setStorageAt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function setStorageAt(client, { address, index, value }) {
      await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
          address,
          typeof index === "number" ? (0, toHex_js_1.numberToHex)(index) : index,
          value
        ]
      });
    }
    exports2.setStorageAt = setStorageAt;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/snapshot.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.snapshot = void 0;
    async function snapshot(client) {
      return await client.request({
        method: "evm_snapshot"
      });
    }
    exports2.snapshot = snapshot;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stopImpersonatingAccount = void 0;
    async function stopImpersonatingAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address]
      });
    }
    exports2.stopImpersonatingAccount = stopImpersonatingAccount;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/test.js
var require_test = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/test.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testActions = void 0;
    var dropTransaction_js_1 = require_dropTransaction();
    var dumpState_js_1 = require_dumpState();
    var getAutomine_js_1 = require_getAutomine();
    var getTxpoolContent_js_1 = require_getTxpoolContent();
    var getTxpoolStatus_js_1 = require_getTxpoolStatus();
    var impersonateAccount_js_1 = require_impersonateAccount();
    var increaseTime_js_1 = require_increaseTime();
    var inspectTxpool_js_1 = require_inspectTxpool();
    var loadState_js_1 = require_loadState();
    var mine_js_1 = require_mine();
    var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
    var reset_js_1 = require_reset();
    var revert_js_1 = require_revert();
    var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
    var setAutomine_js_1 = require_setAutomine();
    var setBalance_js_1 = require_setBalance();
    var setBlockGasLimit_js_1 = require_setBlockGasLimit();
    var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
    var setCode_js_1 = require_setCode();
    var setCoinbase_js_1 = require_setCoinbase();
    var setIntervalMining_js_1 = require_setIntervalMining();
    var setLoggingEnabled_js_1 = require_setLoggingEnabled();
    var setMinGasPrice_js_1 = require_setMinGasPrice();
    var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
    var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
    var setNonce_js_1 = require_setNonce();
    var setRpcUrl_js_1 = require_setRpcUrl();
    var setStorageAt_js_1 = require_setStorageAt();
    var snapshot_js_1 = require_snapshot();
    var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
    function testActions({ mode }) {
      return (client_) => {
        const client = client_.extend(() => ({
          mode
        }));
        return {
          dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
          dumpState: () => (0, dumpState_js_1.dumpState)(client),
          getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
          getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
          getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
          impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
          increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
          inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
          loadState: (args) => (0, loadState_js_1.loadState)(client, args),
          mine: (args) => (0, mine_js_1.mine)(client, args),
          removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
          reset: (args) => (0, reset_js_1.reset)(client, args),
          revert: (args) => (0, revert_js_1.revert)(client, args),
          sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
          setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
          setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
          setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
          setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
          setCode: (args) => (0, setCode_js_1.setCode)(client, args),
          setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
          setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
          setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
          setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
          setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
          setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
          setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
          setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
          setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
          snapshot: () => (0, snapshot_js_1.snapshot)(client),
          stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
        };
      };
    }
    exports2.testActions = testActions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createTestClient.js
var require_createTestClient = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createTestClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTestClient = void 0;
    var createClient_js_1 = require_createClient();
    var test_js_1 = require_test();
    function createTestClient(parameters) {
      const { key = "test", name = "Test Client", mode } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "testClient"
      });
      return client.extend((config2) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config2)
      }));
    }
    exports2.createTestClient = createTestClient;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/addChain.js
var require_addChain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/addChain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addChain = void 0;
    var toHex_js_1 = require_toHex();
    async function addChain(client, { chain }) {
      const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
      await client.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id),
            chainName: name,
            nativeCurrency,
            rpcUrls: rpcUrls.default.http,
            blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
          }
        ]
      });
    }
    exports2.addChain = addChain;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/deployContract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deployContract = void 0;
    var encodeDeployData_js_1 = require_encodeDeployData();
    var sendTransaction_js_1 = require_sendTransaction();
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
      const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode
      });
      return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata
      });
    }
    exports2.deployContract = deployContract;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/getAddresses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function getAddresses(client) {
      if (client.account?.type === "local")
        return [client.account.address];
      const addresses = await client.request({ method: "eth_accounts" });
      return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
    }
    exports2.getAddresses = getAddresses;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/getPermissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPermissions = void 0;
    async function getPermissions(client) {
      const permissions = await client.request({ method: "wallet_getPermissions" });
      return permissions;
    }
    exports2.getPermissions = getPermissions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/requestAddresses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.requestAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function requestAddresses(client) {
      const addresses = await client.request({ method: "eth_requestAccounts" });
      return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
    }
    exports2.requestAddresses = requestAddresses;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/requestPermissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.requestPermissions = void 0;
    async function requestPermissions(client, permissions) {
      return client.request({
        method: "wallet_requestPermissions",
        params: [permissions]
      });
    }
    exports2.requestPermissions = requestPermissions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signMessage = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    async function signMessage(client, { account: account_ = client.account, message }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      if (account.type === "local")
        return account.signMessage({ message });
      const message_ = (() => {
        if (typeof message === "string")
          return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
          return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
      })();
      return client.request({
        method: "personal_sign",
        params: [message_, account.address]
      });
    }
    exports2.signMessage = signMessage;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signTransaction.js
var require_signTransaction = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signTransaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    var transactionRequest_js_1 = require_transactionRequest();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils7();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    async function signTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, ...transaction } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      (0, assertRequest_js_1.assertRequest)({
        account,
        ...args
      });
      const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
      if (chain !== null)
        (0, assertCurrentChain_js_1.assertCurrentChain)({
          currentChainId: chainId,
          chain
        });
      const formatters = chain?.formatters || client.chain?.formatters;
      const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      if (account.type === "local")
        return account.signTransaction({
          ...transaction,
          chainId
        }, { serializer: client.chain?.serializers?.transaction });
      return await client.request({
        method: "eth_signTransaction",
        params: [
          {
            ...format(transaction),
            chainId: (0, index_js_1.numberToHex)(chainId),
            from: account.address
          }
        ]
      });
    }
    exports2.signTransaction = signTransaction;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/signTypedData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signTypedData = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    var typedData_js_1 = require_typedData();
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTypedData"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      if (account.type === "local")
        return account.signTypedData({
          domain,
          primaryType,
          types,
          message
        });
      const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
      return client.request({
        method: "eth_signTypedData_v4",
        params: [account.address, typedData]
      });
    }
    exports2.signTypedData = signTypedData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/switchChain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchChain = void 0;
    var toHex_js_1 = require_toHex();
    async function switchChain(client, { id }) {
      await client.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id)
          }
        ]
      });
    }
    exports2.switchChain = switchChain;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/actions/wallet/watchAsset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.watchAsset = void 0;
    async function watchAsset(client, params) {
      const added = await client.request({
        method: "wallet_watchAsset",
        params
      });
      return added;
    }
    exports2.watchAsset = watchAsset;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/wallet.js
var require_wallet = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/decorators/wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.walletActions = void 0;
    var getChainId_js_1 = require_getChainId();
    var addChain_js_1 = require_addChain();
    var deployContract_js_1 = require_deployContract();
    var getAddresses_js_1 = require_getAddresses();
    var getPermissions_js_1 = require_getPermissions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var requestAddresses_js_1 = require_requestAddresses();
    var requestPermissions_js_1 = require_requestPermissions();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    var sendTransaction_js_1 = require_sendTransaction();
    var signMessage_js_1 = require_signMessage();
    var signTransaction_js_1 = require_signTransaction();
    var signTypedData_js_1 = require_signTypedData();
    var switchChain_js_1 = require_switchChain();
    var watchAsset_js_1 = require_watchAsset();
    var writeContract_js_1 = require_writeContract();
    function walletActions(client) {
      return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
      };
    }
    exports2.walletActions = walletActions;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/createWalletClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createWalletClient = void 0;
    var createClient_js_1 = require_createClient();
    var wallet_js_1 = require_wallet();
    function createWalletClient(parameters) {
      const { key = "wallet", name = "Wallet Client", transport } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      });
      return client.extend(wallet_js_1.walletActions);
    }
    exports2.createWalletClient = createWalletClient;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/webSocket.js
var require_webSocket = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/clients/transports/webSocket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webSocket = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function webSocket(url, config2 = {}) {
      const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config2;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config2.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config2.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
              body,
              timeout
            });
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "webSocket"
        }, {
          getSocket() {
            return (0, rpc_js_1.getSocket)(url_);
          },
          async subscribe({ params, onData, onError }) {
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onResponse(response) {
                if (response.error) {
                  reject(response.error);
                  onError?.(response.error);
                  return;
                }
                if (typeof response.id === "number") {
                  resolve(response);
                  return;
                }
                if (response.method !== "eth_subscription")
                  return;
                onData(response.params);
              }
            }));
            return {
              subscriptionId,
              async unsubscribe() {
                return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onResponse: resolve
                }));
              }
            };
          }
        });
      };
    }
    exports2.webSocket = webSocket;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/address.js
var require_address2 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zeroAddress = void 0;
    exports2.zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/number.js
var require_number = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.minInt144 = exports2.minInt136 = exports2.minInt128 = exports2.minInt120 = exports2.minInt112 = exports2.minInt104 = exports2.minInt96 = exports2.minInt88 = exports2.minInt80 = exports2.minInt72 = exports2.minInt64 = exports2.minInt56 = exports2.minInt48 = exports2.minInt40 = exports2.minInt32 = exports2.minInt24 = exports2.minInt16 = exports2.minInt8 = exports2.maxInt256 = exports2.maxInt248 = exports2.maxInt240 = exports2.maxInt232 = exports2.maxInt224 = exports2.maxInt216 = exports2.maxInt208 = exports2.maxInt200 = exports2.maxInt192 = exports2.maxInt184 = exports2.maxInt176 = exports2.maxInt168 = exports2.maxInt160 = exports2.maxInt152 = exports2.maxInt144 = exports2.maxInt136 = exports2.maxInt128 = exports2.maxInt120 = exports2.maxInt112 = exports2.maxInt104 = exports2.maxInt96 = exports2.maxInt88 = exports2.maxInt80 = exports2.maxInt72 = exports2.maxInt64 = exports2.maxInt56 = exports2.maxInt48 = exports2.maxInt40 = exports2.maxInt32 = exports2.maxInt24 = exports2.maxInt16 = exports2.maxInt8 = void 0;
    exports2.maxUint256 = exports2.maxUint248 = exports2.maxUint240 = exports2.maxUint232 = exports2.maxUint224 = exports2.maxUint216 = exports2.maxUint208 = exports2.maxUint200 = exports2.maxUint192 = exports2.maxUint184 = exports2.maxUint176 = exports2.maxUint168 = exports2.maxUint160 = exports2.maxUint152 = exports2.maxUint144 = exports2.maxUint136 = exports2.maxUint128 = exports2.maxUint120 = exports2.maxUint112 = exports2.maxUint104 = exports2.maxUint96 = exports2.maxUint88 = exports2.maxUint80 = exports2.maxUint72 = exports2.maxUint64 = exports2.maxUint56 = exports2.maxUint48 = exports2.maxUint40 = exports2.maxUint32 = exports2.maxUint24 = exports2.maxUint16 = exports2.maxUint8 = exports2.minInt256 = exports2.minInt248 = exports2.minInt240 = exports2.minInt232 = exports2.minInt224 = exports2.minInt216 = exports2.minInt208 = exports2.minInt200 = exports2.minInt192 = exports2.minInt184 = exports2.minInt176 = exports2.minInt168 = exports2.minInt160 = exports2.minInt152 = void 0;
    exports2.maxInt8 = 2n ** (8n - 1n) - 1n;
    exports2.maxInt16 = 2n ** (16n - 1n) - 1n;
    exports2.maxInt24 = 2n ** (24n - 1n) - 1n;
    exports2.maxInt32 = 2n ** (32n - 1n) - 1n;
    exports2.maxInt40 = 2n ** (40n - 1n) - 1n;
    exports2.maxInt48 = 2n ** (48n - 1n) - 1n;
    exports2.maxInt56 = 2n ** (56n - 1n) - 1n;
    exports2.maxInt64 = 2n ** (64n - 1n) - 1n;
    exports2.maxInt72 = 2n ** (72n - 1n) - 1n;
    exports2.maxInt80 = 2n ** (80n - 1n) - 1n;
    exports2.maxInt88 = 2n ** (88n - 1n) - 1n;
    exports2.maxInt96 = 2n ** (96n - 1n) - 1n;
    exports2.maxInt104 = 2n ** (104n - 1n) - 1n;
    exports2.maxInt112 = 2n ** (112n - 1n) - 1n;
    exports2.maxInt120 = 2n ** (120n - 1n) - 1n;
    exports2.maxInt128 = 2n ** (128n - 1n) - 1n;
    exports2.maxInt136 = 2n ** (136n - 1n) - 1n;
    exports2.maxInt144 = 2n ** (144n - 1n) - 1n;
    exports2.maxInt152 = 2n ** (152n - 1n) - 1n;
    exports2.maxInt160 = 2n ** (160n - 1n) - 1n;
    exports2.maxInt168 = 2n ** (168n - 1n) - 1n;
    exports2.maxInt176 = 2n ** (176n - 1n) - 1n;
    exports2.maxInt184 = 2n ** (184n - 1n) - 1n;
    exports2.maxInt192 = 2n ** (192n - 1n) - 1n;
    exports2.maxInt200 = 2n ** (200n - 1n) - 1n;
    exports2.maxInt208 = 2n ** (208n - 1n) - 1n;
    exports2.maxInt216 = 2n ** (216n - 1n) - 1n;
    exports2.maxInt224 = 2n ** (224n - 1n) - 1n;
    exports2.maxInt232 = 2n ** (232n - 1n) - 1n;
    exports2.maxInt240 = 2n ** (240n - 1n) - 1n;
    exports2.maxInt248 = 2n ** (248n - 1n) - 1n;
    exports2.maxInt256 = 2n ** (256n - 1n) - 1n;
    exports2.minInt8 = -(2n ** (8n - 1n));
    exports2.minInt16 = -(2n ** (16n - 1n));
    exports2.minInt24 = -(2n ** (24n - 1n));
    exports2.minInt32 = -(2n ** (32n - 1n));
    exports2.minInt40 = -(2n ** (40n - 1n));
    exports2.minInt48 = -(2n ** (48n - 1n));
    exports2.minInt56 = -(2n ** (56n - 1n));
    exports2.minInt64 = -(2n ** (64n - 1n));
    exports2.minInt72 = -(2n ** (72n - 1n));
    exports2.minInt80 = -(2n ** (80n - 1n));
    exports2.minInt88 = -(2n ** (88n - 1n));
    exports2.minInt96 = -(2n ** (96n - 1n));
    exports2.minInt104 = -(2n ** (104n - 1n));
    exports2.minInt112 = -(2n ** (112n - 1n));
    exports2.minInt120 = -(2n ** (120n - 1n));
    exports2.minInt128 = -(2n ** (128n - 1n));
    exports2.minInt136 = -(2n ** (136n - 1n));
    exports2.minInt144 = -(2n ** (144n - 1n));
    exports2.minInt152 = -(2n ** (152n - 1n));
    exports2.minInt160 = -(2n ** (160n - 1n));
    exports2.minInt168 = -(2n ** (168n - 1n));
    exports2.minInt176 = -(2n ** (176n - 1n));
    exports2.minInt184 = -(2n ** (184n - 1n));
    exports2.minInt192 = -(2n ** (192n - 1n));
    exports2.minInt200 = -(2n ** (200n - 1n));
    exports2.minInt208 = -(2n ** (208n - 1n));
    exports2.minInt216 = -(2n ** (216n - 1n));
    exports2.minInt224 = -(2n ** (224n - 1n));
    exports2.minInt232 = -(2n ** (232n - 1n));
    exports2.minInt240 = -(2n ** (240n - 1n));
    exports2.minInt248 = -(2n ** (248n - 1n));
    exports2.minInt256 = -(2n ** (256n - 1n));
    exports2.maxUint8 = 2n ** 8n - 1n;
    exports2.maxUint16 = 2n ** 16n - 1n;
    exports2.maxUint24 = 2n ** 24n - 1n;
    exports2.maxUint32 = 2n ** 32n - 1n;
    exports2.maxUint40 = 2n ** 40n - 1n;
    exports2.maxUint48 = 2n ** 48n - 1n;
    exports2.maxUint56 = 2n ** 56n - 1n;
    exports2.maxUint64 = 2n ** 64n - 1n;
    exports2.maxUint72 = 2n ** 72n - 1n;
    exports2.maxUint80 = 2n ** 80n - 1n;
    exports2.maxUint88 = 2n ** 88n - 1n;
    exports2.maxUint96 = 2n ** 96n - 1n;
    exports2.maxUint104 = 2n ** 104n - 1n;
    exports2.maxUint112 = 2n ** 112n - 1n;
    exports2.maxUint120 = 2n ** 120n - 1n;
    exports2.maxUint128 = 2n ** 128n - 1n;
    exports2.maxUint136 = 2n ** 136n - 1n;
    exports2.maxUint144 = 2n ** 144n - 1n;
    exports2.maxUint152 = 2n ** 152n - 1n;
    exports2.maxUint160 = 2n ** 160n - 1n;
    exports2.maxUint168 = 2n ** 168n - 1n;
    exports2.maxUint176 = 2n ** 176n - 1n;
    exports2.maxUint184 = 2n ** 184n - 1n;
    exports2.maxUint192 = 2n ** 192n - 1n;
    exports2.maxUint200 = 2n ** 200n - 1n;
    exports2.maxUint208 = 2n ** 208n - 1n;
    exports2.maxUint216 = 2n ** 216n - 1n;
    exports2.maxUint224 = 2n ** 224n - 1n;
    exports2.maxUint232 = 2n ** 232n - 1n;
    exports2.maxUint240 = 2n ** 240n - 1n;
    exports2.maxUint248 = 2n ** 248n - 1n;
    exports2.maxUint256 = 2n ** 256n - 1n;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/bytes.js
var require_bytes = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/constants/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zeroHash = void 0;
    exports2.zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/abi/decodeDeployData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var docsPath = "/docs/contract/decodeDeployData";
    function decodeDeployData({ abi, bytecode, data }) {
      if (data === bytecode)
        return { bytecode };
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
      return { args, bytecode };
    }
    exports2.decodeDeployData = decodeDeployData;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js
var require_compactSignatureToSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactSignatureToSignature = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function compactSignatureToSignature({ r, yParityAndS }) {
      const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
      const v = yParityAndS_bytes[0] & 128 ? 28n : 27n;
      const s = yParityAndS_bytes;
      if (v === 28n)
        s[0] &= 127;
      return { r, s: (0, toHex_js_1.bytesToHex)(s), v };
    }
    exports2.compactSignatureToSignature = compactSignatureToSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js
var require_hexToCompactSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToCompactSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToCompactSignature(signatureHex) {
      const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      return {
        r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
        yParityAndS: (0, toHex_js_1.numberToHex)(s, { size: 32 })
      };
    }
    exports2.hexToCompactSignature = hexToCompactSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hexToSignature.js
var require_hexToSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/hexToSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToSignature(signatureHex) {
      const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      const v = BigInt(`0x${signatureHex.slice(130)}`);
      return { r: (0, toHex_js_1.numberToHex)(r, { size: 32 }), s: (0, toHex_js_1.numberToHex)(s, { size: 32 }), v };
    }
    exports2.hexToSignature = hexToSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js
var require_signatureToCompactSignature = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signatureToCompactSignature = void 0;
    var index_js_1 = require_utils7();
    function signatureToCompactSignature(signature) {
      const { r, s, v } = signature;
      const yParity = v - 27n;
      let yParityAndS = s;
      if (yParity === 1n) {
        const bytes = (0, index_js_1.hexToBytes)(s);
        bytes[0] |= 128;
        yParityAndS = (0, index_js_1.bytesToHex)(bytes);
      }
      return { r, yParityAndS };
    }
    exports2.signatureToCompactSignature = signatureToCompactSignature;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js
var require_compactSignatureToHex = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactSignatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    function compactSignatureToHex({ r, yParityAndS }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
    }
    exports2.compactSignatureToHex = compactSignatureToHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/signatureToHex.js
var require_signatureToHex = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/utils/signature/signatureToHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function signatureToHex({ r, s, v }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${(0, toHex_js_1.toHex)(v).slice(2)}`;
    }
    exports2.signatureToHex = signatureToHex;
  }
});

// node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/.pnpm/viem@1.21.4_typescript@4.9.3_zod@3.22.4/node_modules/viem/_cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.maxInt112 = exports2.maxInt104 = exports2.maxInt96 = exports2.maxInt88 = exports2.maxInt80 = exports2.maxInt72 = exports2.maxInt64 = exports2.maxInt56 = exports2.maxInt48 = exports2.maxInt40 = exports2.maxInt32 = exports2.maxInt24 = exports2.maxInt16 = exports2.maxInt8 = exports2.weiUnits = exports2.gweiUnits = exports2.etherUnits = exports2.zeroAddress = exports2.multicall3Abi = exports2.webSocket = exports2.createWalletClient = exports2.createTransport = exports2.walletActions = exports2.testActions = exports2.publicActions = exports2.createTestClient = exports2.createPublicClient = exports2.http = exports2.fallback = exports2.custom = exports2.createClient = exports2.getContract = exports2.parseAbiParameters = exports2.parseAbiParameter = exports2.parseAbiItem = exports2.parseAbi = exports2.UnknownSignatureError = exports2.UnknownTypeError = exports2.SolidityProtectedKeywordError = exports2.InvalidStructSignatureError = exports2.InvalidSignatureError = exports2.InvalidParenthesisError = exports2.InvalidParameterError = exports2.InvalidModifierError = exports2.InvalidFunctionModifierError = exports2.InvalidAbiTypeParameterError = exports2.InvalidAbiItemError = exports2.InvalidAbiParametersError = exports2.InvalidAbiParameterError = exports2.CircularReferenceError = void 0;
    exports2.maxUint256 = exports2.maxUint248 = exports2.maxUint240 = exports2.maxUint232 = exports2.maxUint224 = exports2.maxUint216 = exports2.maxUint208 = exports2.maxUint200 = exports2.maxUint192 = exports2.maxUint184 = exports2.maxUint176 = exports2.maxUint168 = exports2.maxUint160 = exports2.maxUint152 = exports2.maxUint144 = exports2.maxUint136 = exports2.maxUint128 = exports2.maxUint120 = exports2.maxUint112 = exports2.maxUint104 = exports2.maxUint96 = exports2.maxUint88 = exports2.maxUint80 = exports2.maxUint72 = exports2.maxUint64 = exports2.maxUint56 = exports2.maxUint48 = exports2.maxUint40 = exports2.maxUint32 = exports2.maxUint24 = exports2.maxUint16 = exports2.maxUint8 = exports2.maxInt256 = exports2.maxInt248 = exports2.maxInt240 = exports2.maxInt232 = exports2.maxInt224 = exports2.maxInt216 = exports2.maxInt208 = exports2.maxInt200 = exports2.maxInt192 = exports2.maxInt184 = exports2.maxInt176 = exports2.maxInt168 = exports2.maxInt160 = exports2.maxInt152 = exports2.maxInt144 = exports2.maxInt136 = exports2.maxInt128 = exports2.maxInt120 = void 0;
    exports2.AbiFunctionOutputsNotFoundError = exports2.AbiFunctionNotFoundError = exports2.AbiEventSignatureNotFoundError = exports2.AbiEventSignatureEmptyTopicsError = exports2.AbiEventNotFoundError = exports2.AbiErrorSignatureNotFoundError = exports2.AbiErrorNotFoundError = exports2.AbiErrorInputsNotFoundError = exports2.AbiEncodingBytesSizeMismatchError = exports2.AbiEncodingLengthMismatchError = exports2.AbiEncodingArrayLengthMismatchError = exports2.AbiDecodingZeroDataError = exports2.AbiDecodingDataSizeTooSmallError = exports2.AbiDecodingDataSizeInvalidError = exports2.AbiConstructorParamsNotFoundError = exports2.AbiConstructorNotFoundError = exports2.presignMessagePrefix = exports2.zeroHash = exports2.minInt256 = exports2.minInt248 = exports2.minInt240 = exports2.minInt232 = exports2.minInt224 = exports2.minInt216 = exports2.minInt208 = exports2.minInt200 = exports2.minInt192 = exports2.minInt184 = exports2.minInt176 = exports2.minInt168 = exports2.minInt160 = exports2.minInt152 = exports2.minInt144 = exports2.minInt136 = exports2.minInt128 = exports2.minInt120 = exports2.minInt112 = exports2.minInt104 = exports2.minInt96 = exports2.minInt88 = exports2.minInt80 = exports2.minInt72 = exports2.minInt64 = exports2.minInt56 = exports2.minInt48 = exports2.minInt40 = exports2.minInt32 = exports2.minInt24 = exports2.minInt16 = exports2.minInt8 = void 0;
    exports2.InvalidHexBooleanError = exports2.IntegerOutOfRangeError = exports2.InvalidBytesBooleanError = exports2.DataLengthTooShortError = exports2.DataLengthTooLongError = exports2.InvalidChainIdError = exports2.ClientChainNotConfiguredError = exports2.ChainNotFoundError = exports2.ChainMismatchError = exports2.ChainDoesNotSupportContract = exports2.UserRejectedRequestError = exports2.UnsupportedProviderMethodError = exports2.UnknownRpcError = exports2.UnauthorizedProviderError = exports2.TransactionRejectedRpcError = exports2.SwitchChainError = exports2.RpcError = exports2.ResourceUnavailableRpcError = exports2.ResourceNotFoundRpcError = exports2.ProviderRpcError = exports2.ProviderDisconnectedError = exports2.ParseRpcError = exports2.MethodNotSupportedRpcError = exports2.MethodNotFoundRpcError = exports2.LimitExceededRpcError = exports2.JsonRpcVersionUnsupportedError = exports2.InvalidRequestRpcError = exports2.InvalidParamsRpcError = exports2.InvalidInputRpcError = exports2.InternalRpcError = exports2.ChainDisconnectedError = exports2.MaxFeePerGasTooLowError = exports2.Eip1559FeesNotSupportedError = exports2.BaseFeeScalarError = exports2.RawContractError = exports2.ContractFunctionZeroDataError = exports2.ContractFunctionRevertedError = exports2.ContractFunctionExecutionError = exports2.CallExecutionError = exports2.BlockNotFoundError = exports2.BaseError = exports2.UnsupportedPackedAbiType = exports2.InvalidDefinitionTypeError = exports2.InvalidArrayError = exports2.InvalidAbiEncodingTypeError = exports2.InvalidAbiDecodingTypeError = exports2.DecodeLogTopicsMismatch = exports2.DecodeLogDataMismatch = exports2.BytesSizeMismatchError = exports2.AbiFunctionSignatureNotFoundError = void 0;
    exports2.encodeAbiParameters = exports2.decodeFunctionResult = exports2.decodeFunctionData = exports2.decodeEventLog = exports2.decodeErrorResult = exports2.decodeDeployData = exports2.decodeAbiParameters = exports2.formatLog = exports2.formatBlock = exports2.defineBlock = exports2.namehash = exports2.labelhash = exports2.UrlRequiredError = exports2.SliceOffsetOutOfBoundsError = exports2.SizeExceedsPaddingSizeError = exports2.WaitForTransactionReceiptTimeoutError = exports2.TransactionReceiptNotFoundError = exports2.TransactionNotFoundError = exports2.TransactionExecutionError = exports2.InvalidStorageKeySizeError = exports2.InvalidSerializedTransactionTypeError = exports2.InvalidSerializedTransactionError = exports2.InvalidSerializableTransactionError = exports2.InvalidLegacyVError = exports2.FeeConflictError = exports2.InvalidAddressError = exports2.WebSocketRequestError = exports2.TimeoutError = exports2.RpcRequestError = exports2.HttpRequestError = exports2.FilterTypeNotSupportedError = exports2.UnknownNodeError = exports2.TransactionTypeNotSupportedError = exports2.TipAboveFeeCapError = exports2.NonceTooLowError = exports2.NonceTooHighError = exports2.NonceMaxValueError = exports2.IntrinsicGasTooLowError = exports2.IntrinsicGasTooHighError = exports2.InsufficientFundsError = exports2.FeeCapTooLowError = exports2.FeeCapTooHighError = exports2.ExecutionRevertedError = exports2.EstimateGasExecutionError = exports2.EnsAvatarUnsupportedNamespaceError = exports2.EnsAvatarInvalidNftUriError = exports2.EnsAvatarUriResolutionError = exports2.SizeOverflowError = exports2.OffsetOutOfBoundsError = exports2.InvalidHexValueError = void 0;
    exports2.toHex = exports2.stringToHex = exports2.numberToHex = exports2.bytesToHex = exports2.boolToHex = exports2.toBytes = exports2.stringToBytes = exports2.numberToBytes = exports2.hexToBytes = exports2.boolToBytes = exports2.assertTransactionLegacy = exports2.assertTransactionEIP2930 = exports2.assertTransactionEIP1559 = exports2.assertRequest = exports2.verifyTypedData = exports2.verifyMessage = exports2.toRlp = exports2.hexToRlp = exports2.bytesToRlp = exports2.signatureToHex = exports2.compactSignatureToHex = exports2.signatureToCompactSignature = exports2.recoverTypedDataAddress = exports2.recoverPublicKey = exports2.recoverMessageAddress = exports2.recoverAddress = exports2.hexToSignature = exports2.hexToCompactSignature = exports2.compactSignatureToSignature = exports2.hashTypedData = exports2.hashDomain = exports2.getTransactionType = exports2.getSerializedTransactionType = exports2.getCreateAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getAbiItem = exports2.rpcTransactionType = exports2.formatTransactionRequest = exports2.defineTransactionRequest = exports2.formatTransactionReceipt = exports2.defineTransactionReceipt = exports2.transactionType = exports2.formatTransaction = exports2.defineTransaction = exports2.encodeFunctionResult = exports2.encodeFunctionData = exports2.encodeEventTopics = exports2.encodeErrorResult = exports2.encodeDeployData = void 0;
    exports2.parseUnits = exports2.parseTransaction = exports2.parseGwei = exports2.parseEther = exports2.padHex = exports2.padBytes = exports2.pad = exports2.ripemd160 = exports2.sha256 = exports2.keccak256 = exports2.isHex = exports2.isHash = exports2.isBytes = exports2.isAddressEqual = exports2.isAddress = exports2.hashMessage = exports2.getFunctionSignature = exports2.getFunctionSelector = exports2.getEventSignature = exports2.getEventSelector = exports2.getContractError = exports2.getAddress = exports2.checksumAddress = exports2.fromRlp = exports2.hexToString = exports2.hexToNumber = exports2.hexToBool = exports2.hexToBigInt = exports2.fromHex = exports2.formatUnits = exports2.formatGwei = exports2.formatEther = exports2.encodePacked = exports2.getChainContractAddress = exports2.extractChain = exports2.defineChain = exports2.assertCurrentChain = exports2.concatHex = exports2.concatBytes = exports2.concat = exports2.offchainLookupSignature = exports2.offchainLookupAbiItem = exports2.offchainLookup = exports2.ccipFetch = exports2.fromBytes = exports2.bytesToString = exports2.bytesToNumber = exports2.bytesToBool = exports2.bytesToBigint = exports2.bytesToBigInt = void 0;
    exports2.getTypesForEIP712Domain = exports2.domainSeparator = exports2.validateTypedData = exports2.trim = exports2.stringify = exports2.sliceHex = exports2.sliceBytes = exports2.slice = exports2.size = exports2.serializeTransaction = exports2.serializeAccessList = void 0;
    var abitype_1 = require_cjs();
    Object.defineProperty(exports2, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_1.CircularReferenceError;
    } });
    Object.defineProperty(exports2, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports2, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports2, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports2, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports2, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports2, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidModifierError;
    } });
    Object.defineProperty(exports2, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidParameterError;
    } });
    Object.defineProperty(exports2, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports2, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports2, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports2, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports2, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_1.UnknownTypeError;
    } });
    Object.defineProperty(exports2, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports2, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports2, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports2, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports2, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var getContract_js_1 = require_getContract();
    Object.defineProperty(exports2, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_1 = require_createClient();
    Object.defineProperty(exports2, "createClient", { enumerable: true, get: function() {
      return createClient_js_1.createClient;
    } });
    var custom_js_1 = require_custom();
    Object.defineProperty(exports2, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require_fallback();
    Object.defineProperty(exports2, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require_http();
    Object.defineProperty(exports2, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = require_createPublicClient();
    Object.defineProperty(exports2, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require_createTestClient();
    Object.defineProperty(exports2, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports2, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_1 = require_test();
    Object.defineProperty(exports2, "testActions", { enumerable: true, get: function() {
      return test_js_1.testActions;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports2, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_1 = require_createTransport();
    Object.defineProperty(exports2, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_1.createTransport;
    } });
    var createWalletClient_js_1 = require_createWalletClient();
    Object.defineProperty(exports2, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require_webSocket();
    Object.defineProperty(exports2, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_1 = require_abis();
    Object.defineProperty(exports2, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_1.multicall3Abi;
    } });
    var address_js_1 = require_address2();
    Object.defineProperty(exports2, "zeroAddress", { enumerable: true, get: function() {
      return address_js_1.zeroAddress;
    } });
    var unit_js_1 = require_unit();
    Object.defineProperty(exports2, "etherUnits", { enumerable: true, get: function() {
      return unit_js_1.etherUnits;
    } });
    Object.defineProperty(exports2, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_1.gweiUnits;
    } });
    Object.defineProperty(exports2, "weiUnits", { enumerable: true, get: function() {
      return unit_js_1.weiUnits;
    } });
    var number_js_1 = require_number();
    Object.defineProperty(exports2, "maxInt8", { enumerable: true, get: function() {
      return number_js_1.maxInt8;
    } });
    Object.defineProperty(exports2, "maxInt16", { enumerable: true, get: function() {
      return number_js_1.maxInt16;
    } });
    Object.defineProperty(exports2, "maxInt24", { enumerable: true, get: function() {
      return number_js_1.maxInt24;
    } });
    Object.defineProperty(exports2, "maxInt32", { enumerable: true, get: function() {
      return number_js_1.maxInt32;
    } });
    Object.defineProperty(exports2, "maxInt40", { enumerable: true, get: function() {
      return number_js_1.maxInt40;
    } });
    Object.defineProperty(exports2, "maxInt48", { enumerable: true, get: function() {
      return number_js_1.maxInt48;
    } });
    Object.defineProperty(exports2, "maxInt56", { enumerable: true, get: function() {
      return number_js_1.maxInt56;
    } });
    Object.defineProperty(exports2, "maxInt64", { enumerable: true, get: function() {
      return number_js_1.maxInt64;
    } });
    Object.defineProperty(exports2, "maxInt72", { enumerable: true, get: function() {
      return number_js_1.maxInt72;
    } });
    Object.defineProperty(exports2, "maxInt80", { enumerable: true, get: function() {
      return number_js_1.maxInt80;
    } });
    Object.defineProperty(exports2, "maxInt88", { enumerable: true, get: function() {
      return number_js_1.maxInt88;
    } });
    Object.defineProperty(exports2, "maxInt96", { enumerable: true, get: function() {
      return number_js_1.maxInt96;
    } });
    Object.defineProperty(exports2, "maxInt104", { enumerable: true, get: function() {
      return number_js_1.maxInt104;
    } });
    Object.defineProperty(exports2, "maxInt112", { enumerable: true, get: function() {
      return number_js_1.maxInt112;
    } });
    Object.defineProperty(exports2, "maxInt120", { enumerable: true, get: function() {
      return number_js_1.maxInt120;
    } });
    Object.defineProperty(exports2, "maxInt128", { enumerable: true, get: function() {
      return number_js_1.maxInt128;
    } });
    Object.defineProperty(exports2, "maxInt136", { enumerable: true, get: function() {
      return number_js_1.maxInt136;
    } });
    Object.defineProperty(exports2, "maxInt144", { enumerable: true, get: function() {
      return number_js_1.maxInt144;
    } });
    Object.defineProperty(exports2, "maxInt152", { enumerable: true, get: function() {
      return number_js_1.maxInt152;
    } });
    Object.defineProperty(exports2, "maxInt160", { enumerable: true, get: function() {
      return number_js_1.maxInt160;
    } });
    Object.defineProperty(exports2, "maxInt168", { enumerable: true, get: function() {
      return number_js_1.maxInt168;
    } });
    Object.defineProperty(exports2, "maxInt176", { enumerable: true, get: function() {
      return number_js_1.maxInt176;
    } });
    Object.defineProperty(exports2, "maxInt184", { enumerable: true, get: function() {
      return number_js_1.maxInt184;
    } });
    Object.defineProperty(exports2, "maxInt192", { enumerable: true, get: function() {
      return number_js_1.maxInt192;
    } });
    Object.defineProperty(exports2, "maxInt200", { enumerable: true, get: function() {
      return number_js_1.maxInt200;
    } });
    Object.defineProperty(exports2, "maxInt208", { enumerable: true, get: function() {
      return number_js_1.maxInt208;
    } });
    Object.defineProperty(exports2, "maxInt216", { enumerable: true, get: function() {
      return number_js_1.maxInt216;
    } });
    Object.defineProperty(exports2, "maxInt224", { enumerable: true, get: function() {
      return number_js_1.maxInt224;
    } });
    Object.defineProperty(exports2, "maxInt232", { enumerable: true, get: function() {
      return number_js_1.maxInt232;
    } });
    Object.defineProperty(exports2, "maxInt240", { enumerable: true, get: function() {
      return number_js_1.maxInt240;
    } });
    Object.defineProperty(exports2, "maxInt248", { enumerable: true, get: function() {
      return number_js_1.maxInt248;
    } });
    Object.defineProperty(exports2, "maxInt256", { enumerable: true, get: function() {
      return number_js_1.maxInt256;
    } });
    Object.defineProperty(exports2, "maxUint8", { enumerable: true, get: function() {
      return number_js_1.maxUint8;
    } });
    Object.defineProperty(exports2, "maxUint16", { enumerable: true, get: function() {
      return number_js_1.maxUint16;
    } });
    Object.defineProperty(exports2, "maxUint24", { enumerable: true, get: function() {
      return number_js_1.maxUint24;
    } });
    Object.defineProperty(exports2, "maxUint32", { enumerable: true, get: function() {
      return number_js_1.maxUint32;
    } });
    Object.defineProperty(exports2, "maxUint40", { enumerable: true, get: function() {
      return number_js_1.maxUint40;
    } });
    Object.defineProperty(exports2, "maxUint48", { enumerable: true, get: function() {
      return number_js_1.maxUint48;
    } });
    Object.defineProperty(exports2, "maxUint56", { enumerable: true, get: function() {
      return number_js_1.maxUint56;
    } });
    Object.defineProperty(exports2, "maxUint64", { enumerable: true, get: function() {
      return number_js_1.maxUint64;
    } });
    Object.defineProperty(exports2, "maxUint72", { enumerable: true, get: function() {
      return number_js_1.maxUint72;
    } });
    Object.defineProperty(exports2, "maxUint80", { enumerable: true, get: function() {
      return number_js_1.maxUint80;
    } });
    Object.defineProperty(exports2, "maxUint88", { enumerable: true, get: function() {
      return number_js_1.maxUint88;
    } });
    Object.defineProperty(exports2, "maxUint96", { enumerable: true, get: function() {
      return number_js_1.maxUint96;
    } });
    Object.defineProperty(exports2, "maxUint104", { enumerable: true, get: function() {
      return number_js_1.maxUint104;
    } });
    Object.defineProperty(exports2, "maxUint112", { enumerable: true, get: function() {
      return number_js_1.maxUint112;
    } });
    Object.defineProperty(exports2, "maxUint120", { enumerable: true, get: function() {
      return number_js_1.maxUint120;
    } });
    Object.defineProperty(exports2, "maxUint128", { enumerable: true, get: function() {
      return number_js_1.maxUint128;
    } });
    Object.defineProperty(exports2, "maxUint136", { enumerable: true, get: function() {
      return number_js_1.maxUint136;
    } });
    Object.defineProperty(exports2, "maxUint144", { enumerable: true, get: function() {
      return number_js_1.maxUint144;
    } });
    Object.defineProperty(exports2, "maxUint152", { enumerable: true, get: function() {
      return number_js_1.maxUint152;
    } });
    Object.defineProperty(exports2, "maxUint160", { enumerable: true, get: function() {
      return number_js_1.maxUint160;
    } });
    Object.defineProperty(exports2, "maxUint168", { enumerable: true, get: function() {
      return number_js_1.maxUint168;
    } });
    Object.defineProperty(exports2, "maxUint176", { enumerable: true, get: function() {
      return number_js_1.maxUint176;
    } });
    Object.defineProperty(exports2, "maxUint184", { enumerable: true, get: function() {
      return number_js_1.maxUint184;
    } });
    Object.defineProperty(exports2, "maxUint192", { enumerable: true, get: function() {
      return number_js_1.maxUint192;
    } });
    Object.defineProperty(exports2, "maxUint200", { enumerable: true, get: function() {
      return number_js_1.maxUint200;
    } });
    Object.defineProperty(exports2, "maxUint208", { enumerable: true, get: function() {
      return number_js_1.maxUint208;
    } });
    Object.defineProperty(exports2, "maxUint216", { enumerable: true, get: function() {
      return number_js_1.maxUint216;
    } });
    Object.defineProperty(exports2, "maxUint224", { enumerable: true, get: function() {
      return number_js_1.maxUint224;
    } });
    Object.defineProperty(exports2, "maxUint232", { enumerable: true, get: function() {
      return number_js_1.maxUint232;
    } });
    Object.defineProperty(exports2, "maxUint240", { enumerable: true, get: function() {
      return number_js_1.maxUint240;
    } });
    Object.defineProperty(exports2, "maxUint248", { enumerable: true, get: function() {
      return number_js_1.maxUint248;
    } });
    Object.defineProperty(exports2, "maxUint256", { enumerable: true, get: function() {
      return number_js_1.maxUint256;
    } });
    Object.defineProperty(exports2, "minInt8", { enumerable: true, get: function() {
      return number_js_1.minInt8;
    } });
    Object.defineProperty(exports2, "minInt16", { enumerable: true, get: function() {
      return number_js_1.minInt16;
    } });
    Object.defineProperty(exports2, "minInt24", { enumerable: true, get: function() {
      return number_js_1.minInt24;
    } });
    Object.defineProperty(exports2, "minInt32", { enumerable: true, get: function() {
      return number_js_1.minInt32;
    } });
    Object.defineProperty(exports2, "minInt40", { enumerable: true, get: function() {
      return number_js_1.minInt40;
    } });
    Object.defineProperty(exports2, "minInt48", { enumerable: true, get: function() {
      return number_js_1.minInt48;
    } });
    Object.defineProperty(exports2, "minInt56", { enumerable: true, get: function() {
      return number_js_1.minInt56;
    } });
    Object.defineProperty(exports2, "minInt64", { enumerable: true, get: function() {
      return number_js_1.minInt64;
    } });
    Object.defineProperty(exports2, "minInt72", { enumerable: true, get: function() {
      return number_js_1.minInt72;
    } });
    Object.defineProperty(exports2, "minInt80", { enumerable: true, get: function() {
      return number_js_1.minInt80;
    } });
    Object.defineProperty(exports2, "minInt88", { enumerable: true, get: function() {
      return number_js_1.minInt88;
    } });
    Object.defineProperty(exports2, "minInt96", { enumerable: true, get: function() {
      return number_js_1.minInt96;
    } });
    Object.defineProperty(exports2, "minInt104", { enumerable: true, get: function() {
      return number_js_1.minInt104;
    } });
    Object.defineProperty(exports2, "minInt112", { enumerable: true, get: function() {
      return number_js_1.minInt112;
    } });
    Object.defineProperty(exports2, "minInt120", { enumerable: true, get: function() {
      return number_js_1.minInt120;
    } });
    Object.defineProperty(exports2, "minInt128", { enumerable: true, get: function() {
      return number_js_1.minInt128;
    } });
    Object.defineProperty(exports2, "minInt136", { enumerable: true, get: function() {
      return number_js_1.minInt136;
    } });
    Object.defineProperty(exports2, "minInt144", { enumerable: true, get: function() {
      return number_js_1.minInt144;
    } });
    Object.defineProperty(exports2, "minInt152", { enumerable: true, get: function() {
      return number_js_1.minInt152;
    } });
    Object.defineProperty(exports2, "minInt160", { enumerable: true, get: function() {
      return number_js_1.minInt160;
    } });
    Object.defineProperty(exports2, "minInt168", { enumerable: true, get: function() {
      return number_js_1.minInt168;
    } });
    Object.defineProperty(exports2, "minInt176", { enumerable: true, get: function() {
      return number_js_1.minInt176;
    } });
    Object.defineProperty(exports2, "minInt184", { enumerable: true, get: function() {
      return number_js_1.minInt184;
    } });
    Object.defineProperty(exports2, "minInt192", { enumerable: true, get: function() {
      return number_js_1.minInt192;
    } });
    Object.defineProperty(exports2, "minInt200", { enumerable: true, get: function() {
      return number_js_1.minInt200;
    } });
    Object.defineProperty(exports2, "minInt208", { enumerable: true, get: function() {
      return number_js_1.minInt208;
    } });
    Object.defineProperty(exports2, "minInt216", { enumerable: true, get: function() {
      return number_js_1.minInt216;
    } });
    Object.defineProperty(exports2, "minInt224", { enumerable: true, get: function() {
      return number_js_1.minInt224;
    } });
    Object.defineProperty(exports2, "minInt232", { enumerable: true, get: function() {
      return number_js_1.minInt232;
    } });
    Object.defineProperty(exports2, "minInt240", { enumerable: true, get: function() {
      return number_js_1.minInt240;
    } });
    Object.defineProperty(exports2, "minInt248", { enumerable: true, get: function() {
      return number_js_1.minInt248;
    } });
    Object.defineProperty(exports2, "minInt256", { enumerable: true, get: function() {
      return number_js_1.minInt256;
    } });
    var bytes_js_1 = require_bytes();
    Object.defineProperty(exports2, "zeroHash", { enumerable: true, get: function() {
      return bytes_js_1.zeroHash;
    } });
    var strings_js_1 = require_strings();
    Object.defineProperty(exports2, "presignMessagePrefix", { enumerable: true, get: function() {
      return strings_js_1.presignMessagePrefix;
    } });
    var abi_js_1 = require_abi();
    Object.defineProperty(exports2, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports2, "AbiDecodingDataSizeTooSmallError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeTooSmallError;
    } });
    Object.defineProperty(exports2, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports2, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports2, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports2, "AbiEncodingBytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingBytesSizeMismatchError;
    } });
    Object.defineProperty(exports2, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports2, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports2, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports2, "BytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_1.BytesSizeMismatchError;
    } });
    Object.defineProperty(exports2, "DecodeLogDataMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogDataMismatch;
    } });
    Object.defineProperty(exports2, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports2, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports2, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports2, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_1.InvalidArrayError;
    } });
    Object.defineProperty(exports2, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidDefinitionTypeError;
    } });
    Object.defineProperty(exports2, "UnsupportedPackedAbiType", { enumerable: true, get: function() {
      return abi_js_1.UnsupportedPackedAbiType;
    } });
    var base_js_1 = require_base();
    Object.defineProperty(exports2, "BaseError", { enumerable: true, get: function() {
      return base_js_1.BaseError;
    } });
    var block_js_1 = require_block();
    Object.defineProperty(exports2, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_1.BlockNotFoundError;
    } });
    var contract_js_1 = require_contract();
    Object.defineProperty(exports2, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_1.CallExecutionError;
    } });
    Object.defineProperty(exports2, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports2, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports2, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports2, "RawContractError", { enumerable: true, get: function() {
      return contract_js_1.RawContractError;
    } });
    var fee_js_1 = require_fee();
    Object.defineProperty(exports2, "BaseFeeScalarError", { enumerable: true, get: function() {
      return fee_js_1.BaseFeeScalarError;
    } });
    Object.defineProperty(exports2, "Eip1559FeesNotSupportedError", { enumerable: true, get: function() {
      return fee_js_1.Eip1559FeesNotSupportedError;
    } });
    Object.defineProperty(exports2, "MaxFeePerGasTooLowError", { enumerable: true, get: function() {
      return fee_js_1.MaxFeePerGasTooLowError;
    } });
    var rpc_js_1 = require_rpc();
    Object.defineProperty(exports2, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ChainDisconnectedError;
    } });
    Object.defineProperty(exports2, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InternalRpcError;
    } });
    Object.defineProperty(exports2, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidInputRpcError;
    } });
    Object.defineProperty(exports2, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports2, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports2, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_1.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports2, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_1.LimitExceededRpcError;
    } });
    Object.defineProperty(exports2, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports2, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports2, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ParseRpcError;
    } });
    Object.defineProperty(exports2, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports2, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderRpcError;
    } });
    Object.defineProperty(exports2, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports2, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports2, "RpcError", { enumerable: true, get: function() {
      return rpc_js_1.RpcError;
    } });
    Object.defineProperty(exports2, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_1.SwitchChainError;
    } });
    Object.defineProperty(exports2, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports2, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_1.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports2, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_1.UnknownRpcError;
    } });
    Object.defineProperty(exports2, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_1.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports2, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_1.UserRejectedRequestError;
    } });
    var chain_js_1 = require_chain();
    Object.defineProperty(exports2, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_1.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports2, "ChainMismatchError", { enumerable: true, get: function() {
      return chain_js_1.ChainMismatchError;
    } });
    Object.defineProperty(exports2, "ChainNotFoundError", { enumerable: true, get: function() {
      return chain_js_1.ChainNotFoundError;
    } });
    Object.defineProperty(exports2, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_1.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports2, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_1.InvalidChainIdError;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports2, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooLongError;
    } });
    Object.defineProperty(exports2, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooShortError;
    } });
    Object.defineProperty(exports2, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports2, "IntegerOutOfRangeError", { enumerable: true, get: function() {
      return encoding_js_1.IntegerOutOfRangeError;
    } });
    Object.defineProperty(exports2, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports2, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexValueError;
    } });
    Object.defineProperty(exports2, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_1.OffsetOutOfBoundsError;
    } });
    Object.defineProperty(exports2, "SizeOverflowError", { enumerable: true, get: function() {
      return encoding_js_1.SizeOverflowError;
    } });
    var ens_js_1 = require_ens();
    Object.defineProperty(exports2, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUriResolutionError;
    } });
    Object.defineProperty(exports2, "EnsAvatarInvalidNftUriError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarInvalidNftUriError;
    } });
    Object.defineProperty(exports2, "EnsAvatarUnsupportedNamespaceError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUnsupportedNamespaceError;
    } });
    var estimateGas_js_1 = require_estimateGas();
    Object.defineProperty(exports2, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_1.EstimateGasExecutionError;
    } });
    var node_js_1 = require_node();
    Object.defineProperty(exports2, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_1.ExecutionRevertedError;
    } });
    Object.defineProperty(exports2, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooHighError;
    } });
    Object.defineProperty(exports2, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooLowError;
    } });
    Object.defineProperty(exports2, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_1.InsufficientFundsError;
    } });
    Object.defineProperty(exports2, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports2, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports2, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_1.NonceMaxValueError;
    } });
    Object.defineProperty(exports2, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_1.NonceTooHighError;
    } });
    Object.defineProperty(exports2, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_1.NonceTooLowError;
    } });
    Object.defineProperty(exports2, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_1.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports2, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_1.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports2, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_1.UnknownNodeError;
    } });
    var log_js_1 = require_log();
    Object.defineProperty(exports2, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_1.FilterTypeNotSupportedError;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports2, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_1.HttpRequestError;
    } });
    Object.defineProperty(exports2, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_1.RpcRequestError;
    } });
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return request_js_1.TimeoutError;
    } });
    Object.defineProperty(exports2, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_1.WebSocketRequestError;
    } });
    var address_js_2 = require_address();
    Object.defineProperty(exports2, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports2, "FeeConflictError", { enumerable: true, get: function() {
      return transaction_js_1.FeeConflictError;
    } });
    Object.defineProperty(exports2, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidLegacyVError;
    } });
    Object.defineProperty(exports2, "InvalidSerializableTransactionError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializableTransactionError;
    } });
    Object.defineProperty(exports2, "InvalidSerializedTransactionError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializedTransactionError;
    } });
    Object.defineProperty(exports2, "InvalidSerializedTransactionTypeError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializedTransactionTypeError;
    } });
    Object.defineProperty(exports2, "InvalidStorageKeySizeError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidStorageKeySizeError;
    } });
    Object.defineProperty(exports2, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionExecutionError;
    } });
    Object.defineProperty(exports2, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionNotFoundError;
    } });
    Object.defineProperty(exports2, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports2, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_1.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports2, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_1.SizeExceedsPaddingSizeError;
    } });
    Object.defineProperty(exports2, "SliceOffsetOutOfBoundsError", { enumerable: true, get: function() {
      return data_js_1.SliceOffsetOutOfBoundsError;
    } });
    var transport_js_1 = require_transport();
    Object.defineProperty(exports2, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_1.UrlRequiredError;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports2, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    var block_js_2 = require_block2();
    Object.defineProperty(exports2, "defineBlock", { enumerable: true, get: function() {
      return block_js_2.defineBlock;
    } });
    Object.defineProperty(exports2, "formatBlock", { enumerable: true, get: function() {
      return block_js_2.formatBlock;
    } });
    var log_js_2 = require_log2();
    Object.defineProperty(exports2, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports2, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require_decodeDeployData();
    Object.defineProperty(exports2, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports2, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports2, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports2, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports2, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports2, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports2, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports2, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports2, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports2, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports2, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_2 = require_transaction2();
    Object.defineProperty(exports2, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_2.defineTransaction;
    } });
    Object.defineProperty(exports2, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_2.formatTransaction;
    } });
    Object.defineProperty(exports2, "transactionType", { enumerable: true, get: function() {
      return transaction_js_2.transactionType;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports2, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    Object.defineProperty(exports2, "formatTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.formatTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports2, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports2, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    Object.defineProperty(exports2, "rpcTransactionType", { enumerable: true, get: function() {
      return transactionRequest_js_1.rpcTransactionType;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports2, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports2, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports2, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports2, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports2, "hashDomain", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashDomain;
    } });
    Object.defineProperty(exports2, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var compactSignatureToSignature_js_1 = require_compactSignatureToSignature();
    Object.defineProperty(exports2, "compactSignatureToSignature", { enumerable: true, get: function() {
      return compactSignatureToSignature_js_1.compactSignatureToSignature;
    } });
    var hexToCompactSignature_js_1 = require_hexToCompactSignature();
    Object.defineProperty(exports2, "hexToCompactSignature", { enumerable: true, get: function() {
      return hexToCompactSignature_js_1.hexToCompactSignature;
    } });
    var hexToSignature_js_1 = require_hexToSignature();
    Object.defineProperty(exports2, "hexToSignature", { enumerable: true, get: function() {
      return hexToSignature_js_1.hexToSignature;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports2, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports2, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var signatureToCompactSignature_js_1 = require_signatureToCompactSignature();
    Object.defineProperty(exports2, "signatureToCompactSignature", { enumerable: true, get: function() {
      return signatureToCompactSignature_js_1.signatureToCompactSignature;
    } });
    var compactSignatureToHex_js_1 = require_compactSignatureToHex();
    Object.defineProperty(exports2, "compactSignatureToHex", { enumerable: true, get: function() {
      return compactSignatureToHex_js_1.compactSignatureToHex;
    } });
    var signatureToHex_js_1 = require_signatureToHex();
    Object.defineProperty(exports2, "signatureToHex", { enumerable: true, get: function() {
      return signatureToHex_js_1.signatureToHex;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports2, "bytesToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.bytesToRlp;
    } });
    Object.defineProperty(exports2, "hexToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.hexToRlp;
    } });
    Object.defineProperty(exports2, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports2, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports2, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports2, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports2, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports2, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports2, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports2, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports2, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    Object.defineProperty(exports2, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports2, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports2, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports2, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports2, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    Object.defineProperty(exports2, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports2, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports2, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports2, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports2, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports2, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports2, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports2, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports2, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports2, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports2, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports2, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports2, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    Object.defineProperty(exports2, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_1.assertCurrentChain;
    } });
    var defineChain_js_1 = require_defineChain();
    Object.defineProperty(exports2, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require_extractChain();
    Object.defineProperty(exports2, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    Object.defineProperty(exports2, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_1.getChainContractAddress;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports2, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports2, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports2, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports2, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports2, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports2, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports2, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports2, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports2, "checksumAddress", { enumerable: true, get: function() {
      return getAddress_js_1.checksumAddress;
    } });
    Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports2, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports2, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getEventSignature_js_1 = require_getEventSignature();
    Object.defineProperty(exports2, "getEventSignature", { enumerable: true, get: function() {
      return getEventSignature_js_1.getEventSignature;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports2, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    Object.defineProperty(exports2, "getFunctionSignature", { enumerable: true, get: function() {
      return getFunctionSignature_js_1.getFunctionSignature;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports2, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports2, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports2, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var sha256_js_1 = require_sha2562();
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require_ripemd1602();
    Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports2, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports2, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports2, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports2, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports2, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports2, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports2, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports2, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports2, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports2, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports2, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    Object.defineProperty(exports2, "domainSeparator", { enumerable: true, get: function() {
      return typedData_js_1.domainSeparator;
    } });
    Object.defineProperty(exports2, "getTypesForEIP712Domain", { enumerable: true, get: function() {
      return typedData_js_1.getTypesForEIP712Domain;
    } });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/validationHelpers.js
var require_validationHelpers = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/validationHelpers.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.functionStatus = exports2.unixPath = exports2.file = exports2.url = exports2.dockerImage = exports2.settingsInput = exports2.framework = exports2.envVarValue = exports2.envVarName = exports2.slug = exports2.description = exports2.ipAddress = exports2.hostname = exports2.email = exports2.privateGatewayName = exports2.functionName = exports2.siteName = exports2.projectName = exports2.name = exports2.pinName = exports2.patName = exports2.ethAddress = exports2.walletAddress = exports2.ens = exports2.id = exports2.positiveNumber = exports2.number = exports2.string = exports2.boolean = exports2.enumeration = exports2.anyRecord = exports2.anyArray = exports2.any = void 0;
    var viem_1 = require_cjs3();
    var zod = __importStar(require_lib());
    var ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
    var NAME_REGEX = /^(?=[a-zA-Z0-9._\-~ ]*$)([^_.\-~ ].*[^_.\-~ ]|[^_.\-~ ])$/;
    var IDENTIFIER_REGEX = /^[a-zA-Z0-9-]+$/;
    var SLUG_REGEX = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    var ENV_VAR_NAME_REGEX = /^[A-Za-z][A-Za-z0-9_]*$/;
    var HOSTNAME_REGEX = /^(?!-)[a-z0-9-]{1,63}(?<!-)(\.(?!-)[a-z0-9-]{1,63}(?<!-))+$/i;
    var IP_ADDRESS_REGEX = /^(localhost|((\d{1,3}\.){3}\d{1,3}))(:\d+)?$/;
    var ENS_REGEX = /^[a-z0-9.-]*\.eth$/i;
    var PIN_REGEX = /^[A-Za-z0-9._\- ]+$/;
    var UNIX_PATH_REGEX = /^(\/?(\.\/)?[\w.-]+\/?)*$/;
    var EMAIL_REGEX = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    exports2.any = zod.any();
    exports2.anyArray = zod.array(exports2.any);
    exports2.anyRecord = zod.record(exports2.any);
    exports2.enumeration = zod.enum;
    exports2.boolean = zod.boolean();
    exports2.string = zod.string();
    exports2.number = zod.number();
    exports2.positiveNumber = exports2.number.positive();
    exports2.id = exports2.string;
    exports2.ens = exports2.string.refine((val) => {
      return ENS_REGEX.test(val);
    }, (ens) => {
      return { message: `${ens} is an invalid ENS name` };
    });
    exports2.walletAddress = exports2.string.refine((address) => {
      return (0, viem_1.isAddress)(address);
    }, (address) => {
      return { message: `${address} is an invalid wallet address` };
    });
    exports2.ethAddress = exports2.string.regex(ETH_ADDRESS_REGEX, { message: `Invalid Ethereum address` });
    exports2.patName = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(50, { message: "Maximum of 50 characters" });
    exports2.pinName = exports2.string.min(1, { message: "Minimum of 1 characters" }).max(30, { message: "Maximum of 30 characters" }).regex(PIN_REGEX, { message: `Pin name only accept A-Z a-z 0-9 . _ -. ` }).refine((pinName) => !!pinName, { message: "Pin name must not be blank" });
    exports2.name = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(30, { message: "Maximum of 30 characters" }).regex(NAME_REGEX, { message: `Name allows only letters, digits and not starting/ending spaces, '.', '-', and '~'` });
    exports2.projectName = exports2.string.min(1, { message: "Minimum of 1 characters" }).max(30, { message: "Maximum of 30 characters" }).refine((projectName) => {
      if (projectName) {
        return NAME_REGEX.test(projectName);
      }
    }, { message: `Name allows only letters, digits and not starting/ending spaces, '.', '-', and '~'` }).refine((porjectName) => !!porjectName, { message: "Project name must not be blank" });
    exports2.siteName = exports2.string.min(1, { message: "Minimum of 1 characters" }).max(30, { message: "Maximum of 30 characters" }).regex(IDENTIFIER_REGEX, { message: `Site Name allows only letters, digits and '-'` }).refine((siteName) => {
      return !!siteName;
    }, { message: "Site name must not be blank" });
    exports2.functionName = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(30, { message: "Maximum of 30 characters" }).regex(IDENTIFIER_REGEX, { message: `Function name allows only letters, digits and '-'` }).refine((functionName) => {
      return !!functionName;
    }, { message: "Function name must not be blank" });
    exports2.privateGatewayName = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(30, { message: "Maximum of 30 characters" }).regex(NAME_REGEX, { message: `Private Gateway Name allows only letters, digits and not starting/ending spaces, '.', '-', and '~'` });
    exports2.email = exports2.string.regex(EMAIL_REGEX, { message: "Invalid email" });
    exports2.hostname = exports2.string.min(2, { message: "Minimum of 2 characters" }).max(80, { message: "Maximum of 80 characters" }).refine((hostName) => !!hostName, { message: "domain name must not be blank" }).refine((hostname) => HOSTNAME_REGEX.test(hostname), (hostname) => ({ message: `${hostname} is an invalid domain` }));
    exports2.ipAddress = exports2.string.refine((ipAddress) => IP_ADDRESS_REGEX.test(ipAddress), (ipAddress) => ({ message: `${ipAddress} isn't a valid IP address or a localhost with port number` }));
    exports2.description = exports2.string.max(500, { message: "Maximum of 500 characters" });
    exports2.slug = exports2.string.max(63, { message: "Maximum of 63 characters" }).regex(SLUG_REGEX, { message: `Slug allows only lowercase letters, digits and '-'` });
    exports2.envVarName = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(150, { message: "Maximum of 150 characters" }).regex(ENV_VAR_NAME_REGEX, { message: "Only letters and numbers allowed" });
    exports2.envVarValue = exports2.string.min(1, { message: "Minimum of 1 character" }).max(250, { message: "Maximum of 250 characters" }).refine((value) => !!value, { message: `Value can't be null` });
    exports2.framework = exports2.string.max(15, { message: "Maximum of 15 characters" });
    exports2.settingsInput = exports2.string.max(30, { message: "Maximum of 30 characters " });
    exports2.dockerImage = exports2.string.min(3, { message: "Minimum of 3 characters" }).max(50, { message: "Maximum of 50 characters" }).refine((dockerImage) => {
      return !!dockerImage;
    }, { message: "Docker image must not be blank" });
    exports2.url = exports2.string.url({ message: "Invalid url" });
    exports2.file = zod.any();
    exports2.unixPath = exports2.string.regex(UNIX_PATH_REGEX, { message: `This is not a valid file path` });
    exports2.functionStatus = zod.enum(["ACTIVE", "INACTIVE"]);
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/auth.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateTwoFactorSecretKeySchema = exports2.verifyTwoFactorSecretKey = exports2.updateApplicationSchemaNext = exports2.updateApplicationSchema = exports2.deleteApplicationSchema = exports2.createApplicationSchemaNext = exports2.createApplicationSchema = exports2.applicationNameAvailablitySchema = exports2.updateProjectSchema = exports2.createProjectSchema = exports2.updateMembershipSchema = exports2.addUserToProjectSchema = exports2.updateUserSchema = exports2.emailAvailabilitySchema = exports2.usernameAvailabilitySchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.usernameAvailabilitySchema = zod.object({
      where: zod.object({
        username: validationHelpers_1.name
      })
    });
    exports2.emailAvailabilitySchema = zod.object({
      where: zod.object({
        email: validationHelpers_1.email
      })
    });
    exports2.updateUserSchema = zod.object({
      data: zod.object({
        avatar: validationHelpers_1.file.optional().nullable(),
        email: validationHelpers_1.email.optional().nullable(),
        firstName: validationHelpers_1.string.optional().nullable(),
        lastName: validationHelpers_1.string.optional().nullable(),
        username: validationHelpers_1.name.optional().nullable(),
        walletAddress: validationHelpers_1.walletAddress.optional().nullable(),
        walletChain: validationHelpers_1.string.optional().nullable()
      })
    });
    exports2.addUserToProjectSchema = zod.object({
      where: zod.object({
        projectId: validationHelpers_1.id
      }),
      data: zod.object({
        email: validationHelpers_1.email,
        role: zod.enum(["OWNER", "MEMBER"])
      })
    });
    exports2.updateMembershipSchema = zod.object({
      where: zod.union([
        zod.object({
          id: validationHelpers_1.id
        }),
        zod.object({ userId: validationHelpers_1.id })
      ]),
      data: zod.object({
        permissionGroupId: validationHelpers_1.id
      })
    });
    exports2.createProjectSchema = zod.object({
      data: zod.object({
        name: validationHelpers_1.projectName,
        planId: validationHelpers_1.id.optional()
      })
    });
    exports2.updateProjectSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        name: validationHelpers_1.projectName.optional(),
        avatar: validationHelpers_1.file.optional(),
        backupStorageOnArweave: validationHelpers_1.boolean.optional(),
        backupStorageOnFilecoin: validationHelpers_1.boolean.optional(),
        allowAccessFromOfacCountries: validationHelpers_1.boolean.optional(),
        billingPlanId: validationHelpers_1.id.optional()
      })
    });
    exports2.applicationNameAvailablitySchema = zod.object({
      where: zod.object({
        name: validationHelpers_1.name
      })
    });
    exports2.createApplicationSchema = zod.object({
      data: zod.object({
        name: validationHelpers_1.name,
        // Note: validation can be messing retroactive support
        // for the whiteLabelDomains support, so set as optional temporarily
        whitelistDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress)).optional(),
        // Warning: deprecated, used only for providing support for older clients
        whiteLabelDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress)).optional()
      })
    });
    exports2.createApplicationSchemaNext = zod.object({
      data: zod.object({
        name: validationHelpers_1.name,
        whitelistDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress))
      })
    });
    exports2.deleteApplicationSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
        //
      })
    });
    exports2.updateApplicationSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        name: validationHelpers_1.name.optional(),
        // Note: validation can be messing retroactive support
        // for the whiteLabelDomains support, so set as optional temporarily
        whitelistDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress)).optional(),
        // Warning: deprecated, used only for providing support for older clients
        whiteLabelDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress)).optional()
      })
    });
    exports2.updateApplicationSchemaNext = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        name: validationHelpers_1.name.optional(),
        whitelistDomains: zod.array(validationHelpers_1.hostname.or(validationHelpers_1.ipAddress))
      })
    });
    exports2.verifyTwoFactorSecretKey = zod.object({
      where: zod.object({
        secretKeyId: validationHelpers_1.id
      }),
      data: zod.object({
        token: validationHelpers_1.string.length(6)
      })
    });
    exports2.updateTwoFactorSecretKeySchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        key: validationHelpers_1.boolean.optional(),
        isActive: validationHelpers_1.boolean.optional()
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/domains.js
var require_domains = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/domains.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.domainAvailabilitySchema = exports2.deleteZone = exports2.createZoneForSiteSchema = exports2.createDnsConfigSchema = exports2.createDomainSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.createDomainSchema = zod.object({
      where: zod.object({ zoneId: validationHelpers_1.id }),
      data: zod.object({ hostname: validationHelpers_1.hostname })
    });
    exports2.createDnsConfigSchema = zod.object({
      where: zod.object({
        domainId: validationHelpers_1.id,
        siteId: validationHelpers_1.id
      }),
      data: zod.object({
        name: zod.enum(["_dnslink"])
      })
    });
    exports2.createZoneForSiteSchema = zod.object({
      where: zod.object({ siteId: validationHelpers_1.id })
    });
    exports2.deleteZone = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.domainAvailabilitySchema = zod.object({
      where: zod.object({
        hostname: validationHelpers_1.hostname
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ipns.js
var require_ipns = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ipns.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipnsRecordSchema = exports2.deleteIpnsRecordSchema = exports2.publishIpnsRecordSchema = exports2.resolveIpnsNameSchema = exports2.publishSignedIpnsNameSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.publishSignedIpnsNameSchema = zod.object({
      data: zod.object({ input: validationHelpers_1.string, key: validationHelpers_1.string })
    });
    exports2.resolveIpnsNameSchema = zod.object({
      where: zod.object({ name: validationHelpers_1.string })
    });
    exports2.publishIpnsRecordSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id }),
      data: zod.object({ hash: validationHelpers_1.string })
    });
    exports2.deleteIpnsRecordSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.ipnsRecordSchema = zod.object({
      where: zod.object({ name: validationHelpers_1.string })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ipfs.js
var require_ipfs = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ipfs.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deleteFolderSchema = exports2.updateFolderSchema = exports2.createFolderSchema = exports2.completePinUploadSchema = exports2.presignPinUrlSchema = exports2.deletePinSchema = exports2.updatePinSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.updatePinSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.string
      }),
      data: zod.object({
        filename: validationHelpers_1.name.optional(),
        parentFolderId: validationHelpers_1.id.optional(),
        moveToRoot: zod.literal(true).optional()
      })
    });
    exports2.deletePinSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.string
      })
    });
    exports2.presignPinUrlSchema = zod.object({
      data: zod.object({
        basename: validationHelpers_1.string,
        format: zod.enum(["car", "raw"]),
        cid: validationHelpers_1.string.optional()
      })
    });
    exports2.completePinUploadSchema = zod.object({
      where: zod.object({
        key: validationHelpers_1.string
      })
    });
    exports2.createFolderSchema = zod.object({
      where: zod.object({ parentFolderId: validationHelpers_1.id.optional() }),
      data: zod.object({ name: validationHelpers_1.name })
    });
    exports2.updateFolderSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id }),
      data: zod.object({ name: validationHelpers_1.name })
    });
    exports2.deleteFolderSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/site.js
var require_site = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/site.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.secretAvailabilitySchema = exports2.siteNameAvailabilitySchema = exports2.slugAvailabilitySchema = exports2.deleteSecretSchema = exports2.updateSecretSchema = exports2.createSecretSchema = exports2.createCustomIpfsDeploymentSchema = exports2.updateSiteSchema = exports2.createSiteSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.createSiteSchema = zod.object({
      data: zod.object({
        name: validationHelpers_1.siteName,
        sourceProvider: zod.enum(["GITHUB", "GITLAB", "BITBUCKET"]).optional(),
        sourceRepositoryId: zod.string().optional(),
        sourceRepositoryOwner: zod.string().optional(),
        sourceRepositoryName: zod.string().optional(),
        sourceBranch: zod.string().optional(),
        enablePreviews: zod.boolean().optional(),
        baseDirectory: validationHelpers_1.unixPath.optional(),
        buildCommand: zod.string().optional(),
        distDirectory: validationHelpers_1.unixPath.optional(),
        dockerImage: validationHelpers_1.dockerImage.optional(),
        cpuLimit: zod.string().optional(),
        memoryLimit: zod.string().optional(),
        githubInstallationId: zod.number().positive().optional(),
        gitIntegrationId: validationHelpers_1.id.optional(),
        buildDurationLimitSeconds: zod.number().positive().optional(),
        templateId: validationHelpers_1.id.optional(),
        frameworkId: validationHelpers_1.id.optional()
      })
    });
    exports2.updateSiteSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        name: validationHelpers_1.siteName.optional(),
        slug: validationHelpers_1.slug.optional(),
        sourceProvider: zod.enum(["GITHUB", "GITLAB", "BITBUCKET"]).optional(),
        sourceRepositoryId: zod.string().optional(),
        sourceRepositoryOwner: zod.string().optional(),
        sourceRepositoryName: zod.string().optional(),
        sourceBranch: zod.string().optional(),
        enablePreviews: zod.boolean().optional(),
        baseDirectory: validationHelpers_1.unixPath.optional(),
        buildCommand: zod.string().optional(),
        distDirectory: validationHelpers_1.unixPath.optional(),
        dockerImage: validationHelpers_1.dockerImage.optional(),
        cpuLimit: zod.string().optional(),
        memoryLimit: zod.string().optional(),
        githubInstallationId: zod.number().positive().optional(),
        buildDurationLimitSeconds: zod.number().positive().optional(),
        avatar: validationHelpers_1.file.optional(),
        frameworkId: validationHelpers_1.id.nullish()
      })
    });
    exports2.createCustomIpfsDeploymentSchema = zod.object({
      data: zod.object({
        siteId: validationHelpers_1.id,
        cid: validationHelpers_1.string
      })
    });
    exports2.createSecretSchema = zod.object({
      data: zod.object({ groupId: validationHelpers_1.id, key: validationHelpers_1.string, value: validationHelpers_1.string, visibility: zod.enum(["PUBLIC", "ENCRYPTED"]) })
    });
    exports2.updateSecretSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id }),
      data: zod.object({ value: validationHelpers_1.string, visibility: zod.enum(["PUBLIC", "ENCRYPTED"]) })
    });
    exports2.deleteSecretSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.slugAvailabilitySchema = zod.object({
      where: zod.object({ slug: validationHelpers_1.slug })
    });
    exports2.siteNameAvailabilitySchema = zod.object({
      where: zod.object({
        name: validationHelpers_1.siteName
      })
    });
    exports2.secretAvailabilitySchema = zod.object({
      where: zod.object({
        siteId: validationHelpers_1.id,
        key: validationHelpers_1.envVarName
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/privateGateway.js
var require_privateGateway = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/privateGateway.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.privateGatewayNameAvailabilitySchema = exports2.privateGatewaySchema = exports2.deletePrivateGatewaySchema = exports2.createPrivateGatewaySchema = exports2.updatePrivateGatewaySchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.updatePrivateGatewaySchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id }),
      data: zod.object({ name: validationHelpers_1.name.optional(), blockOfacCountries: validationHelpers_1.boolean.optional() })
    });
    exports2.createPrivateGatewaySchema = zod.object({
      where: zod.object({ zoneId: validationHelpers_1.id }),
      data: zod.object({ name: validationHelpers_1.name })
    });
    exports2.deletePrivateGatewaySchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.privateGatewaySchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.privateGatewayNameAvailabilitySchema = zod.object({
      where: zod.object({
        name: validationHelpers_1.name
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ens.js
var require_ens2 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/ens.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensNameAvailabilitySchema = exports2.verifyEnsRecordSchema = exports2.deleteEnsRecordSchema = exports2.createEnsRecordSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.createEnsRecordSchema = zod.object({
      where: zod.object({ siteId: validationHelpers_1.id, ipnsRecordId: validationHelpers_1.id }),
      data: zod.object({ name: validationHelpers_1.ens })
    });
    exports2.deleteEnsRecordSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.verifyEnsRecordSchema = zod.object({
      where: zod.object({ id: validationHelpers_1.id })
    });
    exports2.ensNameAvailabilitySchema = zod.object({
      where: zod.object({
        name: validationHelpers_1.ens,
        siteId: validationHelpers_1.string.optional()
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/template.js
var require_template = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/template.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.templateNameAvailabilitySchema = exports2.deleteTemplateSchema = exports2.updateTemplateSchema = exports2.createTemplateSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.createTemplateSchema = zod.object({
      data: zod.object({
        name: validationHelpers_1.name,
        description: validationHelpers_1.description,
        siteId: validationHelpers_1.id,
        templateCategoryId: validationHelpers_1.id,
        banner: validationHelpers_1.file
      })
    });
    exports2.updateTemplateSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      }),
      data: zod.object({
        name: validationHelpers_1.name.nullish().or(zod.literal("")),
        description: validationHelpers_1.description.nullish(),
        templateCategoryId: validationHelpers_1.id.nullish(),
        banner: validationHelpers_1.file.optional()
      })
    });
    exports2.deleteTemplateSchema = zod.object({
      where: zod.object({
        id: validationHelpers_1.id
      })
    });
    exports2.templateNameAvailabilitySchema = zod.object({
      where: zod.object({
        name: validationHelpers_1.name
      })
    });
  }
});

// node_modules/.pnpm/zod-validation-error@3.4.0_zod@3.22.4/node_modules/zod-validation-error/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/zod-validation-error@3.4.0_zod@3.22.4/node_modules/zod-validation-error/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var lib_exports = {};
    __export2(lib_exports, {
      ValidationError: () => ValidationError,
      createMessageBuilder: () => createMessageBuilder,
      errorMap: () => errorMap,
      fromError: () => fromError,
      fromZodError: () => fromZodError,
      fromZodIssue: () => fromZodIssue,
      isValidationError: () => isValidationError,
      isValidationErrorLike: () => isValidationErrorLike,
      isZodErrorLike: () => isZodErrorLike,
      toValidationError: () => toValidationError
    });
    module2.exports = __toCommonJS2(lib_exports);
    function isZodErrorLike(err) {
      return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
    }
    var ValidationError = class extends Error {
      name;
      details;
      constructor(message, options) {
        super(message, options);
        this.name = "ZodValidationError";
        this.details = getIssuesFromErrorOptions(options);
      }
      toString() {
        return this.message;
      }
    };
    function getIssuesFromErrorOptions(options) {
      if (options) {
        const cause = options.cause;
        if (isZodErrorLike(cause)) {
          return cause.issues;
        }
      }
      return [];
    }
    function isValidationError(err) {
      return err instanceof ValidationError;
    }
    function isValidationErrorLike(err) {
      return err instanceof Error && err.name === "ZodValidationError";
    }
    var zod2 = __toESM2(require_lib());
    var zod = __toESM2(require_lib());
    function isNonEmptyArray(value) {
      return value.length !== 0;
    }
    var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
    function joinPath5(path3) {
      if (path3.length === 1) {
        return path3[0].toString();
      }
      return path3.reduce((acc, item) => {
        if (typeof item === "number") {
          return acc + "[" + item.toString() + "]";
        }
        if (item.includes('"')) {
          return acc + '["' + escapeQuotes(item) + '"]';
        }
        if (!identifierRegex.test(item)) {
          return acc + '["' + item + '"]';
        }
        const separator = acc.length === 0 ? "" : ".";
        return acc + separator + item;
      }, "");
    }
    function escapeQuotes(str) {
      return str.replace(/"/g, '\\"');
    }
    var ISSUE_SEPARATOR = "; ";
    var MAX_ISSUES_IN_MESSAGE = 99;
    var PREFIX = "Validation error";
    var PREFIX_SEPARATOR = ": ";
    var UNION_SEPARATOR = ", or ";
    function createMessageBuilder(props = {}) {
      const {
        issueSeparator = ISSUE_SEPARATOR,
        unionSeparator = UNION_SEPARATOR,
        prefixSeparator = PREFIX_SEPARATOR,
        prefix = PREFIX,
        includePath = true,
        maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE
      } = props;
      return (issues) => {
        const message = issues.slice(0, maxIssuesInMessage).map(
          (issue) => getMessageFromZodIssue({
            issue,
            issueSeparator,
            unionSeparator,
            includePath
          })
        ).join(issueSeparator);
        return prefixMessage(message, prefix, prefixSeparator);
      };
    }
    function getMessageFromZodIssue(props) {
      const { issue, issueSeparator, unionSeparator, includePath } = props;
      if (issue.code === zod.ZodIssueCode.invalid_union) {
        return issue.unionErrors.reduce((acc, zodError) => {
          const newIssues = zodError.issues.map(
            (issue2) => getMessageFromZodIssue({
              issue: issue2,
              issueSeparator,
              unionSeparator,
              includePath
            })
          ).join(issueSeparator);
          if (!acc.includes(newIssues)) {
            acc.push(newIssues);
          }
          return acc;
        }, []).join(unionSeparator);
      }
      if (issue.code === zod.ZodIssueCode.invalid_arguments) {
        return [
          issue.message,
          ...issue.argumentsError.issues.map(
            (issue2) => getMessageFromZodIssue({
              issue: issue2,
              issueSeparator,
              unionSeparator,
              includePath
            })
          )
        ].join(issueSeparator);
      }
      if (issue.code === zod.ZodIssueCode.invalid_return_type) {
        return [
          issue.message,
          ...issue.returnTypeError.issues.map(
            (issue2) => getMessageFromZodIssue({
              issue: issue2,
              issueSeparator,
              unionSeparator,
              includePath
            })
          )
        ].join(issueSeparator);
      }
      if (includePath && isNonEmptyArray(issue.path)) {
        if (issue.path.length === 1) {
          const identifier = issue.path[0];
          if (typeof identifier === "number") {
            return `${issue.message} at index ${identifier}`;
          }
        }
        return `${issue.message} at "${joinPath5(issue.path)}"`;
      }
      return issue.message;
    }
    function prefixMessage(message, prefix, prefixSeparator) {
      if (prefix !== null) {
        if (message.length > 0) {
          return [prefix, message].join(prefixSeparator);
        }
        return prefix;
      }
      if (message.length > 0) {
        return message;
      }
      return PREFIX;
    }
    function fromZodIssue(issue, options = {}) {
      const messageBuilder = createMessageBuilderFromOptions(options);
      const message = messageBuilder([issue]);
      return new ValidationError(message, { cause: new zod2.ZodError([issue]) });
    }
    function createMessageBuilderFromOptions(options) {
      if ("messageBuilder" in options) {
        return options.messageBuilder;
      }
      return createMessageBuilder(options);
    }
    var errorMap = (issue, ctx) => {
      const error = fromZodIssue({
        ...issue,
        // fallback to the default error message
        // when issue does not have a message
        message: issue.message ?? ctx.defaultError
      });
      return {
        message: error.message
      };
    };
    function fromZodError(zodError, options = {}) {
      if (!isZodErrorLike(zodError)) {
        throw new TypeError(
          `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
        );
      }
      return fromZodErrorWithoutRuntimeCheck(zodError, options);
    }
    function fromZodErrorWithoutRuntimeCheck(zodError, options = {}) {
      const zodIssues = zodError.errors;
      let message;
      if (isNonEmptyArray(zodIssues)) {
        const messageBuilder = createMessageBuilderFromOptions2(options);
        message = messageBuilder(zodIssues);
      } else {
        message = zodError.message;
      }
      return new ValidationError(message, { cause: zodError });
    }
    function createMessageBuilderFromOptions2(options) {
      if ("messageBuilder" in options) {
        return options.messageBuilder;
      }
      return createMessageBuilder(options);
    }
    var toValidationError = (options = {}) => (err) => {
      if (isZodErrorLike(err)) {
        return fromZodErrorWithoutRuntimeCheck(err, options);
      }
      if (err instanceof Error) {
        return new ValidationError(err.message, { cause: err });
      }
      return new ValidationError("Unknown error");
    };
    function fromError(err, options = {}) {
      return toValidationError(options)(err);
    }
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/configuration/validateConfigurationWithResult.js
var require_validateConfigurationWithResult = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/configuration/validateConfigurationWithResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fleekRootConfigSchema = exports2.fleekSiteConfigSchema = exports2.validateConfigurationWithResult = void 0;
    var zod_1 = require_lib();
    var zod_validation_error_1 = require_dist();
    var validationHelpers_1 = require_validationHelpers();
    var validateConfigurationWithResult2 = async ({ configuration }) => {
      return exports2.fleekRootConfigSchema.parseAsync(configuration).catch((error) => Promise.reject(new Error((0, zod_validation_error_1.fromZodError)(error).toString())));
    };
    exports2.validateConfigurationWithResult = validateConfigurationWithResult2;
    exports2.fleekSiteConfigSchema = zod_1.z.object({
      slug: validationHelpers_1.slug,
      distDir: validationHelpers_1.string,
      buildCommand: validationHelpers_1.string.optional()
    }).strict();
    exports2.fleekRootConfigSchema = zod_1.z.object({
      sites: zod_1.z.array(exports2.fleekSiteConfigSchema).length(1)
    }).strict();
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isHostnameValid.js
var require_isHostnameValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isHostnameValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHostnameValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isHostnameValid4 = ({ hostname }) => validationHelpers_1.hostname.safeParse(hostname).success && validationHelpers_1.url.safeParse(`https://${hostname}`).success;
    exports2.isHostnameValid = isHostnameValid4;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isPrivateGatewayNameValid.js
var require_isPrivateGatewayNameValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isPrivateGatewayNameValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPrivateGatewayNameValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isPrivateGatewayNameValid2 = ({ name }) => validationHelpers_1.privateGatewayName.safeParse(name).success;
    exports2.isPrivateGatewayNameValid = isPrivateGatewayNameValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isProjectNameValid.js
var require_isProjectNameValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isProjectNameValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isProjectNameValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isProjectNameValid2 = ({ name }) => validationHelpers_1.name.safeParse(name).success;
    exports2.isProjectNameValid = isProjectNameValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionNameValid.js
var require_isFunctionNameValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionNameValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunctionNameValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isFunctionNameValid3 = ({ name }) => validationHelpers_1.functionName.safeParse(name).success;
    exports2.isFunctionNameValid = isFunctionNameValid3;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionSlugValid.js
var require_isFunctionSlugValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionSlugValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunctionSlugValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isFunctionSlugValid2 = ({ slug }) => validationHelpers_1.slug.safeParse(slug).success;
    exports2.isFunctionSlugValid = isFunctionSlugValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionStatusValid.js
var require_isFunctionStatusValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionStatusValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunctionStatusValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isFunctionStatusValid2 = ({ status }) => validationHelpers_1.functionStatus.safeParse(status).success;
    exports2.isFunctionStatusValid = isFunctionStatusValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isSiteNameValid.js
var require_isSiteNameValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isSiteNameValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSiteNameValid = void 0;
    var validationHelpers_1 = require_validationHelpers();
    var isSiteNameValid2 = ({ name }) => validationHelpers_1.siteName.safeParse(name).success;
    exports2.isSiteNameValid = isSiteNameValid2;
  }
});

// node_modules/.pnpm/@adraffy+ens-normalize@1.11.0/node_modules/@adraffy/ens-normalize/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/.pnpm/@adraffy+ens-normalize@1.11.0/node_modules/@adraffy/ens-normalize/dist/index.cjs"(exports2) {
    "use strict";
    var COMPRESSED$1 = "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28";
    var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    var NSM_MAX = 4;
    function decode_arithmetic(bytes) {
      let pos = 0;
      function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
      }
      let symbol_count = u16();
      let total = 1;
      let acc = [0, 1];
      for (let i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
      }
      let skip = u16();
      let pos_payload = pos;
      pos += skip;
      let read_width = 0;
      let read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      const N = 31;
      const FULL = 2 ** N;
      const HALF = FULL >>> 1;
      const QRTR = HALF >> 1;
      const MASK = FULL - 1;
      let register = 0;
      for (let i = 0; i < N; i++) register = register << 1 | read_bit();
      let symbols = [];
      let low = 0;
      let range = FULL;
      while (true) {
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while (end - start > 1) {
          let mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0) break;
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a = a << 1 & MASK;
          b = b << 1 & MASK | 1;
        }
        while (a & ~b & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a = a << 1 ^ HALF;
          b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
      }
      let offset = symbol_count - 4;
      return symbols.map((x) => {
        switch (x - offset) {
          case 3:
            return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 2:
            return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 1:
            return offset + bytes[pos_payload++];
          default:
            return x - 1;
        }
      });
    }
    function read_payload(v) {
      let pos = 0;
      return () => v[pos++];
    }
    function read_compressed_payload(s) {
      return read_payload(decode_arithmetic(unsafe_atob(s)));
    }
    function unsafe_atob(s) {
      let lookup = [];
      [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
      let n = s.length;
      let ret = new Uint8Array(6 * n >> 3);
      for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
        carry = carry << 6 | lookup[s.charCodeAt(i)];
        width += 6;
        if (width >= 8) {
          ret[pos++] = carry >> (width -= 8);
        }
      }
      return ret;
    }
    function signed(i) {
      return i & 1 ? ~i >> 1 : i >> 1;
    }
    function read_deltas(n, next) {
      let v = Array(n);
      for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
      return v;
    }
    function read_sorted(next, prev = 0) {
      let ret = [];
      while (true) {
        let x = next();
        let n = next();
        if (!n) break;
        prev += x;
        for (let i = 0; i < n; i++) {
          ret.push(prev + i);
        }
        prev += n + 1;
      }
      return ret;
    }
    function read_sorted_arrays(next) {
      return read_array_while(() => {
        let v = read_sorted(next);
        if (v.length) return v;
      });
    }
    function read_mapped(next) {
      let ret = [];
      while (true) {
        let w = next();
        if (w == 0) break;
        ret.push(read_linear_table(w, next));
      }
      while (true) {
        let w = next() - 1;
        if (w < 0) break;
        ret.push(read_replacement_table(w, next));
      }
      return ret.flat();
    }
    function read_array_while(next) {
      let v = [];
      while (true) {
        let x = next(v.length);
        if (!x) break;
        v.push(x);
      }
      return v;
    }
    function read_transposed(n, w, next) {
      let m = Array(n).fill().map(() => []);
      for (let i = 0; i < w; i++) {
        read_deltas(n, next).forEach((x, j) => m[j].push(x));
      }
      return m;
    }
    function read_linear_table(w, next) {
      let dx = 1 + next();
      let dy = next();
      let vN = read_array_while(next);
      let m = read_transposed(vN.length, 1 + w, next);
      return m.flatMap((v, i) => {
        let [x, ...ys] = v;
        return Array(vN[i]).fill().map((_, j) => {
          let j_dy = j * dy;
          return [x + j * dx, ys.map((y) => y + j_dy)];
        });
      });
    }
    function read_replacement_table(w, next) {
      let n = 1 + next();
      let m = read_transposed(n, 1 + w, next);
      return m.map((v) => [v[0], v.slice(1)]);
    }
    function read_trie(next) {
      let ret = [];
      let sorted = read_sorted(next);
      expand(decode([]), []);
      return ret;
      function decode(Q) {
        let S = next();
        let B = read_array_while(() => {
          let cps = read_sorted(next).map((i) => sorted[i]);
          if (cps.length) return decode(cps);
        });
        return { S, B, Q };
      }
      function expand({ S, B }, cps, saved) {
        if (S & 4 && saved === cps[cps.length - 1]) return;
        if (S & 2) saved = cps[cps.length - 1];
        if (S & 1) ret.push(cps);
        for (let br of B) {
          for (let cp of br.Q) {
            expand(br, [...cps, cp], saved);
          }
        }
      }
    }
    function hex_cp(cp) {
      return cp.toString(16).toUpperCase().padStart(2, "0");
    }
    function quote_cp(cp) {
      return `{${hex_cp(cp)}}`;
    }
    function explode_cp(s) {
      let cps = [];
      for (let pos = 0, len = s.length; pos < len; ) {
        let cp = s.codePointAt(pos);
        pos += cp < 65536 ? 1 : 2;
        cps.push(cp);
      }
      return cps;
    }
    function str_from_cps(cps) {
      const chunk = 4096;
      let len = cps.length;
      if (len < chunk) return String.fromCodePoint(...cps);
      let buf = [];
      for (let i = 0; i < len; ) {
        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
      }
      return buf.join("");
    }
    function compare_arrays(a, b) {
      let n = a.length;
      let c = n - b.length;
      for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
      return c;
    }
    function array_replace(v, a, b) {
      let prev = 0;
      while (true) {
        let next = v.indexOf(a, prev);
        if (next < 0) break;
        v[next] = b;
        prev = next + 1;
      }
    }
    var COMPRESSED = "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA";
    var S0 = 44032;
    var L0 = 4352;
    var V0 = 4449;
    var T0 = 4519;
    var L_COUNT = 19;
    var V_COUNT = 21;
    var T_COUNT = 28;
    var N_COUNT = V_COUNT * T_COUNT;
    var S_COUNT = L_COUNT * N_COUNT;
    var S1 = S0 + S_COUNT;
    var L1 = L0 + L_COUNT;
    var V1 = V0 + V_COUNT;
    var T1 = T0 + T_COUNT;
    function unpack_cc(packed) {
      return packed >> 24 & 255;
    }
    function unpack_cp(packed) {
      return packed & 16777215;
    }
    var SHIFTED_RANK;
    var EXCLUSIONS;
    var DECOMP;
    var RECOMP;
    function init$1() {
      let r = read_compressed_payload(COMPRESSED);
      SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
      EXCLUSIONS = new Set(read_sorted(r));
      DECOMP = /* @__PURE__ */ new Map();
      RECOMP = /* @__PURE__ */ new Map();
      for (let [cp, cps] of read_mapped(r)) {
        if (!EXCLUSIONS.has(cp) && cps.length == 2) {
          let [a, b] = cps;
          let bucket = RECOMP.get(a);
          if (!bucket) {
            bucket = /* @__PURE__ */ new Map();
            RECOMP.set(a, bucket);
          }
          bucket.set(b, cp);
        }
        DECOMP.set(cp, cps.reverse());
      }
    }
    function is_hangul(cp) {
      return cp >= S0 && cp < S1;
    }
    function compose_pair(a, b) {
      if (a >= L0 && a < L1 && b >= V0 && b < V1) {
        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
      } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
        return a + (b - T0);
      } else {
        let recomp = RECOMP.get(a);
        if (recomp) {
          recomp = recomp.get(b);
          if (recomp) {
            return recomp;
          }
        }
        return -1;
      }
    }
    function decomposed(cps) {
      if (!SHIFTED_RANK) init$1();
      let ret = [];
      let buf = [];
      let check_order = false;
      function add(cp) {
        let cc = SHIFTED_RANK.get(cp);
        if (cc) {
          check_order = true;
          cp |= cc;
        }
        ret.push(cp);
      }
      for (let cp of cps) {
        while (true) {
          if (cp < 128) {
            ret.push(cp);
          } else if (is_hangul(cp)) {
            let s_index = cp - S0;
            let l_index = s_index / N_COUNT | 0;
            let v_index = s_index % N_COUNT / T_COUNT | 0;
            let t_index = s_index % T_COUNT;
            add(L0 + l_index);
            add(V0 + v_index);
            if (t_index > 0) add(T0 + t_index);
          } else {
            let mapped = DECOMP.get(cp);
            if (mapped) {
              buf.push(...mapped);
            } else {
              add(cp);
            }
          }
          if (!buf.length) break;
          cp = buf.pop();
        }
      }
      if (check_order && ret.length > 1) {
        let prev_cc = unpack_cc(ret[0]);
        for (let i = 1; i < ret.length; i++) {
          let cc = unpack_cc(ret[i]);
          if (cc == 0 || prev_cc <= cc) {
            prev_cc = cc;
            continue;
          }
          let j = i - 1;
          while (true) {
            let tmp = ret[j + 1];
            ret[j + 1] = ret[j];
            ret[j] = tmp;
            if (!j) break;
            prev_cc = unpack_cc(ret[--j]);
            if (prev_cc <= cc) break;
          }
          prev_cc = unpack_cc(ret[i]);
        }
      }
      return ret;
    }
    function composed_from_decomposed(v) {
      let ret = [];
      let stack = [];
      let prev_cp = -1;
      let prev_cc = 0;
      for (let packed of v) {
        let cc = unpack_cc(packed);
        let cp = unpack_cp(packed);
        if (prev_cp == -1) {
          if (cc == 0) {
            prev_cp = cp;
          } else {
            ret.push(cp);
          }
        } else if (prev_cc > 0 && prev_cc >= cc) {
          if (cc == 0) {
            ret.push(prev_cp, ...stack);
            stack.length = 0;
            prev_cp = cp;
          } else {
            stack.push(cp);
          }
          prev_cc = cc;
        } else {
          let composed = compose_pair(prev_cp, cp);
          if (composed >= 0) {
            prev_cp = composed;
          } else if (prev_cc == 0 && cc == 0) {
            ret.push(prev_cp);
            prev_cp = cp;
          } else {
            stack.push(cp);
            prev_cc = cc;
          }
        }
      }
      if (prev_cp >= 0) {
        ret.push(prev_cp, ...stack);
      }
      return ret;
    }
    function nfd(cps) {
      return decomposed(cps).map(unpack_cp);
    }
    function nfc(cps) {
      return composed_from_decomposed(decomposed(cps));
    }
    var HYPHEN = 45;
    var STOP = 46;
    var STOP_CH = ".";
    var FE0F = 65039;
    var UNIQUE_PH = 1;
    var Array_from = (x) => Array.from(x);
    function group_has_cp(g, cp) {
      return g.P.has(cp) || g.Q.has(cp);
    }
    var Emoji = class extends Array {
      get is_emoji() {
        return true;
      }
      // free tagging system
    };
    var MAPPED;
    var IGNORED;
    var CM;
    var NSM;
    var ESCAPE;
    var NFC_CHECK;
    var GROUPS;
    var WHOLE_VALID;
    var WHOLE_MAP;
    var VALID;
    var EMOJI_LIST;
    var EMOJI_ROOT;
    function init2() {
      if (MAPPED) return;
      let r = read_compressed_payload(COMPRESSED$1);
      const read_sorted_array = () => read_sorted(r);
      const read_sorted_set = () => new Set(read_sorted_array());
      const set_add_many = (set, v) => v.forEach((x) => set.add(x));
      MAPPED = new Map(read_mapped(r));
      IGNORED = read_sorted_set();
      CM = read_sorted_array();
      NSM = new Set(read_sorted_array().map((i) => CM[i]));
      CM = new Set(CM);
      ESCAPE = read_sorted_set();
      NFC_CHECK = read_sorted_set();
      let chunks = read_sorted_arrays(r);
      let unrestricted = r();
      const read_chunked = () => {
        let set = /* @__PURE__ */ new Set();
        read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
        set_add_many(set, read_sorted_array());
        return set;
      };
      GROUPS = read_array_while((i) => {
        let N = read_array_while(r).map((x) => x + 96);
        if (N.length) {
          let R = i >= unrestricted;
          N[0] -= 32;
          N = str_from_cps(N);
          if (R) N = `Restricted[${N}]`;
          let P = read_chunked();
          let Q = read_chunked();
          let M = !r();
          return { N, P, Q, M, R };
        }
      });
      WHOLE_VALID = read_sorted_set();
      WHOLE_MAP = /* @__PURE__ */ new Map();
      let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b);
      wholes.forEach((cp, i) => {
        let d = r();
        let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
        w.V.push(cp);
        if (!WHOLE_VALID.has(cp)) {
          WHOLE_MAP.set(cp, w);
        }
      });
      for (let { V, M } of new Set(WHOLE_MAP.values())) {
        let recs = [];
        for (let cp of V) {
          let gs = GROUPS.filter((g) => group_has_cp(g, cp));
          let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
          if (!rec) {
            rec = { G: /* @__PURE__ */ new Set(), V: [] };
            recs.push(rec);
          }
          rec.V.push(cp);
          set_add_many(rec.G, gs);
        }
        let union = recs.flatMap((x) => Array_from(x.G));
        for (let { G, V: V2 } of recs) {
          let complement = new Set(union.filter((g) => !G.has(g)));
          for (let cp of V2) {
            M.set(cp, complement);
          }
        }
      }
      VALID = /* @__PURE__ */ new Set();
      let multi = /* @__PURE__ */ new Set();
      const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
      for (let g of GROUPS) {
        for (let cp of g.P) add_to_union(cp);
        for (let cp of g.Q) add_to_union(cp);
      }
      for (let cp of VALID) {
        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
          WHOLE_MAP.set(cp, UNIQUE_PH);
        }
      }
      set_add_many(VALID, nfd(VALID));
      EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
      EMOJI_ROOT = /* @__PURE__ */ new Map();
      for (let cps of EMOJI_LIST) {
        let prev = [EMOJI_ROOT];
        for (let cp of cps) {
          let next = prev.map((node) => {
            let child = node.get(cp);
            if (!child) {
              child = /* @__PURE__ */ new Map();
              node.set(cp, child);
            }
            return child;
          });
          if (cp === FE0F) {
            prev.push(...next);
          } else {
            prev = next;
          }
        }
        for (let x of prev) {
          x.V = cps;
        }
      }
    }
    function quoted_cp(cp) {
      return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
    }
    function bidi_qq(s) {
      return `"${s}"\u200E`;
    }
    function check_label_extension(cps) {
      if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
        throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
      }
    }
    function check_leading_underscore(cps) {
      const UNDERSCORE = 95;
      for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
        if (cps[--i] !== UNDERSCORE) {
          throw new Error("underscore allowed only at start");
        }
      }
    }
    function check_fenced(cps) {
      let cp = cps[0];
      let prev = FENCED.get(cp);
      if (prev) throw error_placement(`leading ${prev}`);
      let n = cps.length;
      let last = -1;
      for (let i = 1; i < n; i++) {
        cp = cps[i];
        let match = FENCED.get(cp);
        if (match) {
          if (last == i) throw error_placement(`${prev} + ${match}`);
          last = i + 1;
          prev = match;
        }
      }
      if (last == n) throw error_placement(`trailing ${prev}`);
    }
    function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
      let buf = [];
      if (is_combining_mark(cps[0])) buf.push("\u25CC");
      if (cps.length > max) {
        max >>= 1;
        cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
      }
      let prev = 0;
      let n = cps.length;
      for (let i = 0; i < n; i++) {
        let cp = cps[i];
        if (should_escape(cp)) {
          buf.push(str_from_cps(cps.slice(prev, i)));
          buf.push(quoter(cp));
          prev = i + 1;
        }
      }
      buf.push(str_from_cps(cps.slice(prev, n)));
      return buf.join("");
    }
    function is_combining_mark(cp, only_nsm) {
      init2();
      return only_nsm ? NSM.has(cp) : CM.has(cp);
    }
    function should_escape(cp) {
      init2();
      return ESCAPE.has(cp);
    }
    function ens_emoji() {
      init2();
      return EMOJI_LIST.map((x) => x.slice());
    }
    function ens_normalize_fragment(frag, decompose) {
      init2();
      let nf = decompose ? nfd : nfc;
      return frag.split(STOP_CH).map((label) => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);
    }
    function ens_normalize(name) {
      return flatten(split(name, nfc, filter_fe0f));
    }
    function ens_beautify(name) {
      let labels = split(name, nfc, (x) => x);
      for (let { type, output: output2, error } of labels) {
        if (error) break;
        if (type !== "Greek") array_replace(output2, 958, 926);
      }
      return flatten(labels);
    }
    function ens_split(name, preserve_emoji) {
      return split(name, nfc, preserve_emoji ? (x) => x.slice() : filter_fe0f);
    }
    function split(name, nf, ef) {
      if (!name) return [];
      init2();
      let offset = 0;
      return name.split(STOP_CH).map((label) => {
        let input = explode_cp(label);
        let info = {
          input,
          offset
          // codepoint, not substring!
        };
        offset += input.length + 1;
        try {
          let tokens = info.tokens = tokens_from_str(input, nf, ef);
          let token_count = tokens.length;
          let type;
          if (!token_count) {
            throw new Error(`empty label`);
          }
          let norm = info.output = tokens.flat();
          check_leading_underscore(norm);
          let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
          if (!emoji && norm.every((cp) => cp < 128)) {
            check_label_extension(norm);
            type = "ASCII";
          } else {
            let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
            if (!chars.length) {
              type = "Emoji";
            } else {
              if (CM.has(norm[0])) throw error_placement("leading combining mark");
              for (let i = 1; i < token_count; i++) {
                let cps = tokens[i];
                if (!cps.is_emoji && CM.has(cps[0])) {
                  throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
                }
              }
              check_fenced(norm);
              let unique = Array_from(new Set(chars));
              let [g] = determine_group(unique);
              check_group(g, chars);
              check_whole(g, unique);
              type = g.N;
            }
          }
          info.type = type;
        } catch (err) {
          info.error = err;
        }
        return info;
      });
    }
    function check_whole(group, unique) {
      let maker;
      let shared = [];
      for (let cp of unique) {
        let whole = WHOLE_MAP.get(cp);
        if (whole === UNIQUE_PH) return;
        if (whole) {
          let set = whole.M.get(cp);
          maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
          if (!maker.length) return;
        } else {
          shared.push(cp);
        }
      }
      if (maker) {
        for (let g of maker) {
          if (shared.every((cp) => group_has_cp(g, cp))) {
            throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
          }
        }
      }
    }
    function determine_group(unique) {
      let groups = GROUPS;
      for (let cp of unique) {
        let gs = groups.filter((g) => group_has_cp(g, cp));
        if (!gs.length) {
          if (!GROUPS.some((g) => group_has_cp(g, cp))) {
            throw error_disallowed(cp);
          } else {
            throw error_group_member(groups[0], cp);
          }
        }
        groups = gs;
        if (gs.length == 1) break;
      }
      return groups;
    }
    function flatten(split2) {
      return split2.map(({ input, error, output: output2 }) => {
        if (error) {
          let msg = error.message;
          throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
        }
        return str_from_cps(output2);
      }).join(STOP_CH);
    }
    function error_disallowed(cp) {
      return new Error(`disallowed character: ${quoted_cp(cp)}`);
    }
    function error_group_member(g, cp) {
      let quoted = quoted_cp(cp);
      let gg = GROUPS.find((g2) => g2.P.has(cp));
      if (gg) {
        quoted = `${gg.N} ${quoted}`;
      }
      return new Error(`illegal mixture: ${g.N} + ${quoted}`);
    }
    function error_placement(where) {
      return new Error(`illegal placement: ${where}`);
    }
    function check_group(g, cps) {
      for (let cp of cps) {
        if (!group_has_cp(g, cp)) {
          throw error_group_member(g, cp);
        }
      }
      if (g.M) {
        let decomposed2 = nfd(cps);
        for (let i = 1, e = decomposed2.length; i < e; i++) {
          if (NSM.has(decomposed2[i])) {
            let j = i + 1;
            for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
              for (let k = i; k < j; k++) {
                if (decomposed2[k] == cp) {
                  throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
                }
              }
            }
            if (j - i > NSM_MAX) {
              throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
            }
            i = j;
          }
        }
      }
    }
    function tokens_from_str(input, nf, ef) {
      let ret = [];
      let chars = [];
      input = input.slice().reverse();
      while (input.length) {
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
          if (chars.length) {
            ret.push(nf(chars));
            chars = [];
          }
          ret.push(ef(emoji));
        } else {
          let cp = input.pop();
          if (VALID.has(cp)) {
            chars.push(cp);
          } else {
            let cps = MAPPED.get(cp);
            if (cps) {
              chars.push(...cps);
            } else if (!IGNORED.has(cp)) {
              throw error_disallowed(cp);
            }
          }
        }
      }
      if (chars.length) {
        ret.push(nf(chars));
      }
      return ret;
    }
    function filter_fe0f(cps) {
      return cps.filter((cp) => cp != FE0F);
    }
    function consume_emoji_reversed(cps, eaten) {
      let node = EMOJI_ROOT;
      let emoji;
      let pos = cps.length;
      while (pos) {
        node = node.get(cps[--pos]);
        if (!node) break;
        let { V } = node;
        if (V) {
          emoji = V;
          if (eaten) eaten.push(...cps.slice(pos).reverse());
          cps.length = pos;
        }
      }
      return emoji;
    }
    var TY_VALID = "valid";
    var TY_MAPPED = "mapped";
    var TY_IGNORED = "ignored";
    var TY_DISALLOWED = "disallowed";
    var TY_EMOJI = "emoji";
    var TY_NFC = "nfc";
    var TY_STOP = "stop";
    function ens_tokenize(name, {
      nf = true
      // collapse unnormalized runs into a single token
    } = {}) {
      init2();
      let input = explode_cp(name).reverse();
      let eaten = [];
      let tokens = [];
      while (input.length) {
        let emoji = consume_emoji_reversed(input, eaten);
        if (emoji) {
          tokens.push({
            type: TY_EMOJI,
            emoji: emoji.slice(),
            // copy emoji
            input: eaten,
            cps: filter_fe0f(emoji)
          });
          eaten = [];
        } else {
          let cp = input.pop();
          if (cp == STOP) {
            tokens.push({ type: TY_STOP, cp });
          } else if (VALID.has(cp)) {
            tokens.push({ type: TY_VALID, cps: [cp] });
          } else if (IGNORED.has(cp)) {
            tokens.push({ type: TY_IGNORED, cp });
          } else {
            let cps = MAPPED.get(cp);
            if (cps) {
              tokens.push({ type: TY_MAPPED, cp, cps: cps.slice() });
            } else {
              tokens.push({ type: TY_DISALLOWED, cp });
            }
          }
        }
      }
      if (nf) {
        for (let i = 0, start = -1; i < tokens.length; i++) {
          let token = tokens[i];
          if (is_valid_or_mapped(token.type)) {
            if (requires_check(token.cps)) {
              let end = i + 1;
              for (let pos = end; pos < tokens.length; pos++) {
                let { type, cps: cps2 } = tokens[pos];
                if (is_valid_or_mapped(type)) {
                  if (!requires_check(cps2)) break;
                  end = pos + 1;
                } else if (type !== TY_IGNORED) {
                  break;
                }
              }
              if (start < 0) start = i;
              let slice = tokens.slice(start, end);
              let cps0 = slice.flatMap((x) => is_valid_or_mapped(x.type) ? x.cps : []);
              let cps = nfc(cps0);
              if (compare_arrays(cps, cps0)) {
                tokens.splice(start, end - start, {
                  type: TY_NFC,
                  input: cps0,
                  // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
                  cps,
                  tokens0: collapse_valid_tokens(slice),
                  tokens: ens_tokenize(str_from_cps(cps), { nf: false })
                });
                i = start;
              } else {
                i = end - 1;
              }
              start = -1;
            } else {
              start = i;
            }
          } else if (token.type !== TY_IGNORED) {
            start = -1;
          }
        }
      }
      return collapse_valid_tokens(tokens);
    }
    function is_valid_or_mapped(type) {
      return type == TY_VALID || type == TY_MAPPED;
    }
    function requires_check(cps) {
      return cps.some((cp) => NFC_CHECK.has(cp));
    }
    function collapse_valid_tokens(tokens) {
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type == TY_VALID) {
          let j = i + 1;
          while (j < tokens.length && tokens[j].type == TY_VALID) j++;
          tokens.splice(i, j - i, { type: TY_VALID, cps: tokens.slice(i, j).flatMap((x) => x.cps) });
        }
      }
      return tokens;
    }
    exports2.ens_beautify = ens_beautify;
    exports2.ens_emoji = ens_emoji;
    exports2.ens_normalize = ens_normalize;
    exports2.ens_normalize_fragment = ens_normalize_fragment;
    exports2.ens_split = ens_split;
    exports2.ens_tokenize = ens_tokenize;
    exports2.is_combining_mark = is_combining_mark;
    exports2.nfc = nfc;
    exports2.nfd = nfd;
    exports2.safe_str_from_cps = safe_str_from_cps;
    exports2.should_escape = should_escape;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isEnsValid.js
var require_isEnsValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isEnsValid.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnsValid = void 0;
    var ens_normalize_1 = require_dist2();
    var zod = __importStar(require_lib());
    var isEnsValid2 = ({ name }) => zod.string().refine((val) => {
      try {
        return Boolean((0, ens_normalize_1.ens_normalize)(val));
      } catch (e) {
        return false;
      }
    }).safeParse(name).success;
    exports2.isEnsValid = isEnsValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isEmailValid.js
var require_isEmailValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isEmailValid.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmailValid = void 0;
    var zod = __importStar(require_lib());
    var isEmailValid = ({ email }) => zod.string().email().safeParse(email).success;
    exports2.isEmailValid = isEmailValid;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isPhoneNumberValid.js
var require_isPhoneNumberValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isPhoneNumberValid.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPhoneNumberValid = void 0;
    var zod = __importStar(require_lib());
    var isPhoneNumberValid = ({ number }) => zod.string().regex(/^\+\d{10,15}$/).safeParse(number).success;
    exports2.isPhoneNumberValid = isPhoneNumberValid;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/billing.js
var require_billing = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/billing.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBillingCycleUsageSchema = exports2.updateBillingPlanSchema = exports2.createBillingPlanSchema = void 0;
    var zod = __importStar(require_lib());
    exports2.createBillingPlanSchema = zod.object({
      data: zod.object({
        name: zod.string(),
        version: zod.number().positive(),
        isActive: zod.boolean(),
        price: zod.number().positive(),
        billingPartnerId: zod.string().optional(),
        isPublicPlan: zod.boolean(),
        planLevel: zod.enum(["FREE", "BASIC", "PRO", "ENTERPRISE"]),
        description: zod.string()
      })
    });
    exports2.updateBillingPlanSchema = zod.object({
      where: zod.object({
        id: zod.string()
      }),
      data: zod.object({
        isActive: zod.boolean().optional(),
        price: zod.number().positive().optional()
      })
    });
    exports2.createBillingCycleUsageSchema = zod.object({
      data: zod.object({
        billingCycleId: zod.string(),
        billingPlanOverageRuleId: zod.string(),
        amount: zod.number().positive()
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/salesContactRequest.js
var require_salesContactRequest = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/services/salesContactRequest.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSalesContactRequestSchema = void 0;
    var zod = __importStar(require_lib());
    var validationHelpers_1 = require_validationHelpers();
    exports2.createSalesContactRequestSchema = zod.object({
      data: zod.object({
        email: validationHelpers_1.email,
        description: zod.string().min(10, { message: "Minimum of 10 characters" }).max(1e3, { message: "Maximum of 1000 characters" })
      })
    });
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionPathValid.js
var require_isFunctionPathValid = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/inputs/isFunctionPathValid.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunctionPathValid = exports2.isValidFolder = exports2.validExtension = void 0;
    var fs18 = __importStar(require("fs"));
    var path_1 = __importDefault(require("path"));
    exports2.validExtension = /* @__PURE__ */ new Set([".js", ".mjs", ".cjs", ".ts", ".jsx", ".tsx", ".wasm"]);
    var isValidFolder3 = async (path3) => {
      try {
        if (fs18.lstatSync(path3).isDirectory()) {
          return true;
        }
        return false;
      } catch (err) {
        return false;
      }
    };
    exports2.isValidFolder = isValidFolder3;
    var isFunctionPathValid2 = async ({ fileOrFolderPath }) => {
      return fs18.existsSync(fileOrFolderPath) && (exports2.validExtension.has(path_1.default.extname(fileOrFolderPath)) || await (0, exports2.isValidFolder)(fileOrFolderPath));
    };
    exports2.isFunctionPathValid = isFunctionPathValid2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-validation@2.4.0_typescript@4.9.3/node_modules/@fleek-platform/utils-validation/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidFolder = exports2.isFunctionPathValid = exports2.createBillingCycleUsageSchema = exports2.updateBillingPlanSchema = exports2.createBillingPlanSchema = exports2.isFunctionStatusValid = exports2.isFunctionSlugValid = exports2.isFunctionNameValid = void 0;
    __exportStar(require_auth(), exports2);
    __exportStar(require_domains(), exports2);
    __exportStar(require_ipns(), exports2);
    __exportStar(require_ipfs(), exports2);
    __exportStar(require_site(), exports2);
    __exportStar(require_domains(), exports2);
    __exportStar(require_privateGateway(), exports2);
    __exportStar(require_ens2(), exports2);
    __exportStar(require_template(), exports2);
    __exportStar(require_validateConfigurationWithResult(), exports2);
    __exportStar(require_isHostnameValid(), exports2);
    __exportStar(require_isPrivateGatewayNameValid(), exports2);
    __exportStar(require_isProjectNameValid(), exports2);
    var isFunctionNameValid_1 = require_isFunctionNameValid();
    Object.defineProperty(exports2, "isFunctionNameValid", { enumerable: true, get: function() {
      return isFunctionNameValid_1.isFunctionNameValid;
    } });
    var isFunctionSlugValid_1 = require_isFunctionSlugValid();
    Object.defineProperty(exports2, "isFunctionSlugValid", { enumerable: true, get: function() {
      return isFunctionSlugValid_1.isFunctionSlugValid;
    } });
    var isFunctionStatusValid_1 = require_isFunctionStatusValid();
    Object.defineProperty(exports2, "isFunctionStatusValid", { enumerable: true, get: function() {
      return isFunctionStatusValid_1.isFunctionStatusValid;
    } });
    __exportStar(require_isSiteNameValid(), exports2);
    __exportStar(require_isEnsValid(), exports2);
    __exportStar(require_validationHelpers(), exports2);
    __exportStar(require_isEmailValid(), exports2);
    __exportStar(require_isPhoneNumberValid(), exports2);
    var billing_1 = require_billing();
    Object.defineProperty(exports2, "createBillingPlanSchema", { enumerable: true, get: function() {
      return billing_1.createBillingPlanSchema;
    } });
    Object.defineProperty(exports2, "updateBillingPlanSchema", { enumerable: true, get: function() {
      return billing_1.updateBillingPlanSchema;
    } });
    Object.defineProperty(exports2, "createBillingCycleUsageSchema", { enumerable: true, get: function() {
      return billing_1.createBillingCycleUsageSchema;
    } });
    __exportStar(require_salesContactRequest(), exports2);
    var isFunctionPathValid_1 = require_isFunctionPathValid();
    Object.defineProperty(exports2, "isFunctionPathValid", { enumerable: true, get: function() {
      return isFunctionPathValid_1.isFunctionPathValid;
    } });
    Object.defineProperty(exports2, "isValidFolder", { enumerable: true, get: function() {
      return isFunctionPathValid_1.isValidFolder;
    } });
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekError.js
var require_FleekError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekError = void 0;
    var FleekError = class extends Error {
      // eslint-disable-next-line fleek-custom/valid-argument-types
      constructor(data) {
        super();
        this.data = data;
      }
      get message() {
        return this.toString();
      }
    };
    exports2.FleekError = FleekError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/BunnyPullZoneNotFoundError.js
var require_BunnyPullZoneNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/BunnyPullZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BunnyPullZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var BunnyPullZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "BunnyPullZoneNotFoundError";
        this.toString = () => `PullZone with name ${this.data.name} was not found on BunnyCDN.`;
      }
    };
    exports2.BunnyPullZoneNotFoundError = BunnyPullZoneNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainNotFoundError.js
var require_DomainNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundError";
        this.toString = () => {
          if (this.data.domain.hostname) {
            return `Domain ${this.data.domain.hostname} was not found.`;
          }
          return "Domain was not found.";
        };
      }
    };
    exports2.DomainNotFoundError = DomainNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainsNotFoundError.js
var require_DomainsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "DomainsNotFoundError";
        this.toString = () => "No domains found.";
      }
    };
    exports2.DomainsNotFoundError = DomainsNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainAlreadyExistsInProjectError.js
var require_DomainAlreadyExistsInProjectError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainAlreadyExistsInProjectError";
        this.toString = () => {
          return `Domain ${this.data.domain.hostname} already exists under the project.`;
        };
      }
    };
    exports2.DomainAlreadyExistsInProjectError = DomainAlreadyExistsInProjectError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainInPendingStateError.js
var require_DomainInPendingStateError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainInPendingStateError";
        this.toString = () => {
          return "Domain is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainInPendingStateError = DomainInPendingStateError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainHostnameInvalidError.js
var require_DomainHostnameInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainHostnameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainHostnameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainHostnameInvalidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainHostnameInvalidError";
        this.toString = () => {
          return `The domain ${this.data.hostname} is invalid`;
        };
      }
    };
    exports2.DomainHostnameInvalidError = DomainHostnameInvalidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnknownError.js
var require_UnknownError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnknownError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownError = void 0;
    var FleekError_1 = require_FleekError();
    var UnknownError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnknownError";
        this.toString = () => `Unexpected error. Repeat the action or contact support.`;
      }
    };
    exports2.UnknownError = UnknownError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteNotFoundError.js
var require_SiteNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotFoundError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} not found.`;
          }
          return `Site not found.`;
        };
      }
    };
    exports2.SiteNotFoundError = SiteNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SitesNotFoundError.js
var require_SitesNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SitesNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SitesNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SitesNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SitesNotFoundError";
        this.toString = () => "No sites found.";
      }
    };
    exports2.SitesNotFoundError = SitesNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteAlreadyExistsError.js
var require_SiteAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.site) {
            return `Site ${this.data.site.name} already exists in the project.`;
          }
          return `Site slug must be unique within Fleek but ${this.data.site.slug} already exists.`;
        };
      }
    };
    exports2.SiteAlreadyExistsError = SiteAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteDeploymentNotFoundError.js
var require_SiteDeploymentNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotFoundError";
        this.toString = () => `Deployment not found.`;
      }
    };
    exports2.SiteDeploymentNotFoundError = SiteDeploymentNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteHasDependentsError.js
var require_SiteHasDependentsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.domains.length > 0) {
            dependentsInfo.push(`${this.data.domains.length} domains`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Site has assigned ${dependentsInfo}. You have to delete them first.`;
        };
      }
    };
    exports2.SiteHasDependentsError = SiteHasDependentsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteHasNoSourceProviderError.js
var require_SiteHasNoSourceProviderError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteHasNoSourceProviderError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasNoSourceProviderError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasNoSourceProviderError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasNoSourceProviderError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have a source provider.`;
          }
          return `Site does not have a source provider.`;
        };
      }
    };
    exports2.SiteHasNoSourceProviderError = SiteHasNoSourceProviderError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteNotDeployedError.js
var require_SiteNotDeployedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteNotDeployedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotDeployedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotDeployedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotDeployedError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have released deployments.`;
          }
          return `Site does not have released deployments.`;
        };
      }
    };
    exports2.SiteNotDeployedError = SiteNotDeployedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordNotFoundError.js
var require_IpnsRecordNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordNotFoundError";
        this.toString = () => `IPNS record not found.`;
      }
    };
    exports2.IpnsRecordNotFoundError = IpnsRecordNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordsNotFoundError.js
var require_IpnsRecordsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "IpnsRecordsNotFoundError";
        this.toString = () => "No IPNS records found.";
      }
    };
    exports2.IpnsRecordsNotFoundError = IpnsRecordsNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsFailToDecryptKeyError.js
var require_IpnsFailToDecryptKeyError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsFailToDecryptKeyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsFailToDecryptKeyError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsFailToDecryptKeyError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsFailToDecryptKeyError";
        this.toString = () => `Failed to decrypt IPNS key.`;
      }
    };
    exports2.IpnsFailToDecryptKeyError = IpnsFailToDecryptKeyError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordsForSiteLimitError.js
var require_IpnsRecordsForSiteLimitError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpnsRecordsForSiteLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsForSiteLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsForSiteLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordsForSiteLimitError";
        this.toString = () => {
          if (this.data.site.name) {
            return `Maximum amount of IPNS records that may be assigned to the ${this.data.site.name} site was exceeded.`;
          }
          return `Maximum amount of IPNS records that may be assigned to the site was exceeded.`;
        };
      }
    };
    exports2.IpnsRecordsForSiteLimitError = IpnsRecordsForSiteLimitError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageIpfsUploadFailedError.js
var require_StorageIpfsUploadFailedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageIpfsUploadFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageIpfsUploadFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageIpfsUploadFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageIpfsUploadFailedError";
        this.toString = () => `Upload failed.`;
      }
    };
    exports2.StorageIpfsUploadFailedError = StorageIpfsUploadFailedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SdkRequiredNodeRuntimeError.js
var require_SdkRequiredNodeRuntimeError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SdkRequiredNodeRuntimeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SdkRequiredNodeRuntimeError = void 0;
    var FleekError_1 = require_FleekError();
    var SdkRequiredNodeRuntimeError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SdkRequiredNodeRuntimeError";
        this.toString = () => `The functionality of this SDK feature is dependent on the Node.js runtime.`;
      }
    };
    exports2.SdkRequiredNodeRuntimeError = SdkRequiredNodeRuntimeError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/AuthorizationError.js
var require_AuthorizationError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/AuthorizationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthorizationError = void 0;
    var FleekError_1 = require_FleekError();
    var AuthorizationError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "AuthorizationError";
        this.toString = () => `Authorization with provided credentials is invalid.`;
      }
    };
    exports2.AuthorizationError = AuthorizationError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipNotFoundError.js
var require_ProjectMembershipNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNotFoundError";
        this.toString = () => `Membership not found for project.`;
      }
    };
    exports2.ProjectMembershipNotFoundError = ProjectMembershipNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GithubAppInstallationNotFoundError.js
var require_GithubAppInstallationNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GithubAppInstallationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GithubAppInstallationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GithubAppInstallationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GithubAppInstallationNotFoundError";
        this.toString = () => {
          return "No GitHub App installation found for given project.";
        };
      }
    };
    exports2.GithubAppInstallationNotFoundError = GithubAppInstallationNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserNotFoundError.js
var require_UserNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserNotFoundError";
        this.toString = () => {
          if (this.data.email) {
            return `User with email ${this.data.email} not found.`;
          }
          return `User not found.`;
        };
      }
    };
    exports2.UserNotFoundError = UserNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserAlreadyExistsError.js
var require_UserAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserAlreadyExistsError";
        this.toString = () => "The username is already in use, please select another one";
      }
    };
    exports2.UserAlreadyExistsError = UserAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectNotFoundError.js
var require_ProjectNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectNotFoundError";
        this.toString = () => "Project not found.";
      }
    };
    exports2.ProjectNotFoundError = ProjectNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectsNotFoundError.js
var require_ProjectsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "ProjectsNotFoundError";
        this.toString = () => "No projects found.";
      }
    };
    exports2.ProjectsNotFoundError = ProjectsNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectHasDependentsError.js
var require_ProjectHasDependentsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.sites.length > 0) {
            dependentsInfo.push(`${this.data.sites.length} sites`);
          }
          if (this.data.privateGateways.length > 0) {
            dependentsInfo.push(`${this.data.privateGateways.length} private gateways`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Project has assigned ${dependentsInfo.join(", ")}. You have to delete them first.`;
        };
      }
    };
    exports2.ProjectHasDependentsError = ProjectHasDependentsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectInvalidNameError.js
var require_ProjectInvalidNameError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectInvalidNameError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvalidNameError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvalidNameError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvalidNameError";
        this.toString = () => `The project name ${this.data.name} is invalid.`;
      }
    };
    exports2.ProjectInvalidNameError = ProjectInvalidNameError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PublicKeyAlreadyExistsError.js
var require_PublicKeyAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PublicKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PublicKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PublicKeyAlreadyExistsError";
        this.toString = () => `Public key already exists.`;
      }
    };
    exports2.PublicKeyAlreadyExistsError = PublicKeyAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/VerificationSessionAlreadyExistsError.js
var require_VerificationSessionAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/VerificationSessionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerificationSessionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var VerificationSessionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "VerificationSessionAlreadyExistsError";
        this.toString = () => `Verification session already exists.`;
      }
    };
    exports2.VerificationSessionAlreadyExistsError = VerificationSessionAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnauthenticatedError.js
var require_UnauthenticatedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnauthenticatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthenticatedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthenticatedError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnauthenticatedError";
        this.toString = () => `The request is not authenticated.`;
      }
    };
    exports2.UnauthenticatedError = UnauthenticatedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneNotFoundError.js
var require_DomainZoneNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneNotFoundError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainZoneNotFoundError = DomainZoneNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneHasDependentsError.js
var require_DomainZoneHasDependentsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneHasDependentsError";
        this.toString = () => "Domain zone has assigned domains or private gateways. You have to delete them first.";
      }
    };
    exports2.DomainZoneHasDependentsError = DomainZoneHasDependentsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneInPendingStateError.js
var require_DomainZoneInPendingStateError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ZoneInPendingStateError";
        this.toString = () => {
          return "Domain zone is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainZoneInPendingStateError = DomainZoneInPendingStateError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainNotFoundUnderPullzoneError.js
var require_DomainNotFoundUnderPullzoneError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainNotFoundUnderPullzoneError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundUnderPullzoneError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundUnderPullzoneError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundUnderPullzoneError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainNotFoundUnderPullzoneError = DomainNotFoundUnderPullzoneError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneInvalidTypeError.js
var require_DomainZoneInvalidTypeError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DomainZoneInvalidTypeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInvalidTypeError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInvalidTypeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneInvalidTypeError";
        this.toString = () => "Domain zone has different purpose of use.";
      }
    };
    exports2.DomainZoneInvalidTypeError = DomainZoneInvalidTypeError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnauthorizedError.js
var require_UnauthorizedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnauthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthorizedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnauthorizedError";
        this.toString = () => {
          if (this.data.scopes) {
            return `You are not authorized to access this resource because of missing permissions: ${this.data.scopes.join(", ")}.`;
          }
          return `You are not authorized to access this resource.`;
        };
      }
    };
    exports2.UnauthorizedError = UnauthorizedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekConfigInvalidContentError.js
var require_FleekConfigInvalidContentError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekConfigInvalidContentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigInvalidContentError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigInvalidContentError4 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigInvalidContentError";
        this.toString = () => {
          if (this.data.validationResult) {
            return `Validation of loaded ${this.data.configPath} failed. ${this.data.validationResult}`;
          }
          return `Loaded ${this.data.configPath} file is corrupted.`;
        };
      }
    };
    exports2.FleekConfigInvalidContentError = FleekConfigInvalidContentError4;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekConfigMissingFileError.js
var require_FleekConfigMissingFileError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekConfigMissingFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigMissingFileError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigMissingFileError4 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigMissingFileError";
        this.toString = () => {
          return `Unable to access or find the configuration file${this.data.configPath && " " + this.data.configPath + "." || "."}`;
        };
      }
    };
    exports2.FleekConfigMissingFileError = FleekConfigMissingFileError4;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationWhitelistDomainDuplicityError.js
var require_ApplicationWhitelistDomainDuplicityError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationWhitelistDomainDuplicityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationWhitelistDomainDuplicityError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationWhitelistDomainDuplicityError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationWhitelistDomainDuplicityError";
        this.toString = () => `Application ${this.data.application.name} doesn't have unique white label domains.`;
      }
    };
    exports2.ApplicationWhitelistDomainDuplicityError = ApplicationWhitelistDomainDuplicityError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationAlreadyExistsError.js
var require_ApplicationAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationAlreadyExistsError";
        this.toString = () => `Application ${this.data.application.name} already exists.`;
      }
    };
    exports2.ApplicationAlreadyExistsError = ApplicationAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationsNotFoundError.js
var require_ApplicationsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationsNotFoundError";
        this.toString = () => "No applications found.";
      }
    };
    exports2.ApplicationsNotFoundError = ApplicationsNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationNotFoundError.js
var require_ApplicationNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNotFoundError";
        this.toString = () => "Application not found.";
      }
    };
    exports2.ApplicationNotFoundError = ApplicationNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationNameInvalidError.js
var require_ApplicationNameInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ApplicationNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNameInvalidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNameInvalidError";
        this.toString = () => `The application name ${this.data.name} is invalid.`;
      }
    };
    exports2.ApplicationNameInvalidError = ApplicationNameInvalidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordNotFoundError.js
var require_EnsRecordNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordNotFoundError";
        this.toString = () => {
          if (this.data.site?.id) {
            return `No site associated with this ENS record.`;
          }
          return `ENS record was not found.`;
        };
      }
    };
    exports2.EnsRecordNotFoundError = EnsRecordNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordAlreadyExistsInProjectError.js
var require_EnsRecordAlreadyExistsInProjectError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordAlreadyExistsInProjectError";
        this.toString = () => {
          return `ENS record already exists under the project.`;
        };
      }
    };
    exports2.EnsRecordAlreadyExistsInProjectError = EnsRecordAlreadyExistsInProjectError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameInvalidError.js
var require_EnsNameInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameInvalidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameInvalidError";
        this.toString = () => {
          return `ENS record name "${this.data.ensRecord.name}" is invalid.`;
        };
      }
    };
    exports2.EnsNameInvalidError = EnsNameInvalidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordInPendingStateError.js
var require_EnsRecordInPendingStateError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsRecordInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordInPendingStateError";
        this.toString = () => {
          return "ENS Record is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.EnsRecordInPendingStateError = EnsRecordInPendingStateError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidPersonalAccessTokenError.js
var require_InvalidPersonalAccessTokenError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidPersonalAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidPersonalAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidPersonalAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidPersonalAccessTokenError";
        this.toString = () => "Personal access token is invalid.";
      }
    };
    exports2.InvalidPersonalAccessTokenError = InvalidPersonalAccessTokenError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PersonalAccessTokenNotFoundError.js
var require_PersonalAccessTokenNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PersonalAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PersonalAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PersonalAccessTokenNotFoundError";
        this.toString = () => `Personal access token with ID ${this.data.personalAccessToken.id} not found.`;
      }
    };
    exports2.PersonalAccessTokenNotFoundError = PersonalAccessTokenNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayNotFoundError.js
var require_PrivateGatewayNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNotFoundError";
        this.toString = () => `Private gateway not found.`;
      }
    };
    exports2.PrivateGatewayNotFoundError = PrivateGatewayNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayAlreadyExistsError.js
var require_PrivateGatewayAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayAlreadyExistsError";
        this.toString = () => `Private gateway already exists. Please choose different name for the private gateway.`;
      }
    };
    exports2.PrivateGatewayAlreadyExistsError = PrivateGatewayAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayNameInvalidError.js
var require_PrivateGatewayNameInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewayNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNameInvalidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNameInvalidError";
        this.toString = () => `The private gateway name ${this.data.name} is invalid.`;
      }
    };
    exports2.PrivateGatewayNameInvalidError = PrivateGatewayNameInvalidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewaysNotFoundError.js
var require_PrivateGatewaysNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PrivateGatewaysNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewaysNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewaysNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewaysNotFoundError";
        this.toString = () => "No private gateways found.";
      }
    };
    exports2.PrivateGatewaysNotFoundError = PrivateGatewaysNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateAlreadyExistsError.js
var require_TemplateAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateAlreadyExistsError";
        this.toString = () => `Template already exists.`;
      }
    };
    exports2.TemplateAlreadyExistsError = TemplateAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateNotFoundError.js
var require_TemplateNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateNotFoundError";
        this.toString = () => `Template not found.`;
      }
    };
    exports2.TemplateNotFoundError = TemplateNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserHasNoAccessToAnotherUserError.js
var require_UserHasNoAccessToAnotherUserError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserHasNoAccessToAnotherUserError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToAnotherUserError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToAnotherUserError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserHasNoAccessToAnotherUserError";
        this.toString = () => "You don`t have access to user you try to fetch data for.";
      }
    };
    exports2.UserHasNoAccessToAnotherUserError = UserHasNoAccessToAnotherUserError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteFrameworkAlreadyExistsError.js
var require_SiteFrameworkAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteFrameworkAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkAlreadyExistsError";
        this.toString = () => `Site framework already exists.`;
      }
    };
    exports2.SiteFrameworkAlreadyExistsError = SiteFrameworkAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteFrameworkNotFoundError.js
var require_SiteFrameworkNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteFrameworkNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkNotFoundError";
        this.toString = () => `Site framework not found.`;
      }
    };
    exports2.SiteFrameworkNotFoundError = SiteFrameworkNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateCategoryNotFoundError.js
var require_TemplateCategoryNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateCategoryNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateCategoryNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateCategoryNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateCategoryNotFoundError";
        this.toString = () => `Template category not found.`;
      }
    };
    exports2.TemplateCategoryNotFoundError = TemplateCategoryNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateDeploymentNotFoundError.js
var require_TemplateDeploymentNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TemplateDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateDeploymentNotFoundError";
        this.toString = () => `Template deployment not found.`;
      }
    };
    exports2.TemplateDeploymentNotFoundError = TemplateDeploymentNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipHasInefficientRoleError.js
var require_ProjectMembershipHasInefficientRoleError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipHasInefficientRoleError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipHasInefficientRoleError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipHasInefficientRoleError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipHasInefficientRoleError";
        this.toString = () => `Membership has inefficient role for this action.`;
      }
    };
    exports2.ProjectMembershipHasInefficientRoleError = ProjectMembershipHasInefficientRoleError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretGroupNotFoundError.js
var require_SecretGroupNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretGroupNotFoundError";
        this.toString = () => {
          return "Secret group was not found.";
        };
      }
    };
    exports2.SecretGroupNotFoundError = SecretGroupNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretNotFoundError.js
var require_SecretNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretNotFoundError";
        this.toString = () => {
          return "Secret was not found.";
        };
      }
    };
    exports2.SecretNotFoundError = SecretNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretVisibilityAlreadyEncryptedError.js
var require_SecretVisibilityAlreadyEncryptedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretVisibilityAlreadyEncryptedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretVisibilityAlreadyEncryptedError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretVisibilityAlreadyEncryptedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretVisibilityAlreadyEncryptedError";
        this.toString = () => {
          return "You cannot change visibility of already encrypted secret.";
        };
      }
    };
    exports2.SecretVisibilityAlreadyEncryptedError = SecretVisibilityAlreadyEncryptedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretKeyAlreadyExistsError.js
var require_SecretKeyAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretKeyAlreadyExistsError";
        this.toString = () => {
          return "Variable with this key is already set.";
        };
      }
    };
    exports2.SecretKeyAlreadyExistsError = SecretKeyAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretFailToEncryptError.js
var require_SecretFailToEncryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SecretFailToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretFailToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretFailToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretFailToEncryptError";
        this.toString = () => {
          return "Failed to encrypt secret.";
        };
      }
    };
    exports2.SecretFailToEncryptError = SecretFailToEncryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinNotFoundError.js
var require_PinNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinNotFoundError";
        this.toString = () => {
          return "Pin was not found.";
        };
      }
    };
    exports2.PinNotFoundError = PinNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinAlreadyExistsInProjectError.js
var require_PinAlreadyExistsInProjectError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var PinAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinAlreadyExistsInProjectError";
        this.toString = () => {
          return `Pin with the same '${this.data.pin.cid ? "cid" : "path"}' already exists within the project.`;
        };
      }
    };
    exports2.PinAlreadyExistsInProjectError = PinAlreadyExistsInProjectError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnstoppableDeploymentError.js
var require_UnstoppableDeploymentError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UnstoppableDeploymentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnstoppableDeploymentError = void 0;
    var FleekError_1 = require_FleekError();
    var UnstoppableDeploymentError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnstoppableDeploymentError";
        this.toString = () => `Deployment cannot be stopped.`;
      }
    };
    exports2.UnstoppableDeploymentError = UnstoppableDeploymentError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteDeploymentNotReleasedError.js
var require_SiteDeploymentNotReleasedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteDeploymentNotReleasedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotReleasedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotReleasedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotReleasedError";
        this.toString = () => `Deployment not released.`;
      }
    };
    exports2.SiteDeploymentNotReleasedError = SiteDeploymentNotReleasedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidDeploymentTriggerError.js
var require_InvalidDeploymentTriggerError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidDeploymentTriggerError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidDeploymentTriggerError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidDeploymentTriggerError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidDeploymentTriggerError";
        this.toString = () => `Deployment can not be triggered, source provider integrations missing.`;
      }
    };
    exports2.InvalidDeploymentTriggerError = InvalidDeploymentTriggerError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpfsGatewayContentUnreachableError.js
var require_IpfsGatewayContentUnreachableError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpfsGatewayContentUnreachableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpfsGatewayContentUnreachableError = void 0;
    var FleekError_1 = require_FleekError();
    var IpfsGatewayContentUnreachableError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpfsGatewayContentUnreachableError";
        this.toString = () => "Cannot get IPFS content through Fleek gateway.";
      }
    };
    exports2.IpfsGatewayContentUnreachableError = IpfsGatewayContentUnreachableError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvitationNotFoundError.js
var require_InvitationNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvitationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvitationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var InvitationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvitationNotFoundError";
        this.toString = () => {
          return "Invitation was not found.";
        };
      }
    };
    exports2.InvitationNotFoundError = InvitationNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationTokenInvalidError.js
var require_MigrationTokenInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationTokenInvalidError";
        this.toString = () => "Migration token is invalid or expired.";
      }
    };
    exports2.MigrationTokenInvalidError = MigrationTokenInvalidError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestsAlreadyExistError.js
var require_MigrationRequestsAlreadyExistError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestsAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestsAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestsAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestsAlreadyExistError";
        this.toString = () => `All migration requests specified in token are either completed or in progress.`;
      }
    };
    exports2.MigrationRequestsAlreadyExistError = MigrationRequestsAlreadyExistError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestNotFoundError.js
var require_MigrationRequestNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestNotFoundError";
        this.toString = () => `Migration request ${this.data.migrationRequest.id} not found.`;
      }
    };
    exports2.MigrationRequestNotFoundError = MigrationRequestNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestInPendingStateError.js
var require_MigrationRequestInPendingStateError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MigrationRequestInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestInPendingStateError";
        this.toString = () => "Migration request is in pending state. Please wait and try action again later.";
      }
    };
    exports2.MigrationRequestInPendingStateError = MigrationRequestInPendingStateError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectInvitationAlreadyExistError.js
var require_ProjectInvitationAlreadyExistError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectInvitationAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvitationAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvitationAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvitationAlreadyExistError";
        this.toString = () => `Project invitation with email ${this.data.user.email} for this project already exist.`;
      }
    };
    exports2.ProjectInvitationAlreadyExistError = ProjectInvitationAlreadyExistError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipAlreadyExistError.js
var require_ProjectMembershipAlreadyExistError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipAlreadyExistError";
        this.toString = () => `Project membership already exists.`;
      }
    };
    exports2.ProjectMembershipAlreadyExistError = ProjectMembershipAlreadyExistError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipNoOwnersError.js
var require_ProjectMembershipNoOwnersError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectMembershipNoOwnersError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNoOwnersError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNoOwnersError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNoOwnersError";
        this.toString = () => `Each project must have at least OWNER-role one membership.`;
      }
    };
    exports2.ProjectMembershipNoOwnersError = ProjectMembershipNoOwnersError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadedS3KeyNotFoundError.js
var require_UploadedS3KeyNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadedS3KeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadedS3KeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadedS3KeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UploadedS3KeyNotFoundError";
        this.toString = () => "Uploaded S3 Key not found.";
      }
    };
    exports2.UploadedS3KeyNotFoundError = UploadedS3KeyNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PathIsNotADirectoryError.js
var require_PathIsNotADirectoryError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PathIsNotADirectoryError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotADirectoryError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotADirectoryError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotADirectoryError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a directory.`;
        };
      }
    };
    exports2.PathIsNotADirectoryError = PathIsNotADirectoryError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionAlreadyExistsError.js
var require_FleekFunctionAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.function || "slug" in this.data.function) {
            return `Function ${this.data.function.name || this.data.function.slug} already exists.`;
          }
          return `Unexpected Function data structure ${JSON.stringify(this.data.function)}`;
        };
      }
    };
    exports2.FleekFunctionAlreadyExistsError = FleekFunctionAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionNotFoundError.js
var require_FleekFunctionNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNotFoundError";
        this.toString = () => {
          if (this.data.function?.name) {
            return `Function ${this.data.function.name} not found.`;
          }
          return `Function not found.`;
        };
      }
    };
    exports2.FleekFunctionNotFoundError = FleekFunctionNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionDeploymentNotFoundError.js
var require_FleekFunctionDeploymentNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionDeploymentNotFoundError";
        this.toString = () => {
          return `Deployment not found.`;
        };
      }
    };
    exports2.FleekFunctionDeploymentNotFoundError = FleekFunctionDeploymentNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionsNotFoundError.js
var require_FleekFunctionsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionsNotFoundError";
        this.toString = () => "No functions found.";
      }
    };
    exports2.FleekFunctionsNotFoundError = FleekFunctionsNotFoundError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionPathNotValidError.js
var require_FleekFunctionPathNotValidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionPathNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionPathNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionPathNotValidError4 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionPathNotValidError";
        this.toString = () => {
          return `File or folder at path, ${this.data.path} is invalid. Please refer to our documentation for more information on function file conventions.`;
        };
      }
    };
    exports2.FleekFunctionPathNotValidError = FleekFunctionPathNotValidError4;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionNameNotValidError.js
var require_FleekFunctionNameNotValidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionNameNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNameNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNameNotValidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNameNotValidError";
        this.toString = () => {
          return `The name, ${this.data.name}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionNameNotValidError = FleekFunctionNameNotValidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionStatusNotValidError.js
var require_FleekFunctionStatusNotValidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionStatusNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionStatusNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionStatusNotValidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionStatusNotValidError";
        this.toString = () => {
          return `The function status is invalid. Must be one of ACTIVE and INACTIVE`;
        };
      }
    };
    exports2.FleekFunctionStatusNotValidError = FleekFunctionStatusNotValidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionSlugNotValidError.js
var require_FleekFunctionSlugNotValidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionSlugNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionSlugNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionSlugNotValidError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionSlugNotValidError";
        this.toString = () => {
          return `The slug, ${this.data.slug}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionSlugNotValidError = FleekFunctionSlugNotValidError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MaintenanceError.js
var require_MaintenanceError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MaintenanceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaintenanceError = void 0;
    var FleekError_1 = require_FleekError();
    var MaintenanceError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "MaintenanceError";
        this.extensions = {
          http: {
            status: 503
            // Service Unavailable
          }
        };
        this.toString = () => "The platform is under maintenance. Please try again later.";
      }
    };
    exports2.MaintenanceError = MaintenanceError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserHasNoAccessToFeatureError.js
var require_UserHasNoAccessToFeatureError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserHasNoAccessToFeatureError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToFeatureError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToFeatureError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserHasNoAccessToFeatureError";
        this.toString = () => `User has no access to this feature.`;
      }
    };
    exports2.UserHasNoAccessToFeatureError = UserHasNoAccessToFeatureError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidCidError.js
var require_InvalidCidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidCidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidCidError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidCidError3 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidCidError";
        this.toString = () => `The cid ${this.data.name} is invalid.`;
      }
    };
    exports2.InvalidCidError = InvalidCidError3;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ValidationError.js
var require_ValidationError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ValidationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationError = void 0;
    var FleekError_1 = require_FleekError();
    var ValidationError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ValidationError";
        this.toString = () => `${JSON.stringify(this.data)}`;
      }
    };
    exports2.ValidationError = ValidationError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserInBlocklistError.js
var require_UserInBlocklistError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserInBlocklistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserInBlocklistError = void 0;
    var FleekError_1 = require_FleekError();
    var UserInBlocklistError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserInBlocklistError";
        this.toString = () => "User is in the blocklist.";
      }
    };
    exports2.UserInBlocklistError = UserInBlocklistError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameContentHashCodecMistmatchError.js
var require_EnsNameContentHashCodecMistmatchError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameContentHashCodecMistmatchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashCodecMistmatchError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashCodecMistmatchError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashCodecMistmatchError";
        this.toString = () => {
          return `The content hash does not match or does not corresponds to ${this.data.codec} protocol`;
        };
      }
    };
    exports2.EnsNameContentHashCodecMistmatchError = EnsNameContentHashCodecMistmatchError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameContentHashUndefinedError.js
var require_EnsNameContentHashUndefinedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnsNameContentHashUndefinedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashUndefinedError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashUndefinedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashUndefinedError";
        this.toString = () => {
          return `The content hash for ENS record name "${this.data.ensRecord.name}" is undefined.`;
        };
      }
    };
    exports2.EnsNameContentHashUndefinedError = EnsNameContentHashUndefinedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DnsConfigAlreadyExistsError.js
var require_DnsConfigAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DnsConfigAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigAlreadyExistsError";
        this.toString = () => `DNS config already exists for "${this.data.name}".`;
      }
    };
    exports2.DnsConfigAlreadyExistsError = DnsConfigAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DnsConfigNotFoundError.js
var require_DnsConfigNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DnsConfigNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigNotFoundError";
        this.toString = () => `DNS config for the "${this.data.name}" name doesn't exist.`;
      }
    };
    exports2.DnsConfigNotFoundError = DnsConfigNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TwoFactorSecretKeyFailedToEncryptError.js
var require_TwoFactorSecretKeyFailedToEncryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TwoFactorSecretKeyFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToEncryptError";
        this.toString = () => "Failed to encrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToEncryptError = TwoFactorSecretKeyFailedToEncryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserSecretKeyAlreadyExistsError.js
var require_UserSecretKeyAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserSecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyAlreadyExistsError";
        this.toString = () => "A secret key for this user already exists.";
      }
    };
    exports2.UserSecretKeyAlreadyExistsError = UserSecretKeyAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserSecretKeyNotFoundError.js
var require_UserSecretKeyNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserSecretKeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyNotFoundError";
        this.toString = () => "A secret key for this user not found.";
      }
    };
    exports2.UserSecretKeyNotFoundError = UserSecretKeyNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TwoFactorSecretKeyFailedToDecryptError.js
var require_TwoFactorSecretKeyFailedToDecryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/TwoFactorSecretKeyFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToDecryptError";
        this.toString = () => "Failed to decrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToDecryptError = TwoFactorSecretKeyFailedToDecryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodesAlreadyExistsError.js
var require_RecoveryCodesAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodesAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodesAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodesAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodesAlreadyExistsError";
        this.toString = () => "Recovery codes already exists.";
      }
    };
    exports2.RecoveryCodesAlreadyExistsError = RecoveryCodesAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/WriteFileFromStreamError.js
var require_WriteFileFromStreamError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/WriteFileFromStreamError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteFileFromStreamError = void 0;
    var FleekError_1 = require_FleekError();
    var WriteFileFromStreamError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "WriteFileFromStreamError";
        this.toString = () => `There was an error while writing file from stream in globSource`;
      }
    };
    exports2.WriteFileFromStreamError = WriteFileFromStreamError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidTOTPTokenError.js
var require_InvalidTOTPTokenError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidTOTPTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidTOTPTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidTOTPTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidTOTPTokenError";
        this.toString = () => "TOTP token is invalid.";
      }
    };
    exports2.InvalidTOTPTokenError = InvalidTOTPTokenError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidRecoveryCodeError.js
var require_InvalidRecoveryCodeError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidRecoveryCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidRecoveryCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidRecoveryCodeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidRecoveryCodeError";
        this.toString = () => "Recovery code is invalid.";
      }
    };
    exports2.InvalidRecoveryCodeError = InvalidRecoveryCodeError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MissingTwoFactorProtectionCredentialsError.js
var require_MissingTwoFactorProtectionCredentialsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MissingTwoFactorProtectionCredentialsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingTwoFactorProtectionCredentialsError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingTwoFactorProtectionCredentialsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingTwoFactorProtectionCredentialsError";
        this.toString = () => "Missing two factor protection credentials. Either a token or a recovery key should be provided.";
      }
    };
    exports2.MissingTwoFactorProtectionCredentialsError = MissingTwoFactorProtectionCredentialsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DeploymentInProgressError.js
var require_DeploymentInProgressError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/DeploymentInProgressError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeploymentInProgressError = void 0;
    var FleekError_1 = require_FleekError();
    var DeploymentInProgressError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DeploymentInProgressError";
        this.toString = () => "Deployment is already in progress.";
      }
    };
    exports2.DeploymentInProgressError = DeploymentInProgressError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PullzoneNotFoundForZoneIdError.js
var require_PullzoneNotFoundForZoneIdError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PullzoneNotFoundForZoneIdError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PullzoneNotFoundForZoneIdError = void 0;
    var FleekError_1 = require_FleekError();
    var PullzoneNotFoundForZoneIdError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PullzoneNotFoundForZoneIdError";
        this.toString = () => {
          return `The pullzone is not found for zone id: ${this.data.id}`;
        };
      }
    };
    exports2.PullzoneNotFoundForZoneIdError = PullzoneNotFoundForZoneIdError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodeFailedToEncryptError.js
var require_RecoveryCodeFailedToEncryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodeFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToEncryptError";
        this.toString = () => "Failed to encrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToEncryptError = RecoveryCodeFailedToEncryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodeFailedToDecryptError.js
var require_RecoveryCodeFailedToDecryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/RecoveryCodeFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToDecryptError";
        this.toString = () => "Failed to decrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToDecryptError = RecoveryCodeFailedToDecryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PermissionGroupNotFoundError.js
var require_PermissionGroupNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PermissionGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionGroupNotFoundError";
        this.toString = () => "Permission group not found";
      }
    };
    exports2.PermissionGroupNotFoundError = PermissionGroupNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PermissionScopeError.js
var require_PermissionScopeError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PermissionScopeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionScopeError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionScopeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionScopeError";
        this.toString = () => `Permission scope ${this.data.scope} doesn't exist.`;
      }
    };
    exports2.PermissionScopeError = PermissionScopeError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidAdminAccessTokenError.js
var require_InvalidAdminAccessTokenError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidAdminAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidAdminAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidAdminAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidAdminAccessTokenError";
        this.toString = () => "Admin access token is invalid.";
      }
    };
    exports2.InvalidAdminAccessTokenError = InvalidAdminAccessTokenError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MissingExpectedDataError.js
var require_MissingExpectedDataError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/MissingExpectedDataError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingExpectedDataError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingExpectedDataError4 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingExpectedDataError";
        this.toString = () => "Oops! This is embarassing but the app is missing important data. Please report this issue to the team.";
      }
    };
    exports2.MissingExpectedDataError = MissingExpectedDataError4;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnvNotSetError.js
var require_EnvNotSetError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/EnvNotSetError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnvNotSetError = void 0;
    var FleekError_1 = require_FleekError();
    var EnvNotSetError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnvNotSetError";
        this.toString = () => this.data ? `Environment variable "${this.data}" is not set.` : `Missing the defined object key pair values.`;
      }
    };
    exports2.EnvNotSetError = EnvNotSetError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitSecretsFailedToEncryptError.js
var require_GitSecretsFailedToEncryptError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitSecretsFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitSecretsFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var GitSecretsFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to encrypt Git Secrets.";
      }
    };
    exports2.GitSecretsFailedToEncryptError = GitSecretsFailedToEncryptError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitConfigFailedToParseError.js
var require_GitConfigFailedToParseError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitConfigFailedToParseError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitConfigFailedToParseError = void 0;
    var FleekError_1 = require_FleekError();
    var GitConfigFailedToParseError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to parse Git Configs.";
      }
    };
    exports2.GitConfigFailedToParseError = GitConfigFailedToParseError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PathIsNotAFileError.js
var require_PathIsNotAFileError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PathIsNotAFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotAFileError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotAFileError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotAFileError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a file.`;
        };
      }
    };
    exports2.PathIsNotAFileError = PathIsNotAFileError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionBundlingFailedError.js
var require_FleekFunctionBundlingFailedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionBundlingFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionBundlingFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionBundlingFailedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionBundlingFailedError";
        this.toString = () => {
          return `Bundle creation failed. For information on supported packages, please consult our documentation.
Error: ${this.data.error}`;
        };
      }
    };
    exports2.FleekFunctionBundlingFailedError = FleekFunctionBundlingFailedError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitIntegrationNotFoundError.js
var require_GitIntegrationNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitIntegrationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationNotFoundError";
        this.toString = () => {
          let infix = "";
          if ("siteId" in this.data) {
            infix = `for site ${this.data.siteId}`;
          } else if ("id" in this.data) {
            infix = `with id ${this.data.id}`;
          }
          return `Git Integration ${infix} not found`;
        };
      }
    };
    exports2.GitIntegrationNotFoundError = GitIntegrationNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotFoundError.js
var require_GitProviderNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotFoundError";
        this.toString = () => {
          return `No Git Provider found with id: ${this.data.providerId}`;
        };
      }
    };
    exports2.GitProviderNotFoundError = GitProviderNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ExpectedOneOfValuesError.js
var require_ExpectedOneOfValuesError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ExpectedOneOfValuesError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpectedOneOfValuesError = void 0;
    var FleekError_1 = require_FleekError();
    var ExpectedOneOfValuesError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ExpectedOneOfValuesError";
        this.toString = () => `Expected one of ${this.data.expectedValues.join(", ")} but got ${this.data.receivedValue}`;
      }
    };
    exports2.ExpectedOneOfValuesError = ExpectedOneOfValuesError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidJSONFormat.js
var require_InvalidJSONFormat = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/InvalidJSONFormat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidJSONFormat = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidJSONFormat2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidJSONFormat";
        this.toString = () => `Invalid JSON format.`;
      }
    };
    exports2.InvalidJSONFormat = InvalidJSONFormat2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageUploadFileCountQuotaExceededError.js
var require_StorageUploadFileCountQuotaExceededError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageUploadFileCountQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadFileCountQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadFileCountQuotaExceededError = class extends FleekError_1.FleekError {
      constructor(data = {}) {
        super(data);
        this.name = "StorageUploadFileCountQuotaExceededError";
        this.toString = () => {
          if (this.data?.quota) {
            return `Sorry, you have reached your daily limit of ${this.data.quota} file uploads. We are unable to process your request.`;
          }
          return "You have exceeded your file upload limit for the past 24 hours.";
        };
      }
    };
    exports2.StorageUploadFileCountQuotaExceededError = StorageUploadFileCountQuotaExceededError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageUploadTotalSizeQuotaExceededError.js
var require_StorageUploadTotalSizeQuotaExceededError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/StorageUploadTotalSizeQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadTotalSizeQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadTotalSizeQuotaExceededError = class extends FleekError_1.FleekError {
      constructor(data = {}) {
        super(data);
        this.name = "StorageUploadTotalSizeQuotaExceededError";
        this.toString = () => {
          if (this.data?.quota) {
            return `Sorry, you have reached your daily upload limit of ${Math.round(this.data.quota / 1e3 ** 3)}GB. We are unable to process your request.`;
          }
          return "You have exceeded your storage upload quota for the last 24 hours.";
        };
      }
    };
    exports2.StorageUploadTotalSizeQuotaExceededError = StorageUploadTotalSizeQuotaExceededError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotSupportedError.js
var require_GitProviderNotSupportedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotSupportedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotSupportedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotSupportedError";
        this.toString = () => `Git provider: ${this.data.provider} not Supported`;
      }
    };
    exports2.GitProviderNotSupportedError = GitProviderNotSupportedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotAuthorizedError.js
var require_GitProviderNotAuthorizedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitProviderNotAuthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotAuthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotAuthorizedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotAuthorizedError";
        this.toString = () => `The user has not authorized the Git provider: ${this.data.provider}`;
      }
    };
    exports2.GitProviderNotAuthorizedError = GitProviderNotAuthorizedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitAccessTokenInvalidError.js
var require_GitAccessTokenInvalidError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitAccessTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenInvalidError";
        this.toString = () => {
          return "The git access token for the user is invalid";
        };
      }
    };
    exports2.GitAccessTokenInvalidError = GitAccessTokenInvalidError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/QueuedDeploymentsLimitError.js
var require_QueuedDeploymentsLimitError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/QueuedDeploymentsLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuedDeploymentsLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var QueuedDeploymentsLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "QueuedDeploymentsLimitError";
        this.toString = () => `You've reached the limit of ${this.data.limit} queued deployments.`;
      }
    };
    exports2.QueuedDeploymentsLimitError = QueuedDeploymentsLimitError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitIntegrationInstallationConflictError.js
var require_GitIntegrationInstallationConflictError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitIntegrationInstallationConflictError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationInstallationConflictError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationInstallationConflictError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationInstallationConflictError";
        this.toString = () => `The Git Integration installation for this provider already exists in this project`;
      }
    };
    exports2.GitIntegrationInstallationConflictError = GitIntegrationInstallationConflictError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitLinkMultipleAccountError.js
var require_GitLinkMultipleAccountError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitLinkMultipleAccountError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitLinkMultipleAccountError = void 0;
    var FleekError_1 = require_FleekError();
    var GitLinkMultipleAccountError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitLinkMultipleAccountError";
        this.toString = () => `Oops! You already have a Git profile linked to your Fleek account. We don't allow multiple connections`;
      }
    };
    exports2.GitLinkMultipleAccountError = GitLinkMultipleAccountError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitRepoByNameAndOwnerNotFoundError.js
var require_GitRepoByNameAndOwnerNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitRepoByNameAndOwnerNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitRepoByNameAndOwnerNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitRepoByNameAndOwnerNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitRepoByNameAndOwnerNotFoundError";
        this.toString = () => `Git repo "${this.data.owner}/${this.data.repo}" not found`;
      }
    };
    exports2.GitRepoByNameAndOwnerNotFoundError = GitRepoByNameAndOwnerNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitAccessTokenNotFoundError.js
var require_GitAccessTokenNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/GitAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenNotFoundError";
        this.toString = () => {
          return "The git access token for the user is not found";
        };
      }
    };
    exports2.GitAccessTokenNotFoundError = GitAccessTokenNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderNotFoundError.js
var require_FolderNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderNotFoundError";
        this.toString = () => `Folder was not found.`;
      }
    };
    exports2.FolderNotFoundError = FolderNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderAlreadyExistsError.js
var require_FolderAlreadyExistsError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderAlreadyExistsError";
        this.toString = () => `Folder ${this.data.folder.name} already exists in ${this.data.folder.parentFolderId ? "parent" : "root project"} folder.`;
      }
    };
    exports2.FolderAlreadyExistsError = FolderAlreadyExistsError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderNameContainsReservedWordError.js
var require_FolderNameContainsReservedWordError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FolderNameContainsReservedWordError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderNameContainsReservedWordError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderNameContainsReservedWordError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderNameContainsReservedWorkError";
        this.toString = () => `Folder name ${this.data.name} is reserved word and you cannot use it.`;
      }
    };
    exports2.FolderNameContainsReservedWordError = FolderNameContainsReservedWordError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinsNotFoundError.js
var require_PinsNotFoundError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/PinsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinsNotFoundError";
        this.toString = () => {
          return "No pins found.";
        };
      }
    };
    exports2.PinsNotFoundError = PinsNotFoundError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteCreationFailedError.js
var require_SiteCreationFailedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/SiteCreationFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteCreationFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteCreationFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SiteCreationFailedError";
        this.toString = () => `Site creation failed.`;
      }
    };
    exports2.SiteCreationFailedError = SiteCreationFailedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionInvalidWasmCodeError.js
var require_FleekFunctionInvalidWasmCodeError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionInvalidWasmCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionInvalidWasmCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionInvalidWasmCodeError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionInvalidWasmCodeError";
        this.toString = () => {
          return `Fleek function encountered corrupt or invalid WASM code.`;
        };
      }
    };
    exports2.FleekFunctionInvalidWasmCodeError = FleekFunctionInvalidWasmCodeError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionWasmEncryptionFailedError.js
var require_FleekFunctionWasmEncryptionFailedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/FleekFunctionWasmEncryptionFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionWasmEncryptionFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionWasmEncryptionFailedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionWasmEncryptionFailedError";
        this.toString = () => {
          return `Unable to encrypt WASM code for Fleek function`;
        };
      }
    };
    exports2.FleekFunctionWasmEncryptionFailedError = FleekFunctionWasmEncryptionFailedError2;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadProxyStoreAsCarError.js
var require_UploadProxyStoreAsCarError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadProxyStoreAsCarError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyStoreAsCarError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyStoreAsCarError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyStoreAsCarError";
        this.toString = () => `Failed to Store as a CAR file.`;
      }
    };
    exports2.UploadProxyStoreAsCarError = UploadProxyStoreAsCarError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadProxyUploadFileError.js
var require_UploadProxyUploadFileError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UploadProxyUploadFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyUploadFileError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyUploadFileError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyUploadFileError";
        this.toString = () => `Failed to Upload file.`;
      }
    };
    exports2.UploadProxyUploadFileError = UploadProxyUploadFileError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpfsDenylistUpdateWorkflowTriggerFailedError.js
var require_IpfsDenylistUpdateWorkflowTriggerFailedError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/IpfsDenylistUpdateWorkflowTriggerFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpfsDenylistUpdateWorkflowTriggerFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var IpfsDenylistUpdateWorkflowTriggerFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpfsDenylistUpdateWorkflowTriggerFailedError";
        this.toString = () => {
          return `Failed to trigger IPFS denylist update workflow: ${this.data.error}`;
        };
      }
    };
    exports2.IpfsDenylistUpdateWorkflowTriggerFailedError = IpfsDenylistUpdateWorkflowTriggerFailedError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectSiteLimitExceededError.js
var require_ProjectSiteLimitExceededError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectSiteLimitExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectSiteLimitExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectSiteLimitExceededError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "ProjectSiteLimitExceededError";
        this.toString = () => `You've reached the maximum number of sites for this project. Contact our Support team if you have any questions.`;
      }
    };
    exports2.ProjectSiteLimitExceededError = ProjectSiteLimitExceededError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectFleekFunctionLimitExceededError.js
var require_ProjectFleekFunctionLimitExceededError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/ProjectFleekFunctionLimitExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectFleekFunctionLimitExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectFleekFunctionLimitExceededError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "ProjectFleekFunctionLimitExceededError";
        this.toString = () => `You've reached the maximum number of Fleek functions for this project. Contact our Support team if you have any questions.`;
      }
    };
    exports2.ProjectFleekFunctionLimitExceededError = ProjectFleekFunctionLimitExceededError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserProjectLimitExceededError.js
var require_UserProjectLimitExceededError = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/UserProjectLimitExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserProjectLimitExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var UserProjectLimitExceededError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserProjectLimitExceededError";
        this.toString = () => `You've reached the maximum number of projects for your account. Contact our Support team if you have any questions.`;
      }
    };
    exports2.UserProjectLimitExceededError = UserProjectLimitExceededError;
  }
});

// node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+errors@2.7.0/node_modules/@fleek-platform/errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = exports2.EnsNameInvalidError = exports2.EnsRecordAlreadyExistsInProjectError = exports2.EnsRecordNotFoundError = exports2.ApplicationNameInvalidError = exports2.ApplicationNotFoundError = exports2.ApplicationsNotFoundError = exports2.ApplicationAlreadyExistsError = exports2.ApplicationWhitelistDomainDuplicityError = exports2.FleekConfigMissingFileError = exports2.FleekConfigInvalidContentError = exports2.UnauthorizedError = exports2.DomainZoneInvalidTypeError = exports2.DomainNotFoundUnderPullzoneError = exports2.DomainZoneInPendingStateError = exports2.DomainZoneHasDependentsError = exports2.DomainZoneNotFoundError = exports2.UnauthenticatedError = exports2.VerificationSessionAlreadyExistsError = exports2.PublicKeyAlreadyExistsError = exports2.ProjectInvalidNameError = exports2.ProjectHasDependentsError = exports2.ProjectsNotFoundError = exports2.ProjectNotFoundError = exports2.UserAlreadyExistsError = exports2.UserNotFoundError = exports2.GithubAppInstallationNotFoundError = exports2.ProjectMembershipNotFoundError = exports2.AuthorizationError = exports2.SdkRequiredNodeRuntimeError = exports2.StorageIpfsUploadFailedError = exports2.IpnsRecordsForSiteLimitError = exports2.IpnsFailToDecryptKeyError = exports2.IpnsRecordsNotFoundError = exports2.IpnsRecordNotFoundError = exports2.SiteNotDeployedError = exports2.SiteHasNoSourceProviderError = exports2.SiteHasDependentsError = exports2.SiteDeploymentNotFoundError = exports2.SiteAlreadyExistsError = exports2.SitesNotFoundError = exports2.SiteNotFoundError = exports2.UnknownError = exports2.DomainHostnameInvalidError = exports2.DomainInPendingStateError = exports2.DomainAlreadyExistsInProjectError = exports2.DomainsNotFoundError = exports2.DomainNotFoundError = exports2.BunnyPullZoneNotFoundError = exports2.FleekError = void 0;
    exports2.EnsNameContentHashUndefinedError = exports2.EnsNameContentHashCodecMistmatchError = exports2.UserInBlocklistError = exports2.ValidationError = exports2.InvalidCidError = exports2.UserHasNoAccessToFeatureError = exports2.MaintenanceError = exports2.FleekFunctionSlugNotValidError = exports2.FleekFunctionStatusNotValidError = exports2.FleekFunctionNameNotValidError = exports2.FleekFunctionPathNotValidError = exports2.FleekFunctionsNotFoundError = exports2.FleekFunctionDeploymentNotFoundError = exports2.FleekFunctionNotFoundError = exports2.FleekFunctionAlreadyExistsError = exports2.PathIsNotADirectoryError = exports2.UploadedS3KeyNotFoundError = exports2.ProjectMembershipNoOwnersError = exports2.ProjectMembershipAlreadyExistError = exports2.ProjectInvitationAlreadyExistError = exports2.MigrationRequestInPendingStateError = exports2.MigrationRequestNotFoundError = exports2.MigrationRequestsAlreadyExistError = exports2.MigrationTokenInvalidError = exports2.InvitationNotFoundError = exports2.IpfsGatewayContentUnreachableError = exports2.InvalidDeploymentTriggerError = exports2.SiteDeploymentNotReleasedError = exports2.UnstoppableDeploymentError = exports2.PinAlreadyExistsInProjectError = exports2.PinNotFoundError = exports2.SecretFailToEncryptError = exports2.SecretKeyAlreadyExistsError = exports2.SecretVisibilityAlreadyEncryptedError = exports2.SecretNotFoundError = exports2.SecretGroupNotFoundError = exports2.ProjectMembershipHasInefficientRoleError = exports2.TemplateDeploymentNotFoundError = exports2.TemplateCategoryNotFoundError = exports2.SiteFrameworkNotFoundError = exports2.SiteFrameworkAlreadyExistsError = exports2.UserHasNoAccessToAnotherUserError = exports2.TemplateNotFoundError = exports2.TemplateAlreadyExistsError = exports2.PrivateGatewaysNotFoundError = exports2.PrivateGatewayNameInvalidError = exports2.PrivateGatewayAlreadyExistsError = exports2.PrivateGatewayNotFoundError = exports2.PersonalAccessTokenNotFoundError = exports2.InvalidPersonalAccessTokenError = void 0;
    exports2.ProjectFleekFunctionLimitExceededError = exports2.ProjectSiteLimitExceededError = exports2.IpfsDenylistUpdateWorkflowTriggerFailedError = exports2.UploadProxyUploadFileError = exports2.UploadProxyStoreAsCarError = exports2.FleekFunctionWasmEncryptionFailedError = exports2.FleekFunctionInvalidWasmCodeError = exports2.SiteCreationFailedError = exports2.PinsNotFoundError = exports2.FolderNameContainsReservedWordError = exports2.FolderAlreadyExistsError = exports2.FolderNotFoundError = exports2.GitAccessTokenNotFoundError = exports2.GitRepoByNameAndOwnerNotFoundError = exports2.GitLinkMultipleAccountError = exports2.GitIntegrationInstallationConflictError = exports2.QueuedDeploymentsLimitError = exports2.GitAccessTokenInvalidError = exports2.GitProviderNotAuthorizedError = exports2.GitProviderNotSupportedError = exports2.StorageUploadTotalSizeQuotaExceededError = exports2.StorageUploadFileCountQuotaExceededError = exports2.InvalidJSONFormat = exports2.ExpectedOneOfValuesError = exports2.GitProviderNotFoundError = exports2.GitIntegrationNotFoundError = exports2.FleekFunctionBundlingFailedError = exports2.PathIsNotAFileError = exports2.GitConfigFailedToParseError = exports2.GitSecretsFailedToEncryptError = exports2.EnvNotSetError = exports2.MissingExpectedDataError = exports2.InvalidAdminAccessTokenError = exports2.PermissionScopeError = exports2.PermissionGroupNotFoundError = exports2.RecoveryCodeFailedToDecryptError = exports2.RecoveryCodeFailedToEncryptError = exports2.PullzoneNotFoundForZoneIdError = exports2.DeploymentInProgressError = exports2.MissingTwoFactorProtectionCredentialsError = exports2.InvalidRecoveryCodeError = exports2.InvalidTOTPTokenError = exports2.WriteFileFromStreamError = exports2.RecoveryCodesAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToDecryptError = exports2.UserSecretKeyNotFoundError = exports2.UserSecretKeyAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToEncryptError = exports2.DnsConfigNotFoundError = exports2.DnsConfigAlreadyExistsError = void 0;
    exports2.UserProjectLimitExceededError = void 0;
    var FleekError_1 = require_FleekError();
    Object.defineProperty(exports2, "FleekError", { enumerable: true, get: function() {
      return FleekError_1.FleekError;
    } });
    var BunnyPullZoneNotFoundError_1 = require_BunnyPullZoneNotFoundError();
    Object.defineProperty(exports2, "BunnyPullZoneNotFoundError", { enumerable: true, get: function() {
      return BunnyPullZoneNotFoundError_1.BunnyPullZoneNotFoundError;
    } });
    var DomainNotFoundError_1 = require_DomainNotFoundError();
    Object.defineProperty(exports2, "DomainNotFoundError", { enumerable: true, get: function() {
      return DomainNotFoundError_1.DomainNotFoundError;
    } });
    var DomainsNotFoundError_1 = require_DomainsNotFoundError();
    Object.defineProperty(exports2, "DomainsNotFoundError", { enumerable: true, get: function() {
      return DomainsNotFoundError_1.DomainsNotFoundError;
    } });
    var DomainAlreadyExistsInProjectError_1 = require_DomainAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "DomainAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return DomainAlreadyExistsInProjectError_1.DomainAlreadyExistsInProjectError;
    } });
    var DomainInPendingStateError_1 = require_DomainInPendingStateError();
    Object.defineProperty(exports2, "DomainInPendingStateError", { enumerable: true, get: function() {
      return DomainInPendingStateError_1.DomainInPendingStateError;
    } });
    var DomainHostnameInvalidError_1 = require_DomainHostnameInvalidError();
    Object.defineProperty(exports2, "DomainHostnameInvalidError", { enumerable: true, get: function() {
      return DomainHostnameInvalidError_1.DomainHostnameInvalidError;
    } });
    var UnknownError_1 = require_UnknownError();
    Object.defineProperty(exports2, "UnknownError", { enumerable: true, get: function() {
      return UnknownError_1.UnknownError;
    } });
    var SiteNotFoundError_1 = require_SiteNotFoundError();
    Object.defineProperty(exports2, "SiteNotFoundError", { enumerable: true, get: function() {
      return SiteNotFoundError_1.SiteNotFoundError;
    } });
    var SitesNotFoundError_1 = require_SitesNotFoundError();
    Object.defineProperty(exports2, "SitesNotFoundError", { enumerable: true, get: function() {
      return SitesNotFoundError_1.SitesNotFoundError;
    } });
    var SiteAlreadyExistsError_1 = require_SiteAlreadyExistsError();
    Object.defineProperty(exports2, "SiteAlreadyExistsError", { enumerable: true, get: function() {
      return SiteAlreadyExistsError_1.SiteAlreadyExistsError;
    } });
    var SiteDeploymentNotFoundError_1 = require_SiteDeploymentNotFoundError();
    Object.defineProperty(exports2, "SiteDeploymentNotFoundError", { enumerable: true, get: function() {
      return SiteDeploymentNotFoundError_1.SiteDeploymentNotFoundError;
    } });
    var SiteHasDependentsError_1 = require_SiteHasDependentsError();
    Object.defineProperty(exports2, "SiteHasDependentsError", { enumerable: true, get: function() {
      return SiteHasDependentsError_1.SiteHasDependentsError;
    } });
    var SiteHasNoSourceProviderError_1 = require_SiteHasNoSourceProviderError();
    Object.defineProperty(exports2, "SiteHasNoSourceProviderError", { enumerable: true, get: function() {
      return SiteHasNoSourceProviderError_1.SiteHasNoSourceProviderError;
    } });
    var SiteNotDeployedError_1 = require_SiteNotDeployedError();
    Object.defineProperty(exports2, "SiteNotDeployedError", { enumerable: true, get: function() {
      return SiteNotDeployedError_1.SiteNotDeployedError;
    } });
    var IpnsRecordNotFoundError_1 = require_IpnsRecordNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordNotFoundError_1.IpnsRecordNotFoundError;
    } });
    var IpnsRecordsNotFoundError_1 = require_IpnsRecordsNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordsNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordsNotFoundError_1.IpnsRecordsNotFoundError;
    } });
    var IpnsFailToDecryptKeyError_1 = require_IpnsFailToDecryptKeyError();
    Object.defineProperty(exports2, "IpnsFailToDecryptKeyError", { enumerable: true, get: function() {
      return IpnsFailToDecryptKeyError_1.IpnsFailToDecryptKeyError;
    } });
    var IpnsRecordsForSiteLimitError_1 = require_IpnsRecordsForSiteLimitError();
    Object.defineProperty(exports2, "IpnsRecordsForSiteLimitError", { enumerable: true, get: function() {
      return IpnsRecordsForSiteLimitError_1.IpnsRecordsForSiteLimitError;
    } });
    var StorageIpfsUploadFailedError_1 = require_StorageIpfsUploadFailedError();
    Object.defineProperty(exports2, "StorageIpfsUploadFailedError", { enumerable: true, get: function() {
      return StorageIpfsUploadFailedError_1.StorageIpfsUploadFailedError;
    } });
    var SdkRequiredNodeRuntimeError_1 = require_SdkRequiredNodeRuntimeError();
    Object.defineProperty(exports2, "SdkRequiredNodeRuntimeError", { enumerable: true, get: function() {
      return SdkRequiredNodeRuntimeError_1.SdkRequiredNodeRuntimeError;
    } });
    var AuthorizationError_1 = require_AuthorizationError();
    Object.defineProperty(exports2, "AuthorizationError", { enumerable: true, get: function() {
      return AuthorizationError_1.AuthorizationError;
    } });
    var ProjectMembershipNotFoundError_1 = require_ProjectMembershipNotFoundError();
    Object.defineProperty(exports2, "ProjectMembershipNotFoundError", { enumerable: true, get: function() {
      return ProjectMembershipNotFoundError_1.ProjectMembershipNotFoundError;
    } });
    var GithubAppInstallationNotFoundError_1 = require_GithubAppInstallationNotFoundError();
    Object.defineProperty(exports2, "GithubAppInstallationNotFoundError", { enumerable: true, get: function() {
      return GithubAppInstallationNotFoundError_1.GithubAppInstallationNotFoundError;
    } });
    var UserNotFoundError_1 = require_UserNotFoundError();
    Object.defineProperty(exports2, "UserNotFoundError", { enumerable: true, get: function() {
      return UserNotFoundError_1.UserNotFoundError;
    } });
    var UserAlreadyExistsError_1 = require_UserAlreadyExistsError();
    Object.defineProperty(exports2, "UserAlreadyExistsError", { enumerable: true, get: function() {
      return UserAlreadyExistsError_1.UserAlreadyExistsError;
    } });
    var ProjectNotFoundError_1 = require_ProjectNotFoundError();
    Object.defineProperty(exports2, "ProjectNotFoundError", { enumerable: true, get: function() {
      return ProjectNotFoundError_1.ProjectNotFoundError;
    } });
    var ProjectsNotFoundError_1 = require_ProjectsNotFoundError();
    Object.defineProperty(exports2, "ProjectsNotFoundError", { enumerable: true, get: function() {
      return ProjectsNotFoundError_1.ProjectsNotFoundError;
    } });
    var ProjectHasDependentsError_1 = require_ProjectHasDependentsError();
    Object.defineProperty(exports2, "ProjectHasDependentsError", { enumerable: true, get: function() {
      return ProjectHasDependentsError_1.ProjectHasDependentsError;
    } });
    var ProjectInvalidNameError_1 = require_ProjectInvalidNameError();
    Object.defineProperty(exports2, "ProjectInvalidNameError", { enumerable: true, get: function() {
      return ProjectInvalidNameError_1.ProjectInvalidNameError;
    } });
    var PublicKeyAlreadyExistsError_1 = require_PublicKeyAlreadyExistsError();
    Object.defineProperty(exports2, "PublicKeyAlreadyExistsError", { enumerable: true, get: function() {
      return PublicKeyAlreadyExistsError_1.PublicKeyAlreadyExistsError;
    } });
    var VerificationSessionAlreadyExistsError_1 = require_VerificationSessionAlreadyExistsError();
    Object.defineProperty(exports2, "VerificationSessionAlreadyExistsError", { enumerable: true, get: function() {
      return VerificationSessionAlreadyExistsError_1.VerificationSessionAlreadyExistsError;
    } });
    var UnauthenticatedError_1 = require_UnauthenticatedError();
    Object.defineProperty(exports2, "UnauthenticatedError", { enumerable: true, get: function() {
      return UnauthenticatedError_1.UnauthenticatedError;
    } });
    var DomainZoneNotFoundError_1 = require_DomainZoneNotFoundError();
    Object.defineProperty(exports2, "DomainZoneNotFoundError", { enumerable: true, get: function() {
      return DomainZoneNotFoundError_1.DomainZoneNotFoundError;
    } });
    var DomainZoneHasDependentsError_1 = require_DomainZoneHasDependentsError();
    Object.defineProperty(exports2, "DomainZoneHasDependentsError", { enumerable: true, get: function() {
      return DomainZoneHasDependentsError_1.DomainZoneHasDependentsError;
    } });
    var DomainZoneInPendingStateError_1 = require_DomainZoneInPendingStateError();
    Object.defineProperty(exports2, "DomainZoneInPendingStateError", { enumerable: true, get: function() {
      return DomainZoneInPendingStateError_1.DomainZoneInPendingStateError;
    } });
    var DomainNotFoundUnderPullzoneError_1 = require_DomainNotFoundUnderPullzoneError();
    Object.defineProperty(exports2, "DomainNotFoundUnderPullzoneError", { enumerable: true, get: function() {
      return DomainNotFoundUnderPullzoneError_1.DomainNotFoundUnderPullzoneError;
    } });
    var DomainZoneInvalidTypeError_1 = require_DomainZoneInvalidTypeError();
    Object.defineProperty(exports2, "DomainZoneInvalidTypeError", { enumerable: true, get: function() {
      return DomainZoneInvalidTypeError_1.DomainZoneInvalidTypeError;
    } });
    var UnauthorizedError_1 = require_UnauthorizedError();
    Object.defineProperty(exports2, "UnauthorizedError", { enumerable: true, get: function() {
      return UnauthorizedError_1.UnauthorizedError;
    } });
    var FleekConfigInvalidContentError_1 = require_FleekConfigInvalidContentError();
    Object.defineProperty(exports2, "FleekConfigInvalidContentError", { enumerable: true, get: function() {
      return FleekConfigInvalidContentError_1.FleekConfigInvalidContentError;
    } });
    var FleekConfigMissingFileError_1 = require_FleekConfigMissingFileError();
    Object.defineProperty(exports2, "FleekConfigMissingFileError", { enumerable: true, get: function() {
      return FleekConfigMissingFileError_1.FleekConfigMissingFileError;
    } });
    var ApplicationWhitelistDomainDuplicityError_1 = require_ApplicationWhitelistDomainDuplicityError();
    Object.defineProperty(exports2, "ApplicationWhitelistDomainDuplicityError", { enumerable: true, get: function() {
      return ApplicationWhitelistDomainDuplicityError_1.ApplicationWhitelistDomainDuplicityError;
    } });
    var ApplicationAlreadyExistsError_1 = require_ApplicationAlreadyExistsError();
    Object.defineProperty(exports2, "ApplicationAlreadyExistsError", { enumerable: true, get: function() {
      return ApplicationAlreadyExistsError_1.ApplicationAlreadyExistsError;
    } });
    var ApplicationsNotFoundError_1 = require_ApplicationsNotFoundError();
    Object.defineProperty(exports2, "ApplicationsNotFoundError", { enumerable: true, get: function() {
      return ApplicationsNotFoundError_1.ApplicationsNotFoundError;
    } });
    var ApplicationNotFoundError_1 = require_ApplicationNotFoundError();
    Object.defineProperty(exports2, "ApplicationNotFoundError", { enumerable: true, get: function() {
      return ApplicationNotFoundError_1.ApplicationNotFoundError;
    } });
    var ApplicationNameInvalidError_1 = require_ApplicationNameInvalidError();
    Object.defineProperty(exports2, "ApplicationNameInvalidError", { enumerable: true, get: function() {
      return ApplicationNameInvalidError_1.ApplicationNameInvalidError;
    } });
    var EnsRecordNotFoundError_1 = require_EnsRecordNotFoundError();
    Object.defineProperty(exports2, "EnsRecordNotFoundError", { enumerable: true, get: function() {
      return EnsRecordNotFoundError_1.EnsRecordNotFoundError;
    } });
    var EnsRecordAlreadyExistsInProjectError_1 = require_EnsRecordAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "EnsRecordAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return EnsRecordAlreadyExistsInProjectError_1.EnsRecordAlreadyExistsInProjectError;
    } });
    var EnsNameInvalidError_1 = require_EnsNameInvalidError();
    Object.defineProperty(exports2, "EnsNameInvalidError", { enumerable: true, get: function() {
      return EnsNameInvalidError_1.EnsNameInvalidError;
    } });
    var EnsRecordInPendingStateError_1 = require_EnsRecordInPendingStateError();
    Object.defineProperty(exports2, "EnsRecordInPendingStateError", { enumerable: true, get: function() {
      return EnsRecordInPendingStateError_1.EnsRecordInPendingStateError;
    } });
    var InvalidPersonalAccessTokenError_1 = require_InvalidPersonalAccessTokenError();
    Object.defineProperty(exports2, "InvalidPersonalAccessTokenError", { enumerable: true, get: function() {
      return InvalidPersonalAccessTokenError_1.InvalidPersonalAccessTokenError;
    } });
    var PersonalAccessTokenNotFoundError_1 = require_PersonalAccessTokenNotFoundError();
    Object.defineProperty(exports2, "PersonalAccessTokenNotFoundError", { enumerable: true, get: function() {
      return PersonalAccessTokenNotFoundError_1.PersonalAccessTokenNotFoundError;
    } });
    var PrivateGatewayNotFoundError_1 = require_PrivateGatewayNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewayNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewayNotFoundError_1.PrivateGatewayNotFoundError;
    } });
    var PrivateGatewayAlreadyExistsError_1 = require_PrivateGatewayAlreadyExistsError();
    Object.defineProperty(exports2, "PrivateGatewayAlreadyExistsError", { enumerable: true, get: function() {
      return PrivateGatewayAlreadyExistsError_1.PrivateGatewayAlreadyExistsError;
    } });
    var PrivateGatewayNameInvalidError_1 = require_PrivateGatewayNameInvalidError();
    Object.defineProperty(exports2, "PrivateGatewayNameInvalidError", { enumerable: true, get: function() {
      return PrivateGatewayNameInvalidError_1.PrivateGatewayNameInvalidError;
    } });
    var PrivateGatewaysNotFoundError_1 = require_PrivateGatewaysNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewaysNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewaysNotFoundError_1.PrivateGatewaysNotFoundError;
    } });
    var TemplateAlreadyExistsError_1 = require_TemplateAlreadyExistsError();
    Object.defineProperty(exports2, "TemplateAlreadyExistsError", { enumerable: true, get: function() {
      return TemplateAlreadyExistsError_1.TemplateAlreadyExistsError;
    } });
    var TemplateNotFoundError_1 = require_TemplateNotFoundError();
    Object.defineProperty(exports2, "TemplateNotFoundError", { enumerable: true, get: function() {
      return TemplateNotFoundError_1.TemplateNotFoundError;
    } });
    var UserHasNoAccessToAnotherUserError_1 = require_UserHasNoAccessToAnotherUserError();
    Object.defineProperty(exports2, "UserHasNoAccessToAnotherUserError", { enumerable: true, get: function() {
      return UserHasNoAccessToAnotherUserError_1.UserHasNoAccessToAnotherUserError;
    } });
    var SiteFrameworkAlreadyExistsError_1 = require_SiteFrameworkAlreadyExistsError();
    Object.defineProperty(exports2, "SiteFrameworkAlreadyExistsError", { enumerable: true, get: function() {
      return SiteFrameworkAlreadyExistsError_1.SiteFrameworkAlreadyExistsError;
    } });
    var SiteFrameworkNotFoundError_1 = require_SiteFrameworkNotFoundError();
    Object.defineProperty(exports2, "SiteFrameworkNotFoundError", { enumerable: true, get: function() {
      return SiteFrameworkNotFoundError_1.SiteFrameworkNotFoundError;
    } });
    var TemplateCategoryNotFoundError_1 = require_TemplateCategoryNotFoundError();
    Object.defineProperty(exports2, "TemplateCategoryNotFoundError", { enumerable: true, get: function() {
      return TemplateCategoryNotFoundError_1.TemplateCategoryNotFoundError;
    } });
    var TemplateDeploymentNotFoundError_1 = require_TemplateDeploymentNotFoundError();
    Object.defineProperty(exports2, "TemplateDeploymentNotFoundError", { enumerable: true, get: function() {
      return TemplateDeploymentNotFoundError_1.TemplateDeploymentNotFoundError;
    } });
    var ProjectMembershipHasInefficientRoleError_1 = require_ProjectMembershipHasInefficientRoleError();
    Object.defineProperty(exports2, "ProjectMembershipHasInefficientRoleError", { enumerable: true, get: function() {
      return ProjectMembershipHasInefficientRoleError_1.ProjectMembershipHasInefficientRoleError;
    } });
    var SecretGroupNotFoundError_1 = require_SecretGroupNotFoundError();
    Object.defineProperty(exports2, "SecretGroupNotFoundError", { enumerable: true, get: function() {
      return SecretGroupNotFoundError_1.SecretGroupNotFoundError;
    } });
    var SecretNotFoundError_1 = require_SecretNotFoundError();
    Object.defineProperty(exports2, "SecretNotFoundError", { enumerable: true, get: function() {
      return SecretNotFoundError_1.SecretNotFoundError;
    } });
    var SecretVisibilityAlreadyEncryptedError_1 = require_SecretVisibilityAlreadyEncryptedError();
    Object.defineProperty(exports2, "SecretVisibilityAlreadyEncryptedError", { enumerable: true, get: function() {
      return SecretVisibilityAlreadyEncryptedError_1.SecretVisibilityAlreadyEncryptedError;
    } });
    var SecretKeyAlreadyExistsError_1 = require_SecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "SecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return SecretKeyAlreadyExistsError_1.SecretKeyAlreadyExistsError;
    } });
    var SecretFailToEncryptError_1 = require_SecretFailToEncryptError();
    Object.defineProperty(exports2, "SecretFailToEncryptError", { enumerable: true, get: function() {
      return SecretFailToEncryptError_1.SecretFailToEncryptError;
    } });
    var PinNotFoundError_1 = require_PinNotFoundError();
    Object.defineProperty(exports2, "PinNotFoundError", { enumerable: true, get: function() {
      return PinNotFoundError_1.PinNotFoundError;
    } });
    var PinAlreadyExistsInProjectError_1 = require_PinAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "PinAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return PinAlreadyExistsInProjectError_1.PinAlreadyExistsInProjectError;
    } });
    var UnstoppableDeploymentError_1 = require_UnstoppableDeploymentError();
    Object.defineProperty(exports2, "UnstoppableDeploymentError", { enumerable: true, get: function() {
      return UnstoppableDeploymentError_1.UnstoppableDeploymentError;
    } });
    var SiteDeploymentNotReleasedError_1 = require_SiteDeploymentNotReleasedError();
    Object.defineProperty(exports2, "SiteDeploymentNotReleasedError", { enumerable: true, get: function() {
      return SiteDeploymentNotReleasedError_1.SiteDeploymentNotReleasedError;
    } });
    var InvalidDeploymentTriggerError_1 = require_InvalidDeploymentTriggerError();
    Object.defineProperty(exports2, "InvalidDeploymentTriggerError", { enumerable: true, get: function() {
      return InvalidDeploymentTriggerError_1.InvalidDeploymentTriggerError;
    } });
    var IpfsGatewayContentUnreachableError_1 = require_IpfsGatewayContentUnreachableError();
    Object.defineProperty(exports2, "IpfsGatewayContentUnreachableError", { enumerable: true, get: function() {
      return IpfsGatewayContentUnreachableError_1.IpfsGatewayContentUnreachableError;
    } });
    var InvitationNotFoundError_1 = require_InvitationNotFoundError();
    Object.defineProperty(exports2, "InvitationNotFoundError", { enumerable: true, get: function() {
      return InvitationNotFoundError_1.InvitationNotFoundError;
    } });
    var MigrationTokenInvalidError_1 = require_MigrationTokenInvalidError();
    Object.defineProperty(exports2, "MigrationTokenInvalidError", { enumerable: true, get: function() {
      return MigrationTokenInvalidError_1.MigrationTokenInvalidError;
    } });
    var MigrationRequestsAlreadyExistError_1 = require_MigrationRequestsAlreadyExistError();
    Object.defineProperty(exports2, "MigrationRequestsAlreadyExistError", { enumerable: true, get: function() {
      return MigrationRequestsAlreadyExistError_1.MigrationRequestsAlreadyExistError;
    } });
    var MigrationRequestNotFoundError_1 = require_MigrationRequestNotFoundError();
    Object.defineProperty(exports2, "MigrationRequestNotFoundError", { enumerable: true, get: function() {
      return MigrationRequestNotFoundError_1.MigrationRequestNotFoundError;
    } });
    var MigrationRequestInPendingStateError_1 = require_MigrationRequestInPendingStateError();
    Object.defineProperty(exports2, "MigrationRequestInPendingStateError", { enumerable: true, get: function() {
      return MigrationRequestInPendingStateError_1.MigrationRequestInPendingStateError;
    } });
    var ProjectInvitationAlreadyExistError_1 = require_ProjectInvitationAlreadyExistError();
    Object.defineProperty(exports2, "ProjectInvitationAlreadyExistError", { enumerable: true, get: function() {
      return ProjectInvitationAlreadyExistError_1.ProjectInvitationAlreadyExistError;
    } });
    var ProjectMembershipAlreadyExistError_1 = require_ProjectMembershipAlreadyExistError();
    Object.defineProperty(exports2, "ProjectMembershipAlreadyExistError", { enumerable: true, get: function() {
      return ProjectMembershipAlreadyExistError_1.ProjectMembershipAlreadyExistError;
    } });
    var ProjectMembershipNoOwnersError_1 = require_ProjectMembershipNoOwnersError();
    Object.defineProperty(exports2, "ProjectMembershipNoOwnersError", { enumerable: true, get: function() {
      return ProjectMembershipNoOwnersError_1.ProjectMembershipNoOwnersError;
    } });
    var UploadedS3KeyNotFoundError_1 = require_UploadedS3KeyNotFoundError();
    Object.defineProperty(exports2, "UploadedS3KeyNotFoundError", { enumerable: true, get: function() {
      return UploadedS3KeyNotFoundError_1.UploadedS3KeyNotFoundError;
    } });
    var PathIsNotADirectoryError_1 = require_PathIsNotADirectoryError();
    Object.defineProperty(exports2, "PathIsNotADirectoryError", { enumerable: true, get: function() {
      return PathIsNotADirectoryError_1.PathIsNotADirectoryError;
    } });
    var FleekFunctionAlreadyExistsError_1 = require_FleekFunctionAlreadyExistsError();
    Object.defineProperty(exports2, "FleekFunctionAlreadyExistsError", { enumerable: true, get: function() {
      return FleekFunctionAlreadyExistsError_1.FleekFunctionAlreadyExistsError;
    } });
    var FleekFunctionNotFoundError_1 = require_FleekFunctionNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionNotFoundError_1.FleekFunctionNotFoundError;
    } });
    var FleekFunctionDeploymentNotFoundError_1 = require_FleekFunctionDeploymentNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionDeploymentNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionDeploymentNotFoundError_1.FleekFunctionDeploymentNotFoundError;
    } });
    var FleekFunctionsNotFoundError_1 = require_FleekFunctionsNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionsNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionsNotFoundError_1.FleekFunctionsNotFoundError;
    } });
    var FleekFunctionPathNotValidError_1 = require_FleekFunctionPathNotValidError();
    Object.defineProperty(exports2, "FleekFunctionPathNotValidError", { enumerable: true, get: function() {
      return FleekFunctionPathNotValidError_1.FleekFunctionPathNotValidError;
    } });
    var FleekFunctionNameNotValidError_1 = require_FleekFunctionNameNotValidError();
    Object.defineProperty(exports2, "FleekFunctionNameNotValidError", { enumerable: true, get: function() {
      return FleekFunctionNameNotValidError_1.FleekFunctionNameNotValidError;
    } });
    var FleekFunctionStatusNotValidError_1 = require_FleekFunctionStatusNotValidError();
    Object.defineProperty(exports2, "FleekFunctionStatusNotValidError", { enumerable: true, get: function() {
      return FleekFunctionStatusNotValidError_1.FleekFunctionStatusNotValidError;
    } });
    var FleekFunctionSlugNotValidError_1 = require_FleekFunctionSlugNotValidError();
    Object.defineProperty(exports2, "FleekFunctionSlugNotValidError", { enumerable: true, get: function() {
      return FleekFunctionSlugNotValidError_1.FleekFunctionSlugNotValidError;
    } });
    var MaintenanceError_1 = require_MaintenanceError();
    Object.defineProperty(exports2, "MaintenanceError", { enumerable: true, get: function() {
      return MaintenanceError_1.MaintenanceError;
    } });
    var UserHasNoAccessToFeatureError_1 = require_UserHasNoAccessToFeatureError();
    Object.defineProperty(exports2, "UserHasNoAccessToFeatureError", { enumerable: true, get: function() {
      return UserHasNoAccessToFeatureError_1.UserHasNoAccessToFeatureError;
    } });
    var InvalidCidError_1 = require_InvalidCidError();
    Object.defineProperty(exports2, "InvalidCidError", { enumerable: true, get: function() {
      return InvalidCidError_1.InvalidCidError;
    } });
    var ValidationError_1 = require_ValidationError();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return ValidationError_1.ValidationError;
    } });
    var UserInBlocklistError_1 = require_UserInBlocklistError();
    Object.defineProperty(exports2, "UserInBlocklistError", { enumerable: true, get: function() {
      return UserInBlocklistError_1.UserInBlocklistError;
    } });
    var EnsNameContentHashCodecMistmatchError_1 = require_EnsNameContentHashCodecMistmatchError();
    Object.defineProperty(exports2, "EnsNameContentHashCodecMistmatchError", { enumerable: true, get: function() {
      return EnsNameContentHashCodecMistmatchError_1.EnsNameContentHashCodecMistmatchError;
    } });
    var EnsNameContentHashUndefinedError_1 = require_EnsNameContentHashUndefinedError();
    Object.defineProperty(exports2, "EnsNameContentHashUndefinedError", { enumerable: true, get: function() {
      return EnsNameContentHashUndefinedError_1.EnsNameContentHashUndefinedError;
    } });
    var DnsConfigAlreadyExistsError_1 = require_DnsConfigAlreadyExistsError();
    Object.defineProperty(exports2, "DnsConfigAlreadyExistsError", { enumerable: true, get: function() {
      return DnsConfigAlreadyExistsError_1.DnsConfigAlreadyExistsError;
    } });
    var DnsConfigNotFoundError_1 = require_DnsConfigNotFoundError();
    Object.defineProperty(exports2, "DnsConfigNotFoundError", { enumerable: true, get: function() {
      return DnsConfigNotFoundError_1.DnsConfigNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToEncryptError_1 = require_TwoFactorSecretKeyFailedToEncryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToEncryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToEncryptError_1.TwoFactorSecretKeyFailedToEncryptError;
    } });
    var UserSecretKeyAlreadyExistsError_1 = require_UserSecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "UserSecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return UserSecretKeyAlreadyExistsError_1.UserSecretKeyAlreadyExistsError;
    } });
    var UserSecretKeyNotFoundError_1 = require_UserSecretKeyNotFoundError();
    Object.defineProperty(exports2, "UserSecretKeyNotFoundError", { enumerable: true, get: function() {
      return UserSecretKeyNotFoundError_1.UserSecretKeyNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToDecryptError_1 = require_TwoFactorSecretKeyFailedToDecryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToDecryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToDecryptError_1.TwoFactorSecretKeyFailedToDecryptError;
    } });
    var RecoveryCodesAlreadyExistsError_1 = require_RecoveryCodesAlreadyExistsError();
    Object.defineProperty(exports2, "RecoveryCodesAlreadyExistsError", { enumerable: true, get: function() {
      return RecoveryCodesAlreadyExistsError_1.RecoveryCodesAlreadyExistsError;
    } });
    var WriteFileFromStreamError_1 = require_WriteFileFromStreamError();
    Object.defineProperty(exports2, "WriteFileFromStreamError", { enumerable: true, get: function() {
      return WriteFileFromStreamError_1.WriteFileFromStreamError;
    } });
    var InvalidTOTPTokenError_1 = require_InvalidTOTPTokenError();
    Object.defineProperty(exports2, "InvalidTOTPTokenError", { enumerable: true, get: function() {
      return InvalidTOTPTokenError_1.InvalidTOTPTokenError;
    } });
    var InvalidRecoveryCodeError_1 = require_InvalidRecoveryCodeError();
    Object.defineProperty(exports2, "InvalidRecoveryCodeError", { enumerable: true, get: function() {
      return InvalidRecoveryCodeError_1.InvalidRecoveryCodeError;
    } });
    var MissingTwoFactorProtectionCredentialsError_1 = require_MissingTwoFactorProtectionCredentialsError();
    Object.defineProperty(exports2, "MissingTwoFactorProtectionCredentialsError", { enumerable: true, get: function() {
      return MissingTwoFactorProtectionCredentialsError_1.MissingTwoFactorProtectionCredentialsError;
    } });
    var DeploymentInProgressError_1 = require_DeploymentInProgressError();
    Object.defineProperty(exports2, "DeploymentInProgressError", { enumerable: true, get: function() {
      return DeploymentInProgressError_1.DeploymentInProgressError;
    } });
    var PullzoneNotFoundForZoneIdError_1 = require_PullzoneNotFoundForZoneIdError();
    Object.defineProperty(exports2, "PullzoneNotFoundForZoneIdError", { enumerable: true, get: function() {
      return PullzoneNotFoundForZoneIdError_1.PullzoneNotFoundForZoneIdError;
    } });
    var RecoveryCodeFailedToEncryptError_1 = require_RecoveryCodeFailedToEncryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToEncryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToEncryptError_1.RecoveryCodeFailedToEncryptError;
    } });
    var RecoveryCodeFailedToDecryptError_1 = require_RecoveryCodeFailedToDecryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToDecryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToDecryptError_1.RecoveryCodeFailedToDecryptError;
    } });
    var PermissionGroupNotFoundError_1 = require_PermissionGroupNotFoundError();
    Object.defineProperty(exports2, "PermissionGroupNotFoundError", { enumerable: true, get: function() {
      return PermissionGroupNotFoundError_1.PermissionGroupNotFoundError;
    } });
    var PermissionScopeError_1 = require_PermissionScopeError();
    Object.defineProperty(exports2, "PermissionScopeError", { enumerable: true, get: function() {
      return PermissionScopeError_1.PermissionScopeError;
    } });
    var InvalidAdminAccessTokenError_1 = require_InvalidAdminAccessTokenError();
    Object.defineProperty(exports2, "InvalidAdminAccessTokenError", { enumerable: true, get: function() {
      return InvalidAdminAccessTokenError_1.InvalidAdminAccessTokenError;
    } });
    var MissingExpectedDataError_1 = require_MissingExpectedDataError();
    Object.defineProperty(exports2, "MissingExpectedDataError", { enumerable: true, get: function() {
      return MissingExpectedDataError_1.MissingExpectedDataError;
    } });
    var EnvNotSetError_1 = require_EnvNotSetError();
    Object.defineProperty(exports2, "EnvNotSetError", { enumerable: true, get: function() {
      return EnvNotSetError_1.EnvNotSetError;
    } });
    var GitSecretsFailedToEncryptError_1 = require_GitSecretsFailedToEncryptError();
    Object.defineProperty(exports2, "GitSecretsFailedToEncryptError", { enumerable: true, get: function() {
      return GitSecretsFailedToEncryptError_1.GitSecretsFailedToEncryptError;
    } });
    var GitConfigFailedToParseError_1 = require_GitConfigFailedToParseError();
    Object.defineProperty(exports2, "GitConfigFailedToParseError", { enumerable: true, get: function() {
      return GitConfigFailedToParseError_1.GitConfigFailedToParseError;
    } });
    var PathIsNotAFileError_1 = require_PathIsNotAFileError();
    Object.defineProperty(exports2, "PathIsNotAFileError", { enumerable: true, get: function() {
      return PathIsNotAFileError_1.PathIsNotAFileError;
    } });
    var FleekFunctionBundlingFailedError_1 = require_FleekFunctionBundlingFailedError();
    Object.defineProperty(exports2, "FleekFunctionBundlingFailedError", { enumerable: true, get: function() {
      return FleekFunctionBundlingFailedError_1.FleekFunctionBundlingFailedError;
    } });
    var GitIntegrationNotFoundError_1 = require_GitIntegrationNotFoundError();
    Object.defineProperty(exports2, "GitIntegrationNotFoundError", { enumerable: true, get: function() {
      return GitIntegrationNotFoundError_1.GitIntegrationNotFoundError;
    } });
    var GitProviderNotFoundError_1 = require_GitProviderNotFoundError();
    Object.defineProperty(exports2, "GitProviderNotFoundError", { enumerable: true, get: function() {
      return GitProviderNotFoundError_1.GitProviderNotFoundError;
    } });
    var ExpectedOneOfValuesError_1 = require_ExpectedOneOfValuesError();
    Object.defineProperty(exports2, "ExpectedOneOfValuesError", { enumerable: true, get: function() {
      return ExpectedOneOfValuesError_1.ExpectedOneOfValuesError;
    } });
    var InvalidJSONFormat_1 = require_InvalidJSONFormat();
    Object.defineProperty(exports2, "InvalidJSONFormat", { enumerable: true, get: function() {
      return InvalidJSONFormat_1.InvalidJSONFormat;
    } });
    var StorageUploadFileCountQuotaExceededError_1 = require_StorageUploadFileCountQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadFileCountQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadFileCountQuotaExceededError_1.StorageUploadFileCountQuotaExceededError;
    } });
    var StorageUploadTotalSizeQuotaExceededError_1 = require_StorageUploadTotalSizeQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadTotalSizeQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadTotalSizeQuotaExceededError_1.StorageUploadTotalSizeQuotaExceededError;
    } });
    var GitProviderNotSupportedError_1 = require_GitProviderNotSupportedError();
    Object.defineProperty(exports2, "GitProviderNotSupportedError", { enumerable: true, get: function() {
      return GitProviderNotSupportedError_1.GitProviderNotSupportedError;
    } });
    var GitProviderNotAuthorizedError_1 = require_GitProviderNotAuthorizedError();
    Object.defineProperty(exports2, "GitProviderNotAuthorizedError", { enumerable: true, get: function() {
      return GitProviderNotAuthorizedError_1.GitProviderNotAuthorizedError;
    } });
    var GitAccessTokenInvalidError_1 = require_GitAccessTokenInvalidError();
    Object.defineProperty(exports2, "GitAccessTokenInvalidError", { enumerable: true, get: function() {
      return GitAccessTokenInvalidError_1.GitAccessTokenInvalidError;
    } });
    var QueuedDeploymentsLimitError_1 = require_QueuedDeploymentsLimitError();
    Object.defineProperty(exports2, "QueuedDeploymentsLimitError", { enumerable: true, get: function() {
      return QueuedDeploymentsLimitError_1.QueuedDeploymentsLimitError;
    } });
    var GitIntegrationInstallationConflictError_1 = require_GitIntegrationInstallationConflictError();
    Object.defineProperty(exports2, "GitIntegrationInstallationConflictError", { enumerable: true, get: function() {
      return GitIntegrationInstallationConflictError_1.GitIntegrationInstallationConflictError;
    } });
    var GitLinkMultipleAccountError_1 = require_GitLinkMultipleAccountError();
    Object.defineProperty(exports2, "GitLinkMultipleAccountError", { enumerable: true, get: function() {
      return GitLinkMultipleAccountError_1.GitLinkMultipleAccountError;
    } });
    var GitRepoByNameAndOwnerNotFoundError_1 = require_GitRepoByNameAndOwnerNotFoundError();
    Object.defineProperty(exports2, "GitRepoByNameAndOwnerNotFoundError", { enumerable: true, get: function() {
      return GitRepoByNameAndOwnerNotFoundError_1.GitRepoByNameAndOwnerNotFoundError;
    } });
    var GitAccessTokenNotFoundError_1 = require_GitAccessTokenNotFoundError();
    Object.defineProperty(exports2, "GitAccessTokenNotFoundError", { enumerable: true, get: function() {
      return GitAccessTokenNotFoundError_1.GitAccessTokenNotFoundError;
    } });
    var FolderNotFoundError_1 = require_FolderNotFoundError();
    Object.defineProperty(exports2, "FolderNotFoundError", { enumerable: true, get: function() {
      return FolderNotFoundError_1.FolderNotFoundError;
    } });
    var FolderAlreadyExistsError_1 = require_FolderAlreadyExistsError();
    Object.defineProperty(exports2, "FolderAlreadyExistsError", { enumerable: true, get: function() {
      return FolderAlreadyExistsError_1.FolderAlreadyExistsError;
    } });
    var FolderNameContainsReservedWordError_1 = require_FolderNameContainsReservedWordError();
    Object.defineProperty(exports2, "FolderNameContainsReservedWordError", { enumerable: true, get: function() {
      return FolderNameContainsReservedWordError_1.FolderNameContainsReservedWordError;
    } });
    var PinsNotFoundError_1 = require_PinsNotFoundError();
    Object.defineProperty(exports2, "PinsNotFoundError", { enumerable: true, get: function() {
      return PinsNotFoundError_1.PinsNotFoundError;
    } });
    var SiteCreationFailedError_1 = require_SiteCreationFailedError();
    Object.defineProperty(exports2, "SiteCreationFailedError", { enumerable: true, get: function() {
      return SiteCreationFailedError_1.SiteCreationFailedError;
    } });
    var FleekFunctionInvalidWasmCodeError_1 = require_FleekFunctionInvalidWasmCodeError();
    Object.defineProperty(exports2, "FleekFunctionInvalidWasmCodeError", { enumerable: true, get: function() {
      return FleekFunctionInvalidWasmCodeError_1.FleekFunctionInvalidWasmCodeError;
    } });
    var FleekFunctionWasmEncryptionFailedError_1 = require_FleekFunctionWasmEncryptionFailedError();
    Object.defineProperty(exports2, "FleekFunctionWasmEncryptionFailedError", { enumerable: true, get: function() {
      return FleekFunctionWasmEncryptionFailedError_1.FleekFunctionWasmEncryptionFailedError;
    } });
    var UploadProxyStoreAsCarError_1 = require_UploadProxyStoreAsCarError();
    Object.defineProperty(exports2, "UploadProxyStoreAsCarError", { enumerable: true, get: function() {
      return UploadProxyStoreAsCarError_1.UploadProxyStoreAsCarError;
    } });
    var UploadProxyUploadFileError_1 = require_UploadProxyUploadFileError();
    Object.defineProperty(exports2, "UploadProxyUploadFileError", { enumerable: true, get: function() {
      return UploadProxyUploadFileError_1.UploadProxyUploadFileError;
    } });
    var IpfsDenylistUpdateWorkflowTriggerFailedError_1 = require_IpfsDenylistUpdateWorkflowTriggerFailedError();
    Object.defineProperty(exports2, "IpfsDenylistUpdateWorkflowTriggerFailedError", { enumerable: true, get: function() {
      return IpfsDenylistUpdateWorkflowTriggerFailedError_1.IpfsDenylistUpdateWorkflowTriggerFailedError;
    } });
    var ProjectSiteLimitExceededError_1 = require_ProjectSiteLimitExceededError();
    Object.defineProperty(exports2, "ProjectSiteLimitExceededError", { enumerable: true, get: function() {
      return ProjectSiteLimitExceededError_1.ProjectSiteLimitExceededError;
    } });
    var ProjectFleekFunctionLimitExceededError_1 = require_ProjectFleekFunctionLimitExceededError();
    Object.defineProperty(exports2, "ProjectFleekFunctionLimitExceededError", { enumerable: true, get: function() {
      return ProjectFleekFunctionLimitExceededError_1.ProjectFleekFunctionLimitExceededError;
    } });
    var UserProjectLimitExceededError_1 = require_UserProjectLimitExceededError();
    Object.defineProperty(exports2, "UserProjectLimitExceededError", { enumerable: true, get: function() {
      return UserProjectLimitExceededError_1.UserProjectLimitExceededError;
    } });
  }
});

// node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js"(exports2, module2) {
    "use strict";
    var textDecoder = new TextDecoder();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder();
    var encodeText = (text) => textEncoder.encode(text);
    function concat(arrs, length) {
      const output2 = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrs) {
        output2.set(arr, offset);
        offset += arr.length;
      }
      return output2;
    }
    module2.exports = { decodeText, encodeText, concat };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js
var require_base2 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js"(exports2, module2) {
    "use strict";
    var { encodeText } = require_util2();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module2.exports = Base;
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js"(exports2, module2) {
    "use strict";
    var decode = (string, alphabet, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode(input, alphabet, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode(input, alphabet, bitsPerChar);
        }
      };
    };
    module2.exports = { rfc4648 };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js"(exports2, module2) {
    "use strict";
    var baseX = require_src();
    var Base = require_base2();
    var { rfc4648 } = require_rfc4648();
    var { decodeText, encodeText } = require_util2();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants2 = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc4648(1), "01"],
      ["base8", "7", rfc4648(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc4648(4), "0123456789abcdef"],
      ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants2.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants2.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names,
      codes
    };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js"(exports2, module2) {
    "use strict";
    var constants2 = require_constants2();
    var { encodeText, decodeText, concat } = require_util2();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants2.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants2.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants2.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants2.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports2 = module2.exports = multibase;
    exports2.encode = encode;
    exports2.decode = decode;
    exports2.isEncoded = isEncoded;
    exports2.encoding = encoding;
    exports2.encodingFromData = encodingFromData;
    var names = Object.freeze(constants2.names);
    var codes = Object.freeze(constants2.codes);
    exports2.names = names;
    exports2.codes = codes;
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js"(exports2, module2) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/constants.js"(exports2, module2) {
    "use strict";
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module2.exports = { names };
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function asUint8Array(buf) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      return buf;
    }
    exports2.asUint8Array = asUint8Array;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports2.alloc = alloc;
    exports2.allocUnsafe = allocUnsafe;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js"(exports2, module2) {
    "use strict";
    var basics = require("multiformats/basics");
    var alloc = require_alloc();
    function createCodec(name, prefix, encode, decode) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode
        },
        decoder: { decode }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = alloc.allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      utf8: string,
      "utf-8": string,
      hex: basics.bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...basics.bases
    };
    module2.exports = BASES;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/to-string.js
var require_to_string = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/to-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases = require_bases();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
      }
      return base.encoder.encode(array).substring(1);
    }
    exports2.toString = toString;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string, "utf-8"));
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    exports2.fromString = fromString;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js
var require_concat2 = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alloc = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output2 = alloc.allocUnsafe(length);
      let offset = 0;
      for (const arr of arrays) {
        output2.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output2);
    }
    exports2.concat = concat;
  }
});

// node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js
var require_src3 = __commonJS({
  "node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js"(exports2, module2) {
    "use strict";
    var multibase = require_src2();
    var varint = require_varint();
    var { names } = require_constants3();
    var { toString: uint8ArrayToString } = require_to_string();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var { concat: uint8ArrayConcat } = require_concat2();
    var codes = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names) {
      const name = (
        /** @type {HashName} */
        key
      );
      codes[names[name]] = name;
    }
    Object.freeze(codes);
    function toHexString(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash, "base16");
    }
    function fromHexString(hash) {
      return uint8ArrayFromString(hash, "base16");
    }
    function toB58String(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
    }
    function fromB58String(hash) {
      const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
      return multibase.decode("z" + encoded);
    }
    function decode(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = (
        /** @type {HashCode} */
        varint.decode(bytes)
      );
      if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      const len = varint.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
      };
    }
    function encode(digest, code, length) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code);
      if (!(digest instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length == null) {
        length = digest.length;
      }
      if (length && digest.length !== length) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash = varint.encode(hashfn);
      const len = varint.encode(length);
      return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);
    }
    function coerceCode(name) {
      let code = name;
      if (typeof name === "string") {
        if (names[name] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (codes[code] === void 0 && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    }
    function isAppCode(code) {
      return code > 0 && code < 16;
    }
    function isValidCode(code) {
      if (isAppCode(code)) {
        return true;
      }
      if (codes[code]) {
        return true;
      }
      return false;
    }
    function validate(multihash) {
      decode(multihash);
    }
    function prefix(multihash) {
      validate(multihash);
      return multihash.subarray(0, 2);
    }
    module2.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode,
      encode,
      coerceCode,
      isAppCode,
      validate,
      prefix,
      isValidCode
    };
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/util.js
var require_util3 = __commonJS({
  "node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/util.js"(exports2, module2) {
    "use strict";
    var varint = require_varint2();
    var { toString: uint8ArrayToString } = require_to_string();
    var { fromString: uint8ArrayFromString } = require_from_string();
    module2.exports = {
      numberToUint8Array,
      uint8ArrayToNumber,
      varintUint8ArrayEncode,
      varintEncode
    };
    function uint8ArrayToNumber(buf) {
      return parseInt(uint8ArrayToString(buf, "base16"), 16);
    }
    function numberToUint8Array(num) {
      let hexString = num.toString(16);
      if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
      }
      return uint8ArrayFromString(hexString, "base16");
    }
    function varintUint8ArrayEncode(input) {
      return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)));
    }
    function varintEncode(num) {
      return Uint8Array.from(varint.encode(num));
    }
  }
});

// node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/generated-table.js
var require_generated_table = __commonJS({
  "node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/generated-table.js"(exports2, module2) {
    "use strict";
    var baseTable = Object.freeze({
      "identity": 0,
      "cidv1": 1,
      "cidv2": 2,
      "cidv3": 3,
      "ip4": 4,
      "tcp": 6,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "dccp": 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "ip6": 41,
      "ip6zone": 42,
      "path": 47,
      "multicodec": 48,
      "multihash": 49,
      "multiaddr": 50,
      "multibase": 51,
      "dns": 53,
      "dns4": 54,
      "dns6": 55,
      "dnsaddr": 56,
      "protobuf": 80,
      "cbor": 81,
      "raw": 85,
      "dbl-sha2-256": 86,
      "rlp": 96,
      "bencode": 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      "sctp": 132,
      "dag-jose": 133,
      "dag-cose": 134,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "eth-receipt-log-trie": 153,
      "eth-reciept-log": 154,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "bitcoin-witness-commitment": 178,
      "zcash-block": 192,
      "zcash-tx": 193,
      "caip-50": 202,
      "streamid": 206,
      "stellar-block": 208,
      "stellar-tx": 209,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      "zeronet": 230,
      "secp256k1-pub": 231,
      "bls12_381-g1-pub": 234,
      "bls12_381-g2-pub": 235,
      "x25519-pub": 236,
      "ed25519-pub": 237,
      "bls12_381-g1g2-pub": 238,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      "udp": 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      "udt": 301,
      "utp": 302,
      "unix": 400,
      "thread": 406,
      "p2p": 421,
      "ipfs": 421,
      "https": 443,
      "onion": 444,
      "onion3": 445,
      "garlic64": 446,
      "garlic32": 447,
      "tls": 448,
      "noise": 454,
      "quic": 460,
      "ws": 477,
      "wss": 478,
      "p2p-websocket-star": 479,
      "http": 480,
      "swhid-1-snp": 496,
      "json": 512,
      "messagepack": 513,
      "libp2p-peer-record": 769,
      "libp2p-relay-rsvp": 770,
      "car-index-sorted": 1024,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "p256-pub": 4608,
      "p384-pub": 4609,
      "p521-pub": 4610,
      "ed448-pub": 4611,
      "x448-pub": 4612,
      "ed25519-priv": 4864,
      "secp256k1-priv": 4865,
      "x25519-priv": 4866,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082,
      "zeroxcert-imprint-256": 52753,
      "fil-commitment-unsealed": 61697,
      "fil-commitment-sealed": 61698,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332,
      "skynet-ns": 11639056,
      "arweave-ns": 11704592
    });
    module2.exports = { baseTable };
  }
});

// node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/maps.js
var require_maps = __commonJS({
  "node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/maps.js"(exports2, module2) {
    "use strict";
    var { baseTable } = require_generated_table();
    var varintEncode = require_util3().varintEncode;
    var nameToVarint = (
      /** @type {NameUint8ArrayMap} */
      {}
    );
    var constantToCode = (
      /** @type {ConstantCodeMap} */
      {}
    );
    var codeToName = (
      /** @type {CodeNameMap} */
      {}
    );
    for (const name in baseTable) {
      const codecName = (
        /** @type {CodecName} */
        name
      );
      const code = baseTable[codecName];
      nameToVarint[codecName] = varintEncode(code);
      const constant = (
        /** @type {CodecConstant} */
        codecName.toUpperCase().replace(/-/g, "_")
      );
      constantToCode[constant] = code;
      if (!codeToName[code]) {
        codeToName[code] = codecName;
      }
    }
    Object.freeze(nameToVarint);
    Object.freeze(constantToCode);
    Object.freeze(codeToName);
    var nameToCode = Object.freeze(baseTable);
    module2.exports = {
      nameToVarint,
      constantToCode,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/index.js
var require_src4 = __commonJS({
  "node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/index.js"(exports2, module2) {
    "use strict";
    var varint = require_varint2();
    var { concat: uint8ArrayConcat } = require_concat2();
    var util = require_util3();
    var { nameToVarint, constantToCode, nameToCode, codeToName } = require_maps();
    function addPrefix(multicodecStrOrCode, data) {
      let prefix;
      if (multicodecStrOrCode instanceof Uint8Array) {
        prefix = util.varintUint8ArrayEncode(multicodecStrOrCode);
      } else {
        if (nameToVarint[multicodecStrOrCode]) {
          prefix = nameToVarint[multicodecStrOrCode];
        } else {
          throw new Error("multicodec not recognized");
        }
      }
      return uint8ArrayConcat([prefix, data], prefix.length + data.length);
    }
    function rmPrefix(data) {
      varint.decode(
        /** @type {Buffer} */
        data
      );
      return data.slice(varint.decode.bytes);
    }
    function getNameFromData(prefixedData) {
      const code = (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
      const name = codeToName[code];
      if (name === void 0) {
        throw new Error(`Code "${code}" not found`);
      }
      return name;
    }
    function getNameFromCode(codec) {
      return codeToName[codec];
    }
    function getCodeFromName(name) {
      const code = nameToCode[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getCodeFromData(prefixedData) {
      return (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
    }
    function getVarintFromName(name) {
      const code = nameToVarint[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getVarintFromCode(code) {
      return util.varintEncode(code);
    }
    function getCodec(prefixedData) {
      return getNameFromData(prefixedData);
    }
    function getName(codec) {
      return getNameFromCode(codec);
    }
    function getNumber(name) {
      return getCodeFromName(name);
    }
    function getCode(prefixedData) {
      return getCodeFromData(prefixedData);
    }
    function getCodeVarint(name) {
      return getVarintFromName(name);
    }
    function getVarint(code) {
      return Array.from(getVarintFromCode(code));
    }
    module2.exports = {
      addPrefix,
      rmPrefix,
      getNameFromData,
      getNameFromCode,
      getCodeFromName,
      getCodeFromData,
      getVarintFromName,
      getVarintFromCode,
      // Deprecated
      getCodec,
      getName,
      getNumber,
      getCode,
      getCodeVarint,
      getVarint,
      // Make the constants top-level constants
      ...constantToCode,
      // Export the maps
      nameToVarint,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js
var require_cid_util = __commonJS({
  "node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js"(exports2, module2) {
    "use strict";
    var mh = require_src3();
    var CIDUtil = {
      /**
       * Test if the given input is a valid CID object.
       * Returns an error message if it is not.
       * Returns undefined if it is a valid CID.
       *
       * @param {any} other
       * @returns {string|undefined}
       */
      checkCIDComponents: function(other) {
        if (other == null) {
          return "null values are not valid CIDs";
        }
        if (!(other.version === 0 || other.version === 1)) {
          return "Invalid version, must be a number equal to 1 or 0";
        }
        if (typeof other.codec !== "string") {
          return "codec must be string";
        }
        if (other.version === 0) {
          if (other.codec !== "dag-pb") {
            return "codec must be 'dag-pb' for CIDv0";
          }
          if (other.multibaseName !== "base58btc") {
            return "multibaseName must be 'base58btc' for CIDv0";
          }
        }
        if (!(other.multihash instanceof Uint8Array)) {
          return "multihash must be a Uint8Array";
        }
        try {
          mh.validate(other.multihash);
        } catch (err) {
          let errorMsg = err.message;
          if (!errorMsg) {
            errorMsg = "Multihash validation failed";
          }
          return errorMsg;
        }
      }
    };
    module2.exports = CIDUtil;
  }
});

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/equals.js
var require_equals = __commonJS({
  "node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/equals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function equals(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.equals = equals;
  }
});

// node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/index.js
var require_src5 = __commonJS({
  "node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/index.js"(exports2, module2) {
    "use strict";
    var mh = require_src3();
    var multibase = require_src2();
    var multicodec = require_src4();
    var CIDUtil = require_cid_util();
    var { concat: uint8ArrayConcat } = require_concat2();
    var { toString: uint8ArrayToString } = require_to_string();
    var { equals: uint8ArrayEquals } = require_equals();
    var codecs = multicodec.nameToCode;
    var codecInts = (
      /** @type {CodecName[]} */
      Object.keys(codecs).reduce(
        (p, name) => {
          p[codecs[name]] = name;
          return p;
        },
        /** @type {Record<CodecCode, CodecName>} */
        {}
      )
    );
    var symbol = Symbol.for("@ipld/js-cid/CID");
    var CID3 = class _CID {
      /**
       * Create a new CID.
       *
       * The algorithm for argument input is roughly:
       * ```
       * if (cid)
       *   -> create a copy
       * else if (str)
       *   if (1st char is on multibase table) -> CID String
       *   else -> bs58 encoded multihash
       * else if (Uint8Array)
       *   if (1st byte is 0 or 1) -> CID
       *   else -> multihash
       * else if (Number)
       *   -> construct CID by parts
       * ```
       *
       * @param {CIDVersion | string | Uint8Array | CID} version
       * @param {string|number} [codec]
       * @param {Uint8Array} [multihash]
       * @param {string} [multibaseName]
       *
       * @example
       * new CID(<version>, <codec>, <multihash>, <multibaseName>)
       * new CID(<cidStr>)
       * new CID(<cid.bytes>)
       * new CID(<multihash>)
       * new CID(<bs58 encoded multihash>)
       * new CID(<cid>)
       */
      constructor(version, codec, multihash, multibaseName) {
        this.version;
        this.codec;
        this.multihash;
        Object.defineProperty(this, symbol, { value: true });
        if (_CID.isCID(version)) {
          const cid = (
            /** @type {CID} */
            version
          );
          this.version = cid.version;
          this.codec = cid.codec;
          this.multihash = cid.multihash;
          this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
          return;
        }
        if (typeof version === "string") {
          const baseName = multibase.isEncoded(version);
          if (baseName) {
            const cid = multibase.decode(version);
            this.version = /** @type {CIDVersion} */
            parseInt(cid[0].toString(), 16);
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = baseName;
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = mh.fromB58String(version);
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          Object.defineProperty(this, "string", { value: version });
          return;
        }
        if (version instanceof Uint8Array) {
          const v = parseInt(version[0].toString(), 16);
          if (v === 1) {
            const cid = version;
            this.version = v;
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = "base32";
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = version;
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          return;
        }
        this.version = version;
        if (typeof codec === "number") {
          codec = codecInts[codec];
        }
        this.codec = /** @type {CodecName} */
        codec;
        this.multihash = /** @type {Uint8Array} */
        multihash;
        this.multibaseName = multibaseName || (version === 0 ? "base58btc" : "base32");
        _CID.validateCID(this);
      }
      /**
       * The CID as a `Uint8Array`
       *
       * @returns {Uint8Array}
       *
       */
      get bytes() {
        let bytes = this._bytes;
        if (!bytes) {
          if (this.version === 0) {
            bytes = this.multihash;
          } else if (this.version === 1) {
            const codec = multicodec.getCodeVarint(this.codec);
            bytes = uint8ArrayConcat([
              [1],
              codec,
              this.multihash
            ], 1 + codec.byteLength + this.multihash.byteLength);
          } else {
            throw new Error("unsupported version");
          }
          Object.defineProperty(this, "_bytes", { value: bytes });
        }
        return bytes;
      }
      /**
       * The prefix of the CID.
       *
       * @returns {Uint8Array}
       */
      get prefix() {
        const codec = multicodec.getCodeVarint(this.codec);
        const multihash = mh.prefix(this.multihash);
        const prefix = uint8ArrayConcat([
          [this.version],
          codec,
          multihash
        ], 1 + codec.byteLength + multihash.byteLength);
        return prefix;
      }
      /**
       * The codec of the CID in its number form.
       *
       * @returns {CodecCode}
       */
      get code() {
        return codecs[this.codec];
      }
      /**
       * Convert to a CID of version `0`.
       *
       * @returns {CID}
       */
      toV0() {
        if (this.codec !== "dag-pb") {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        const { name, length } = mh.decode(this.multihash);
        if (name !== "sha2-256") {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        if (length !== 32) {
          throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
        }
        return new _CID(0, this.codec, this.multihash);
      }
      /**
       * Convert to a CID of version `1`.
       *
       * @returns {CID}
       */
      toV1() {
        return new _CID(1, this.codec, this.multihash, this.multibaseName);
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toBaseEncodedString(base = this.multibaseName) {
        if (this.string && this.string.length !== 0 && base === this.multibaseName) {
          return this.string;
        }
        let str;
        if (this.version === 0) {
          if (base !== "base58btc") {
            throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
          }
          str = mh.toB58String(this.multihash);
        } else if (this.version === 1) {
          str = uint8ArrayToString(multibase.encode(base, this.bytes));
        } else {
          throw new Error("unsupported version");
        }
        if (base === this.multibaseName) {
          Object.defineProperty(this, "string", { value: str });
        }
        return str;
      }
      /**
       * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
       *
       * @returns {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toString(base) {
        return this.toBaseEncodedString(base);
      }
      /**
       * Serialize to a plain object.
       *
       * @returns {SerializedCID}
       */
      toJSON() {
        return {
          codec: this.codec,
          version: this.version,
          hash: this.multihash
        };
      }
      /**
       * Compare equality with another CID.
       *
       * @param {CID} other
       * @returns {boolean}
       */
      equals(other) {
        return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
      }
      /**
       * Test if the given input is a valid CID object.
       * Throws if it is not.
       *
       * @param {any} other - The other CID.
       * @returns {void}
       */
      static validateCID(other) {
        const errorMsg = CIDUtil.checkCIDComponents(other);
        if (errorMsg) {
          throw new Error(errorMsg);
        }
      }
      /**
       * Check if object is a CID instance
       *
       * @param {any} value
       * @returns {value is CID}
       */
      static isCID(value) {
        return value instanceof _CID || Boolean(value && value[symbol]);
      }
    };
    CID3.codecs = codecs;
    module2.exports = CID3;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-ipfs@0.4.4/node_modules/@fleek-platform/utils-ipfs/dist/bundle.js
var require_bundle = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-ipfs@0.4.4/node_modules/@fleek-platform/utils-ipfs/dist/bundle.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var require_FleekError2 = __commonJS2({
      "../../errors/dist/FleekError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekError = void 0;
        var FleekError = class extends Error {
          // eslint-disable-next-line fleek-custom/valid-argument-types
          constructor(data) {
            super();
            this.data = data;
          }
          get message() {
            return this.toString();
          }
        };
        exports22.FleekError = FleekError;
      }
    });
    var require_BunnyPullZoneNotFoundError2 = __commonJS2({
      "../../errors/dist/BunnyPullZoneNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.BunnyPullZoneNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var BunnyPullZoneNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "BunnyPullZoneNotFoundError";
            this.toString = () => `PullZone with name ${this.data.name} was not found on BunnyCDN.`;
          }
        };
        exports22.BunnyPullZoneNotFoundError = BunnyPullZoneNotFoundError;
      }
    });
    var require_DomainNotFoundError2 = __commonJS2({
      "../../errors/dist/DomainNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainNotFoundError";
            this.toString = () => {
              if (this.data.domain.hostname) {
                return `Domain ${this.data.domain.hostname} was not found.`;
              }
              return "Domain was not found.";
            };
          }
        };
        exports22.DomainNotFoundError = DomainNotFoundError;
      }
    });
    var require_DomainsNotFoundError2 = __commonJS2({
      "../../errors/dist/DomainsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainsNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "DomainsNotFoundError";
            this.toString = () => "No domains found.";
          }
        };
        exports22.DomainsNotFoundError = DomainsNotFoundError2;
      }
    });
    var require_DomainAlreadyExistsInProjectError2 = __commonJS2({
      "../../errors/dist/DomainAlreadyExistsInProjectError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainAlreadyExistsInProjectError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainAlreadyExistsInProjectError";
            this.toString = () => {
              return `Domain ${this.data.domain.hostname} already exists under the project.`;
            };
          }
        };
        exports22.DomainAlreadyExistsInProjectError = DomainAlreadyExistsInProjectError;
      }
    });
    var require_DomainInPendingStateError2 = __commonJS2({
      "../../errors/dist/DomainInPendingStateError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainInPendingStateError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainInPendingStateError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainInPendingStateError";
            this.toString = () => {
              return "Domain is in pending state. Please wait and try action again later.";
            };
          }
        };
        exports22.DomainInPendingStateError = DomainInPendingStateError;
      }
    });
    var require_DomainHostnameInvalidError2 = __commonJS2({
      "../../errors/dist/DomainHostnameInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainHostnameInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainHostnameInvalidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainHostnameInvalidError";
            this.toString = () => {
              return `The domain ${this.data.hostname} is invalid`;
            };
          }
        };
        exports22.DomainHostnameInvalidError = DomainHostnameInvalidError2;
      }
    });
    var require_UnknownError2 = __commonJS2({
      "../../errors/dist/UnknownError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UnknownError = void 0;
        var FleekError_1 = require_FleekError2();
        var UnknownError2 = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UnknownError";
            this.toString = () => `Unexpected error. Repeat the action or contact support.`;
          }
        };
        exports22.UnknownError = UnknownError2;
      }
    });
    var require_SiteNotFoundError2 = __commonJS2({
      "../../errors/dist/SiteNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteNotFoundError";
            this.toString = () => {
              if (this.data.site.slug) {
                return `Site ${this.data.site.slug} not found.`;
              }
              return `Site not found.`;
            };
          }
        };
        exports22.SiteNotFoundError = SiteNotFoundError;
      }
    });
    var require_SitesNotFoundError2 = __commonJS2({
      "../../errors/dist/SitesNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SitesNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SitesNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "SitesNotFoundError";
            this.toString = () => "No sites found.";
          }
        };
        exports22.SitesNotFoundError = SitesNotFoundError2;
      }
    });
    var require_SiteAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/SiteAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteAlreadyExistsError";
            this.toString = () => {
              if ("name" in this.data.site) {
                return `Site ${this.data.site.name} already exists in the project.`;
              }
              return `Site slug must be unique within Fleek but ${this.data.site.slug} already exists.`;
            };
          }
        };
        exports22.SiteAlreadyExistsError = SiteAlreadyExistsError;
      }
    });
    var require_SiteDeploymentNotFoundError2 = __commonJS2({
      "../../errors/dist/SiteDeploymentNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteDeploymentNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteDeploymentNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteDeploymentNotFoundError";
            this.toString = () => `Deployment not found.`;
          }
        };
        exports22.SiteDeploymentNotFoundError = SiteDeploymentNotFoundError;
      }
    });
    var require_SiteHasDependentsError2 = __commonJS2({
      "../../errors/dist/SiteHasDependentsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteHasDependentsError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteHasDependentsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteHasDependentsError";
            this.toString = () => {
              const dependentsInfo = [];
              if (this.data.domains.length > 0) {
                dependentsInfo.push(`${this.data.domains.length} domains`);
              }
              if (this.data.ipnsRecords.length > 0) {
                dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
              }
              return `Site has assigned ${dependentsInfo}. You have to delete them first.`;
            };
          }
        };
        exports22.SiteHasDependentsError = SiteHasDependentsError;
      }
    });
    var require_SiteHasNoSourceProviderError2 = __commonJS2({
      "../../errors/dist/SiteHasNoSourceProviderError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteHasNoSourceProviderError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteHasNoSourceProviderError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteHasNoSourceProviderError";
            this.toString = () => {
              if (this.data.site.slug) {
                return `Site ${this.data.site.slug} does not have a source provider.`;
              }
              return `Site does not have a source provider.`;
            };
          }
        };
        exports22.SiteHasNoSourceProviderError = SiteHasNoSourceProviderError;
      }
    });
    var require_SiteNotDeployedError2 = __commonJS2({
      "../../errors/dist/SiteNotDeployedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteNotDeployedError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteNotDeployedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteNotDeployedError";
            this.toString = () => {
              if (this.data.site.slug) {
                return `Site ${this.data.site.slug} does not have released deployments.`;
              }
              return `Site does not have released deployments.`;
            };
          }
        };
        exports22.SiteNotDeployedError = SiteNotDeployedError;
      }
    });
    var require_IpnsRecordNotFoundError2 = __commonJS2({
      "../../errors/dist/IpnsRecordNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpnsRecordNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpnsRecordNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "IpnsRecordNotFoundError";
            this.toString = () => `IPNS record not found.`;
          }
        };
        exports22.IpnsRecordNotFoundError = IpnsRecordNotFoundError;
      }
    });
    var require_IpnsRecordsNotFoundError2 = __commonJS2({
      "../../errors/dist/IpnsRecordsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpnsRecordsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpnsRecordsNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "IpnsRecordsNotFoundError";
            this.toString = () => "No IPNS records found.";
          }
        };
        exports22.IpnsRecordsNotFoundError = IpnsRecordsNotFoundError2;
      }
    });
    var require_IpnsFailToDecryptKeyError2 = __commonJS2({
      "../../errors/dist/IpnsFailToDecryptKeyError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpnsFailToDecryptKeyError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpnsFailToDecryptKeyError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "IpnsFailToDecryptKeyError";
            this.toString = () => `Failed to decrypt IPNS key.`;
          }
        };
        exports22.IpnsFailToDecryptKeyError = IpnsFailToDecryptKeyError;
      }
    });
    var require_IpnsRecordsForSiteLimitError2 = __commonJS2({
      "../../errors/dist/IpnsRecordsForSiteLimitError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpnsRecordsForSiteLimitError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpnsRecordsForSiteLimitError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "IpnsRecordsForSiteLimitError";
            this.toString = () => {
              if (this.data.site.name) {
                return `Maximum amount of IPNS records that may be assigned to the ${this.data.site.name} site was exceeded.`;
              }
              return `Maximum amount of IPNS records that may be assigned to the site was exceeded.`;
            };
          }
        };
        exports22.IpnsRecordsForSiteLimitError = IpnsRecordsForSiteLimitError;
      }
    });
    var require_StorageIpfsUploadFailedError2 = __commonJS2({
      "../../errors/dist/StorageIpfsUploadFailedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.StorageIpfsUploadFailedError = void 0;
        var FleekError_1 = require_FleekError2();
        var StorageIpfsUploadFailedError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "StorageIpfsUploadFailedError";
            this.toString = () => `Upload failed.`;
          }
        };
        exports22.StorageIpfsUploadFailedError = StorageIpfsUploadFailedError;
      }
    });
    var require_SdkRequiredNodeRuntimeError2 = __commonJS2({
      "../../errors/dist/SdkRequiredNodeRuntimeError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SdkRequiredNodeRuntimeError = void 0;
        var FleekError_1 = require_FleekError2();
        var SdkRequiredNodeRuntimeError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "SdkRequiredNodeRuntimeError";
            this.toString = () => `The functionality of this SDK feature is dependent on the Node.js runtime.`;
          }
        };
        exports22.SdkRequiredNodeRuntimeError = SdkRequiredNodeRuntimeError;
      }
    });
    var require_AuthorizationError2 = __commonJS2({
      "../../errors/dist/AuthorizationError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.AuthorizationError = void 0;
        var FleekError_1 = require_FleekError2();
        var AuthorizationError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "AuthorizationError";
            this.toString = () => `Authorization with provided credentials is invalid.`;
          }
        };
        exports22.AuthorizationError = AuthorizationError;
      }
    });
    var require_ProjectMembershipNotFoundError2 = __commonJS2({
      "../../errors/dist/ProjectMembershipNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectMembershipNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectMembershipNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectMembershipNotFoundError";
            this.toString = () => `Membership not found for project.`;
          }
        };
        exports22.ProjectMembershipNotFoundError = ProjectMembershipNotFoundError;
      }
    });
    var require_GithubAppInstallationNotFoundError2 = __commonJS2({
      "../../errors/dist/GithubAppInstallationNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GithubAppInstallationNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var GithubAppInstallationNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GithubAppInstallationNotFoundError";
            this.toString = () => {
              return "No GitHub App installation found for given project.";
            };
          }
        };
        exports22.GithubAppInstallationNotFoundError = GithubAppInstallationNotFoundError;
      }
    });
    var require_UserNotFoundError2 = __commonJS2({
      "../../errors/dist/UserNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UserNotFoundError";
            this.toString = () => {
              if (this.data.email) {
                return `User with email ${this.data.email} not found.`;
              }
              return `User not found.`;
            };
          }
        };
        exports22.UserNotFoundError = UserNotFoundError;
      }
    });
    var require_UserAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/UserAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UserAlreadyExistsError";
            this.toString = () => "The username is already in use, please select another one";
          }
        };
        exports22.UserAlreadyExistsError = UserAlreadyExistsError;
      }
    });
    var require_ProjectNotFoundError2 = __commonJS2({
      "../../errors/dist/ProjectNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectNotFoundError";
            this.toString = () => "Project not found.";
          }
        };
        exports22.ProjectNotFoundError = ProjectNotFoundError;
      }
    });
    var require_ProjectsNotFoundError2 = __commonJS2({
      "../../errors/dist/ProjectsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectsNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "ProjectsNotFoundError";
            this.toString = () => "No projects found.";
          }
        };
        exports22.ProjectsNotFoundError = ProjectsNotFoundError2;
      }
    });
    var require_ProjectHasDependentsError2 = __commonJS2({
      "../../errors/dist/ProjectHasDependentsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectHasDependentsError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectHasDependentsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectHasDependentsError";
            this.toString = () => {
              const dependentsInfo = [];
              if (this.data.sites.length > 0) {
                dependentsInfo.push(`${this.data.sites.length} sites`);
              }
              if (this.data.privateGateways.length > 0) {
                dependentsInfo.push(`${this.data.privateGateways.length} private gateways`);
              }
              if (this.data.ipnsRecords.length > 0) {
                dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
              }
              return `Project has assigned ${dependentsInfo.join(", ")}. You have to delete them first.`;
            };
          }
        };
        exports22.ProjectHasDependentsError = ProjectHasDependentsError;
      }
    });
    var require_ProjectInvalidNameError2 = __commonJS2({
      "../../errors/dist/ProjectInvalidNameError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectInvalidNameError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectInvalidNameError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectInvalidNameError";
            this.toString = () => `The project name ${this.data.name} is invalid.`;
          }
        };
        exports22.ProjectInvalidNameError = ProjectInvalidNameError2;
      }
    });
    var require_PublicKeyAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/PublicKeyAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PublicKeyAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var PublicKeyAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PublicKeyAlreadyExistsError";
            this.toString = () => `Public key already exists.`;
          }
        };
        exports22.PublicKeyAlreadyExistsError = PublicKeyAlreadyExistsError;
      }
    });
    var require_VerificationSessionAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/VerificationSessionAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.VerificationSessionAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var VerificationSessionAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "VerificationSessionAlreadyExistsError";
            this.toString = () => `Verification session already exists.`;
          }
        };
        exports22.VerificationSessionAlreadyExistsError = VerificationSessionAlreadyExistsError;
      }
    });
    var require_UnauthenticatedError2 = __commonJS2({
      "../../errors/dist/UnauthenticatedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UnauthenticatedError = void 0;
        var FleekError_1 = require_FleekError2();
        var UnauthenticatedError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UnauthenticatedError";
            this.toString = () => `The request is not authenticated.`;
          }
        };
        exports22.UnauthenticatedError = UnauthenticatedError;
      }
    });
    var require_DomainZoneNotFoundError2 = __commonJS2({
      "../../errors/dist/DomainZoneNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainZoneNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainZoneNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainZoneNotFoundError";
            this.toString = () => {
              return "Domain zone not found.";
            };
          }
        };
        exports22.DomainZoneNotFoundError = DomainZoneNotFoundError;
      }
    });
    var require_DomainZoneHasDependentsError2 = __commonJS2({
      "../../errors/dist/DomainZoneHasDependentsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainZoneHasDependentsError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainZoneHasDependentsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainZoneHasDependentsError";
            this.toString = () => "Domain zone has assigned domains or private gateways. You have to delete them first.";
          }
        };
        exports22.DomainZoneHasDependentsError = DomainZoneHasDependentsError;
      }
    });
    var require_DomainZoneInPendingStateError2 = __commonJS2({
      "../../errors/dist/DomainZoneInPendingStateError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainZoneInPendingStateError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainZoneInPendingStateError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ZoneInPendingStateError";
            this.toString = () => {
              return "Domain zone is in pending state. Please wait and try action again later.";
            };
          }
        };
        exports22.DomainZoneInPendingStateError = DomainZoneInPendingStateError;
      }
    });
    var require_DomainNotFoundUnderPullzoneError2 = __commonJS2({
      "../../errors/dist/DomainNotFoundUnderPullzoneError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainNotFoundUnderPullzoneError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainNotFoundUnderPullzoneError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainNotFoundUnderPullzoneError";
            this.toString = () => {
              return "Domain zone not found.";
            };
          }
        };
        exports22.DomainNotFoundUnderPullzoneError = DomainNotFoundUnderPullzoneError;
      }
    });
    var require_DomainZoneInvalidTypeError2 = __commonJS2({
      "../../errors/dist/DomainZoneInvalidTypeError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DomainZoneInvalidTypeError = void 0;
        var FleekError_1 = require_FleekError2();
        var DomainZoneInvalidTypeError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DomainZoneInvalidTypeError";
            this.toString = () => "Domain zone has different purpose of use.";
          }
        };
        exports22.DomainZoneInvalidTypeError = DomainZoneInvalidTypeError;
      }
    });
    var require_UnauthorizedError2 = __commonJS2({
      "../../errors/dist/UnauthorizedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UnauthorizedError = void 0;
        var FleekError_1 = require_FleekError2();
        var UnauthorizedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UnauthorizedError";
            this.toString = () => {
              if (this.data.scopes) {
                return `You are not authorized to access this resource because of missing permissions: ${this.data.scopes.join(", ")}.`;
              }
              return `You are not authorized to access this resource.`;
            };
          }
        };
        exports22.UnauthorizedError = UnauthorizedError;
      }
    });
    var require_FleekConfigInvalidContentError2 = __commonJS2({
      "../../errors/dist/FleekConfigInvalidContentError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekConfigInvalidContentError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekConfigInvalidContentError4 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekConfigInvalidContentError";
            this.toString = () => {
              if (this.data.validationResult) {
                return `Validation of loaded ${this.data.configPath} failed. ${this.data.validationResult}`;
              }
              return `Loaded ${this.data.configPath} file is corrupted.`;
            };
          }
        };
        exports22.FleekConfigInvalidContentError = FleekConfigInvalidContentError4;
      }
    });
    var require_FleekConfigMissingFileError2 = __commonJS2({
      "../../errors/dist/FleekConfigMissingFileError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekConfigMissingFileError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekConfigMissingFileError4 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekConfigMissingFileError";
            this.toString = () => {
              return `Unable to access or find the configuration file${this.data.configPath && " " + this.data.configPath + "." || "."}`;
            };
          }
        };
        exports22.FleekConfigMissingFileError = FleekConfigMissingFileError4;
      }
    });
    var require_ApplicationWhitelistDomainDuplicityError2 = __commonJS2({
      "../../errors/dist/ApplicationWhitelistDomainDuplicityError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ApplicationWhitelistDomainDuplicityError = void 0;
        var FleekError_1 = require_FleekError2();
        var ApplicationWhitelistDomainDuplicityError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ApplicationWhitelistDomainDuplicityError";
            this.toString = () => `Application ${this.data.application.name} doesn't have unique white label domains.`;
          }
        };
        exports22.ApplicationWhitelistDomainDuplicityError = ApplicationWhitelistDomainDuplicityError;
      }
    });
    var require_ApplicationAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/ApplicationAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ApplicationAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var ApplicationAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ApplicationAlreadyExistsError";
            this.toString = () => `Application ${this.data.application.name} already exists.`;
          }
        };
        exports22.ApplicationAlreadyExistsError = ApplicationAlreadyExistsError;
      }
    });
    var require_ApplicationsNotFoundError2 = __commonJS2({
      "../../errors/dist/ApplicationsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ApplicationsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var ApplicationsNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ApplicationsNotFoundError";
            this.toString = () => "No applications found.";
          }
        };
        exports22.ApplicationsNotFoundError = ApplicationsNotFoundError2;
      }
    });
    var require_ApplicationNotFoundError2 = __commonJS2({
      "../../errors/dist/ApplicationNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ApplicationNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var ApplicationNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ApplicationNotFoundError";
            this.toString = () => "Application not found.";
          }
        };
        exports22.ApplicationNotFoundError = ApplicationNotFoundError;
      }
    });
    var require_ApplicationNameInvalidError2 = __commonJS2({
      "../../errors/dist/ApplicationNameInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ApplicationNameInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var ApplicationNameInvalidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ApplicationNameInvalidError";
            this.toString = () => `The application name ${this.data.name} is invalid.`;
          }
        };
        exports22.ApplicationNameInvalidError = ApplicationNameInvalidError2;
      }
    });
    var require_EnsRecordNotFoundError2 = __commonJS2({
      "../../errors/dist/EnsRecordNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsRecordNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsRecordNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsRecordNotFoundError";
            this.toString = () => {
              if (this.data.site?.id) {
                return `No site associated with this ENS record.`;
              }
              return `ENS record was not found.`;
            };
          }
        };
        exports22.EnsRecordNotFoundError = EnsRecordNotFoundError2;
      }
    });
    var require_EnsRecordAlreadyExistsInProjectError2 = __commonJS2({
      "../../errors/dist/EnsRecordAlreadyExistsInProjectError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsRecordAlreadyExistsInProjectError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsRecordAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsRecordAlreadyExistsInProjectError";
            this.toString = () => {
              return `ENS record already exists under the project.`;
            };
          }
        };
        exports22.EnsRecordAlreadyExistsInProjectError = EnsRecordAlreadyExistsInProjectError;
      }
    });
    var require_EnsNameInvalidError2 = __commonJS2({
      "../../errors/dist/EnsNameInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsNameInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsNameInvalidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsNameInvalidError";
            this.toString = () => {
              return `ENS record name "${this.data.ensRecord.name}" is invalid.`;
            };
          }
        };
        exports22.EnsNameInvalidError = EnsNameInvalidError2;
      }
    });
    var require_EnsRecordInPendingStateError2 = __commonJS2({
      "../../errors/dist/EnsRecordInPendingStateError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsRecordInPendingStateError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsRecordInPendingStateError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsRecordInPendingStateError";
            this.toString = () => {
              return "ENS Record is in pending state. Please wait and try action again later.";
            };
          }
        };
        exports22.EnsRecordInPendingStateError = EnsRecordInPendingStateError;
      }
    });
    var require_InvalidPersonalAccessTokenError2 = __commonJS2({
      "../../errors/dist/InvalidPersonalAccessTokenError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidPersonalAccessTokenError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidPersonalAccessTokenError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidPersonalAccessTokenError";
            this.toString = () => "Personal access token is invalid.";
          }
        };
        exports22.InvalidPersonalAccessTokenError = InvalidPersonalAccessTokenError;
      }
    });
    var require_PersonalAccessTokenNotFoundError2 = __commonJS2({
      "../../errors/dist/PersonalAccessTokenNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PersonalAccessTokenNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PersonalAccessTokenNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PersonalAccessTokenNotFoundError";
            this.toString = () => `Personal access token with ID ${this.data.personalAccessToken.id} not found.`;
          }
        };
        exports22.PersonalAccessTokenNotFoundError = PersonalAccessTokenNotFoundError;
      }
    });
    var require_PrivateGatewayNotFoundError2 = __commonJS2({
      "../../errors/dist/PrivateGatewayNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PrivateGatewayNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PrivateGatewayNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PrivateGatewayNotFoundError";
            this.toString = () => `Private gateway not found.`;
          }
        };
        exports22.PrivateGatewayNotFoundError = PrivateGatewayNotFoundError;
      }
    });
    var require_PrivateGatewayAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/PrivateGatewayAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PrivateGatewayAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var PrivateGatewayAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PrivateGatewayAlreadyExistsError";
            this.toString = () => `Private gateway already exists. Please choose different name for the private gateway.`;
          }
        };
        exports22.PrivateGatewayAlreadyExistsError = PrivateGatewayAlreadyExistsError;
      }
    });
    var require_PrivateGatewayNameInvalidError2 = __commonJS2({
      "../../errors/dist/PrivateGatewayNameInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PrivateGatewayNameInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var PrivateGatewayNameInvalidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PrivateGatewayNameInvalidError";
            this.toString = () => `The private gateway name ${this.data.name} is invalid.`;
          }
        };
        exports22.PrivateGatewayNameInvalidError = PrivateGatewayNameInvalidError2;
      }
    });
    var require_PrivateGatewaysNotFoundError2 = __commonJS2({
      "../../errors/dist/PrivateGatewaysNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PrivateGatewaysNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PrivateGatewaysNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PrivateGatewaysNotFoundError";
            this.toString = () => "No private gateways found.";
          }
        };
        exports22.PrivateGatewaysNotFoundError = PrivateGatewaysNotFoundError2;
      }
    });
    var require_TemplateAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/TemplateAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TemplateAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var TemplateAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TemplateAlreadyExistsError";
            this.toString = () => `Template already exists.`;
          }
        };
        exports22.TemplateAlreadyExistsError = TemplateAlreadyExistsError;
      }
    });
    var require_TemplateNotFoundError2 = __commonJS2({
      "../../errors/dist/TemplateNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TemplateNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var TemplateNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TemplateNotFoundError";
            this.toString = () => `Template not found.`;
          }
        };
        exports22.TemplateNotFoundError = TemplateNotFoundError;
      }
    });
    var require_UserHasNoAccessToAnotherUserError2 = __commonJS2({
      "../../errors/dist/UserHasNoAccessToAnotherUserError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserHasNoAccessToAnotherUserError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserHasNoAccessToAnotherUserError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UserHasNoAccessToAnotherUserError";
            this.toString = () => "You don`t have access to user you try to fetch data for.";
          }
        };
        exports22.UserHasNoAccessToAnotherUserError = UserHasNoAccessToAnotherUserError;
      }
    });
    var require_SiteFrameworkAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/SiteFrameworkAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteFrameworkAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteFrameworkAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteFrameworkAlreadyExistsError";
            this.toString = () => `Site framework already exists.`;
          }
        };
        exports22.SiteFrameworkAlreadyExistsError = SiteFrameworkAlreadyExistsError;
      }
    });
    var require_SiteFrameworkNotFoundError2 = __commonJS2({
      "../../errors/dist/SiteFrameworkNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteFrameworkNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteFrameworkNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteFrameworkNotFoundError";
            this.toString = () => `Site framework not found.`;
          }
        };
        exports22.SiteFrameworkNotFoundError = SiteFrameworkNotFoundError;
      }
    });
    var require_TemplateCategoryNotFoundError2 = __commonJS2({
      "../../errors/dist/TemplateCategoryNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TemplateCategoryNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var TemplateCategoryNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TemplateCategoryNotFoundError";
            this.toString = () => `Template category not found.`;
          }
        };
        exports22.TemplateCategoryNotFoundError = TemplateCategoryNotFoundError;
      }
    });
    var require_TemplateDeploymentNotFoundError2 = __commonJS2({
      "../../errors/dist/TemplateDeploymentNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TemplateDeploymentNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var TemplateDeploymentNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TemplateDeploymentNotFoundError";
            this.toString = () => `Template deployment not found.`;
          }
        };
        exports22.TemplateDeploymentNotFoundError = TemplateDeploymentNotFoundError;
      }
    });
    var require_ProjectMembershipHasInefficientRoleError2 = __commonJS2({
      "../../errors/dist/ProjectMembershipHasInefficientRoleError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectMembershipHasInefficientRoleError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectMembershipHasInefficientRoleError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectMembershipHasInefficientRoleError";
            this.toString = () => `Membership has inefficient role for this action.`;
          }
        };
        exports22.ProjectMembershipHasInefficientRoleError = ProjectMembershipHasInefficientRoleError;
      }
    });
    var require_SecretGroupNotFoundError2 = __commonJS2({
      "../../errors/dist/SecretGroupNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SecretGroupNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SecretGroupNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SecretGroupNotFoundError";
            this.toString = () => {
              return "Secret group was not found.";
            };
          }
        };
        exports22.SecretGroupNotFoundError = SecretGroupNotFoundError;
      }
    });
    var require_SecretNotFoundError2 = __commonJS2({
      "../../errors/dist/SecretNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SecretNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var SecretNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SecretNotFoundError";
            this.toString = () => {
              return "Secret was not found.";
            };
          }
        };
        exports22.SecretNotFoundError = SecretNotFoundError;
      }
    });
    var require_SecretVisibilityAlreadyEncryptedError2 = __commonJS2({
      "../../errors/dist/SecretVisibilityAlreadyEncryptedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SecretVisibilityAlreadyEncryptedError = void 0;
        var FleekError_1 = require_FleekError2();
        var SecretVisibilityAlreadyEncryptedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SecretVisibilityAlreadyEncryptedError";
            this.toString = () => {
              return "You cannot change visibility of already encrypted secret.";
            };
          }
        };
        exports22.SecretVisibilityAlreadyEncryptedError = SecretVisibilityAlreadyEncryptedError;
      }
    });
    var require_SecretKeyAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/SecretKeyAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SecretKeyAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var SecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SecretKeyAlreadyExistsError";
            this.toString = () => {
              return "Variable with this key is already set.";
            };
          }
        };
        exports22.SecretKeyAlreadyExistsError = SecretKeyAlreadyExistsError;
      }
    });
    var require_SecretFailToEncryptError2 = __commonJS2({
      "../../errors/dist/SecretFailToEncryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SecretFailToEncryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var SecretFailToEncryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SecretFailToEncryptError";
            this.toString = () => {
              return "Failed to encrypt secret.";
            };
          }
        };
        exports22.SecretFailToEncryptError = SecretFailToEncryptError;
      }
    });
    var require_PinNotFoundError2 = __commonJS2({
      "../../errors/dist/PinNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PinNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PinNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PinNotFoundError";
            this.toString = () => {
              return "Pin was not found.";
            };
          }
        };
        exports22.PinNotFoundError = PinNotFoundError;
      }
    });
    var require_PinAlreadyExistsInProjectError2 = __commonJS2({
      "../../errors/dist/PinAlreadyExistsInProjectError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PinAlreadyExistsInProjectError = void 0;
        var FleekError_1 = require_FleekError2();
        var PinAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PinAlreadyExistsInProjectError";
            this.toString = () => {
              return `Pin with the same '${this.data.pin.cid ? "cid" : "path"}' already exists within the project.`;
            };
          }
        };
        exports22.PinAlreadyExistsInProjectError = PinAlreadyExistsInProjectError;
      }
    });
    var require_UnstoppableDeploymentError2 = __commonJS2({
      "../../errors/dist/UnstoppableDeploymentError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UnstoppableDeploymentError = void 0;
        var FleekError_1 = require_FleekError2();
        var UnstoppableDeploymentError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UnstoppableDeploymentError";
            this.toString = () => `Deployment cannot be stopped.`;
          }
        };
        exports22.UnstoppableDeploymentError = UnstoppableDeploymentError;
      }
    });
    var require_SiteDeploymentNotReleasedError2 = __commonJS2({
      "../../errors/dist/SiteDeploymentNotReleasedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteDeploymentNotReleasedError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteDeploymentNotReleasedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "SiteDeploymentNotReleasedError";
            this.toString = () => `Deployment not released.`;
          }
        };
        exports22.SiteDeploymentNotReleasedError = SiteDeploymentNotReleasedError;
      }
    });
    var require_InvalidDeploymentTriggerError2 = __commonJS2({
      "../../errors/dist/InvalidDeploymentTriggerError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidDeploymentTriggerError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidDeploymentTriggerError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidDeploymentTriggerError";
            this.toString = () => `Deployment can not be triggered, source provider integrations missing.`;
          }
        };
        exports22.InvalidDeploymentTriggerError = InvalidDeploymentTriggerError;
      }
    });
    var require_IpfsGatewayContentUnreachableError2 = __commonJS2({
      "../../errors/dist/IpfsGatewayContentUnreachableError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpfsGatewayContentUnreachableError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpfsGatewayContentUnreachableError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "IpfsGatewayContentUnreachableError";
            this.toString = () => "Cannot get IPFS content through Fleek gateway.";
          }
        };
        exports22.IpfsGatewayContentUnreachableError = IpfsGatewayContentUnreachableError;
      }
    });
    var require_InvitationNotFoundError2 = __commonJS2({
      "../../errors/dist/InvitationNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvitationNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvitationNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvitationNotFoundError";
            this.toString = () => {
              return "Invitation was not found.";
            };
          }
        };
        exports22.InvitationNotFoundError = InvitationNotFoundError;
      }
    });
    var require_MigrationTokenInvalidError2 = __commonJS2({
      "../../errors/dist/MigrationTokenInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MigrationTokenInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var MigrationTokenInvalidError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MigrationTokenInvalidError";
            this.toString = () => "Migration token is invalid or expired.";
          }
        };
        exports22.MigrationTokenInvalidError = MigrationTokenInvalidError;
      }
    });
    var require_MigrationRequestsAlreadyExistError2 = __commonJS2({
      "../../errors/dist/MigrationRequestsAlreadyExistError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MigrationRequestsAlreadyExistError = void 0;
        var FleekError_1 = require_FleekError2();
        var MigrationRequestsAlreadyExistError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MigrationRequestsAlreadyExistError";
            this.toString = () => `All migration requests specified in token are either completed or in progress.`;
          }
        };
        exports22.MigrationRequestsAlreadyExistError = MigrationRequestsAlreadyExistError;
      }
    });
    var require_MigrationRequestNotFoundError2 = __commonJS2({
      "../../errors/dist/MigrationRequestNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MigrationRequestNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var MigrationRequestNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MigrationRequestNotFoundError";
            this.toString = () => `Migration request ${this.data.migrationRequest.id} not found.`;
          }
        };
        exports22.MigrationRequestNotFoundError = MigrationRequestNotFoundError;
      }
    });
    var require_MigrationRequestInPendingStateError2 = __commonJS2({
      "../../errors/dist/MigrationRequestInPendingStateError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MigrationRequestInPendingStateError = void 0;
        var FleekError_1 = require_FleekError2();
        var MigrationRequestInPendingStateError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MigrationRequestInPendingStateError";
            this.toString = () => "Migration request is in pending state. Please wait and try action again later.";
          }
        };
        exports22.MigrationRequestInPendingStateError = MigrationRequestInPendingStateError;
      }
    });
    var require_ProjectInvitationAlreadyExistError2 = __commonJS2({
      "../../errors/dist/ProjectInvitationAlreadyExistError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectInvitationAlreadyExistError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectInvitationAlreadyExistError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectInvitationAlreadyExistError";
            this.toString = () => `Project invitation with email ${this.data.user.email} for this project already exist.`;
          }
        };
        exports22.ProjectInvitationAlreadyExistError = ProjectInvitationAlreadyExistError;
      }
    });
    var require_ProjectMembershipAlreadyExistError2 = __commonJS2({
      "../../errors/dist/ProjectMembershipAlreadyExistError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectMembershipAlreadyExistError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectMembershipAlreadyExistError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectMembershipAlreadyExistError";
            this.toString = () => `Project membership already exists.`;
          }
        };
        exports22.ProjectMembershipAlreadyExistError = ProjectMembershipAlreadyExistError;
      }
    });
    var require_ProjectMembershipNoOwnersError2 = __commonJS2({
      "../../errors/dist/ProjectMembershipNoOwnersError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectMembershipNoOwnersError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectMembershipNoOwnersError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectMembershipNoOwnersError";
            this.toString = () => `Each project must have at least OWNER-role one membership.`;
          }
        };
        exports22.ProjectMembershipNoOwnersError = ProjectMembershipNoOwnersError;
      }
    });
    var require_UploadedS3KeyNotFoundError2 = __commonJS2({
      "../../errors/dist/UploadedS3KeyNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UploadedS3KeyNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var UploadedS3KeyNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UploadedS3KeyNotFoundError";
            this.toString = () => "Uploaded S3 Key not found.";
          }
        };
        exports22.UploadedS3KeyNotFoundError = UploadedS3KeyNotFoundError;
      }
    });
    var require_PathIsNotADirectoryError2 = __commonJS2({
      "../../errors/dist/PathIsNotADirectoryError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PathIsNotADirectoryError = void 0;
        var FleekError_1 = require_FleekError2();
        var PathIsNotADirectoryError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PathIsNotADirectoryError";
            this.toString = () => {
              return `Given path ${this.data.path} is not a directory.`;
            };
          }
        };
        exports22.PathIsNotADirectoryError = PathIsNotADirectoryError;
      }
    });
    var require_FleekFunctionAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/FleekFunctionAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionAlreadyExistsError";
            this.toString = () => {
              if ("name" in this.data.function || "slug" in this.data.function) {
                return `Function ${this.data.function.name || this.data.function.slug} already exists.`;
              }
              return `Unexpected Function data structure ${JSON.stringify(this.data.function)}`;
            };
          }
        };
        exports22.FleekFunctionAlreadyExistsError = FleekFunctionAlreadyExistsError;
      }
    });
    var require_FleekFunctionNotFoundError2 = __commonJS2({
      "../../errors/dist/FleekFunctionNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionNotFoundError";
            this.toString = () => {
              if (this.data.function?.name) {
                return `Function ${this.data.function.name} not found.`;
              }
              return `Function not found.`;
            };
          }
        };
        exports22.FleekFunctionNotFoundError = FleekFunctionNotFoundError;
      }
    });
    var require_FleekFunctionDeploymentNotFoundError2 = __commonJS2({
      "../../errors/dist/FleekFunctionDeploymentNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionDeploymentNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionDeploymentNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionDeploymentNotFoundError";
            this.toString = () => {
              return `Deployment not found.`;
            };
          }
        };
        exports22.FleekFunctionDeploymentNotFoundError = FleekFunctionDeploymentNotFoundError;
      }
    });
    var require_FleekFunctionsNotFoundError2 = __commonJS2({
      "../../errors/dist/FleekFunctionsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionsNotFoundError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionsNotFoundError";
            this.toString = () => "No functions found.";
          }
        };
        exports22.FleekFunctionsNotFoundError = FleekFunctionsNotFoundError2;
      }
    });
    var require_FleekFunctionPathNotValidError2 = __commonJS2({
      "../../errors/dist/FleekFunctionPathNotValidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionPathNotValidError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionPathNotValidError4 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionPathNotValidError";
            this.toString = () => {
              return `File or folder at path, ${this.data.path} is invalid. Please refer to our documentation for more information on function file conventions.`;
            };
          }
        };
        exports22.FleekFunctionPathNotValidError = FleekFunctionPathNotValidError4;
      }
    });
    var require_FleekFunctionNameNotValidError2 = __commonJS2({
      "../../errors/dist/FleekFunctionNameNotValidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionNameNotValidError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionNameNotValidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionNameNotValidError";
            this.toString = () => {
              return `The name, ${this.data.name}, is invalid`;
            };
          }
        };
        exports22.FleekFunctionNameNotValidError = FleekFunctionNameNotValidError2;
      }
    });
    var require_FleekFunctionStatusNotValidError2 = __commonJS2({
      "../../errors/dist/FleekFunctionStatusNotValidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionStatusNotValidError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionStatusNotValidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionStatusNotValidError";
            this.toString = () => {
              return `The function status is invalid. Must be one of ACTIVE and INACTIVE`;
            };
          }
        };
        exports22.FleekFunctionStatusNotValidError = FleekFunctionStatusNotValidError2;
      }
    });
    var require_FleekFunctionSlugNotValidError2 = __commonJS2({
      "../../errors/dist/FleekFunctionSlugNotValidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionSlugNotValidError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionSlugNotValidError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionSlugNotValidError";
            this.toString = () => {
              return `The slug, ${this.data.slug}, is invalid`;
            };
          }
        };
        exports22.FleekFunctionSlugNotValidError = FleekFunctionSlugNotValidError2;
      }
    });
    var require_MaintenanceError2 = __commonJS2({
      "../../errors/dist/MaintenanceError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MaintenanceError = void 0;
        var FleekError_1 = require_FleekError2();
        var MaintenanceError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "MaintenanceError";
            this.extensions = {
              http: {
                status: 503
                // Service Unavailable
              }
            };
            this.toString = () => "The platform is under maintenance. Please try again later.";
          }
        };
        exports22.MaintenanceError = MaintenanceError;
      }
    });
    var require_UserHasNoAccessToFeatureError2 = __commonJS2({
      "../../errors/dist/UserHasNoAccessToFeatureError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserHasNoAccessToFeatureError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserHasNoAccessToFeatureError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UserHasNoAccessToFeatureError";
            this.toString = () => `User has no access to this feature.`;
          }
        };
        exports22.UserHasNoAccessToFeatureError = UserHasNoAccessToFeatureError;
      }
    });
    var require_InvalidCidError2 = __commonJS2({
      "../../errors/dist/InvalidCidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidCidError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidCidError3 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidCidError";
            this.toString = () => `The cid ${this.data.name} is invalid.`;
          }
        };
        exports22.InvalidCidError = InvalidCidError3;
      }
    });
    var require_ValidationError2 = __commonJS2({
      "../../errors/dist/ValidationError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ValidationError = void 0;
        var FleekError_1 = require_FleekError2();
        var ValidationError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ValidationError";
            this.toString = () => `${JSON.stringify(this.data)}`;
          }
        };
        exports22.ValidationError = ValidationError;
      }
    });
    var require_UserInBlocklistError2 = __commonJS2({
      "../../errors/dist/UserInBlocklistError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserInBlocklistError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserInBlocklistError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UserInBlocklistError";
            this.toString = () => "User is in the blocklist.";
          }
        };
        exports22.UserInBlocklistError = UserInBlocklistError;
      }
    });
    var require_EnsNameContentHashCodecMistmatchError2 = __commonJS2({
      "../../errors/dist/EnsNameContentHashCodecMistmatchError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsNameContentHashCodecMistmatchError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsNameContentHashCodecMistmatchError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsNameContentHashCodecMistmatchError";
            this.toString = () => {
              return `The content hash does not match or does not corresponds to ${this.data.codec} protocol`;
            };
          }
        };
        exports22.EnsNameContentHashCodecMistmatchError = EnsNameContentHashCodecMistmatchError;
      }
    });
    var require_EnsNameContentHashUndefinedError2 = __commonJS2({
      "../../errors/dist/EnsNameContentHashUndefinedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsNameContentHashUndefinedError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnsNameContentHashUndefinedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnsNameContentHashUndefinedError";
            this.toString = () => {
              return `The content hash for ENS record name "${this.data.ensRecord.name}" is undefined.`;
            };
          }
        };
        exports22.EnsNameContentHashUndefinedError = EnsNameContentHashUndefinedError;
      }
    });
    var require_DnsConfigAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/DnsConfigAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DnsConfigAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var DnsConfigAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DnsConfigAlreadyExistsError";
            this.toString = () => `DNS config already exists for "${this.data.name}".`;
          }
        };
        exports22.DnsConfigAlreadyExistsError = DnsConfigAlreadyExistsError;
      }
    });
    var require_DnsConfigNotFoundError2 = __commonJS2({
      "../../errors/dist/DnsConfigNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DnsConfigNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var DnsConfigNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DnsConfigNotFoundError";
            this.toString = () => `DNS config for the "${this.data.name}" name doesn't exist.`;
          }
        };
        exports22.DnsConfigNotFoundError = DnsConfigNotFoundError;
      }
    });
    var require_TwoFactorSecretKeyFailedToEncryptError2 = __commonJS2({
      "../../errors/dist/TwoFactorSecretKeyFailedToEncryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TwoFactorSecretKeyFailedToEncryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var TwoFactorSecretKeyFailedToEncryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TwoFactorSecretKeyFailedToEncryptError";
            this.toString = () => "Failed to encrypt 2FA secret key.";
          }
        };
        exports22.TwoFactorSecretKeyFailedToEncryptError = TwoFactorSecretKeyFailedToEncryptError;
      }
    });
    var require_UserSecretKeyAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/UserSecretKeyAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserSecretKeyAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserSecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UserSecretKeyAlreadyExistsError";
            this.toString = () => "A secret key for this user already exists.";
          }
        };
        exports22.UserSecretKeyAlreadyExistsError = UserSecretKeyAlreadyExistsError;
      }
    });
    var require_UserSecretKeyNotFoundError2 = __commonJS2({
      "../../errors/dist/UserSecretKeyNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserSecretKeyNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserSecretKeyNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "UserSecretKeyNotFoundError";
            this.toString = () => "A secret key for this user not found.";
          }
        };
        exports22.UserSecretKeyNotFoundError = UserSecretKeyNotFoundError;
      }
    });
    var require_TwoFactorSecretKeyFailedToDecryptError2 = __commonJS2({
      "../../errors/dist/TwoFactorSecretKeyFailedToDecryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.TwoFactorSecretKeyFailedToDecryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var TwoFactorSecretKeyFailedToDecryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "TwoFactorSecretKeyFailedToDecryptError";
            this.toString = () => "Failed to decrypt 2FA secret key.";
          }
        };
        exports22.TwoFactorSecretKeyFailedToDecryptError = TwoFactorSecretKeyFailedToDecryptError;
      }
    });
    var require_RecoveryCodesAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/RecoveryCodesAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.RecoveryCodesAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var RecoveryCodesAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "RecoveryCodesAlreadyExistsError";
            this.toString = () => "Recovery codes already exists.";
          }
        };
        exports22.RecoveryCodesAlreadyExistsError = RecoveryCodesAlreadyExistsError;
      }
    });
    var require_WriteFileFromStreamError2 = __commonJS2({
      "../../errors/dist/WriteFileFromStreamError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.WriteFileFromStreamError = void 0;
        var FleekError_1 = require_FleekError2();
        var WriteFileFromStreamError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "WriteFileFromStreamError";
            this.toString = () => `There was an error while writing file from stream in globSource`;
          }
        };
        exports22.WriteFileFromStreamError = WriteFileFromStreamError;
      }
    });
    var require_InvalidTOTPTokenError2 = __commonJS2({
      "../../errors/dist/InvalidTOTPTokenError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidTOTPTokenError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidTOTPTokenError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidTOTPTokenError";
            this.toString = () => "TOTP token is invalid.";
          }
        };
        exports22.InvalidTOTPTokenError = InvalidTOTPTokenError;
      }
    });
    var require_InvalidRecoveryCodeError2 = __commonJS2({
      "../../errors/dist/InvalidRecoveryCodeError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidRecoveryCodeError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidRecoveryCodeError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidRecoveryCodeError";
            this.toString = () => "Recovery code is invalid.";
          }
        };
        exports22.InvalidRecoveryCodeError = InvalidRecoveryCodeError;
      }
    });
    var require_MissingTwoFactorProtectionCredentialsError2 = __commonJS2({
      "../../errors/dist/MissingTwoFactorProtectionCredentialsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MissingTwoFactorProtectionCredentialsError = void 0;
        var FleekError_1 = require_FleekError2();
        var MissingTwoFactorProtectionCredentialsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MissingTwoFactorProtectionCredentialsError";
            this.toString = () => "Missing two factor protection credentials. Either a token or a recovery key should be provided.";
          }
        };
        exports22.MissingTwoFactorProtectionCredentialsError = MissingTwoFactorProtectionCredentialsError;
      }
    });
    var require_DeploymentInProgressError2 = __commonJS2({
      "../../errors/dist/DeploymentInProgressError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.DeploymentInProgressError = void 0;
        var FleekError_1 = require_FleekError2();
        var DeploymentInProgressError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "DeploymentInProgressError";
            this.toString = () => "Deployment is already in progress.";
          }
        };
        exports22.DeploymentInProgressError = DeploymentInProgressError;
      }
    });
    var require_PullzoneNotFoundForZoneIdError2 = __commonJS2({
      "../../errors/dist/PullzoneNotFoundForZoneIdError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PullzoneNotFoundForZoneIdError = void 0;
        var FleekError_1 = require_FleekError2();
        var PullzoneNotFoundForZoneIdError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PullzoneNotFoundForZoneIdError";
            this.toString = () => {
              return `The pullzone is not found for zone id: ${this.data.id}`;
            };
          }
        };
        exports22.PullzoneNotFoundForZoneIdError = PullzoneNotFoundForZoneIdError;
      }
    });
    var require_RecoveryCodeFailedToEncryptError2 = __commonJS2({
      "../../errors/dist/RecoveryCodeFailedToEncryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.RecoveryCodeFailedToEncryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var RecoveryCodeFailedToEncryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "RecoveryCodeFailedToEncryptError";
            this.toString = () => "Failed to encrypt recovery code.";
          }
        };
        exports22.RecoveryCodeFailedToEncryptError = RecoveryCodeFailedToEncryptError;
      }
    });
    var require_RecoveryCodeFailedToDecryptError2 = __commonJS2({
      "../../errors/dist/RecoveryCodeFailedToDecryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.RecoveryCodeFailedToDecryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var RecoveryCodeFailedToDecryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "RecoveryCodeFailedToDecryptError";
            this.toString = () => "Failed to decrypt recovery code.";
          }
        };
        exports22.RecoveryCodeFailedToDecryptError = RecoveryCodeFailedToDecryptError;
      }
    });
    var require_PermissionGroupNotFoundError2 = __commonJS2({
      "../../errors/dist/PermissionGroupNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PermissionGroupNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PermissionGroupNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PermissionGroupNotFoundError";
            this.toString = () => "Permission group not found";
          }
        };
        exports22.PermissionGroupNotFoundError = PermissionGroupNotFoundError;
      }
    });
    var require_PermissionScopeError2 = __commonJS2({
      "../../errors/dist/PermissionScopeError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PermissionScopeError = void 0;
        var FleekError_1 = require_FleekError2();
        var PermissionScopeError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PermissionScopeError";
            this.toString = () => `Permission scope ${this.data.scope} doesn't exist.`;
          }
        };
        exports22.PermissionScopeError = PermissionScopeError;
      }
    });
    var require_InvalidAdminAccessTokenError2 = __commonJS2({
      "../../errors/dist/InvalidAdminAccessTokenError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidAdminAccessTokenError = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidAdminAccessTokenError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidAdminAccessTokenError";
            this.toString = () => "Admin access token is invalid.";
          }
        };
        exports22.InvalidAdminAccessTokenError = InvalidAdminAccessTokenError;
      }
    });
    var require_MissingExpectedDataError2 = __commonJS2({
      "../../errors/dist/MissingExpectedDataError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.MissingExpectedDataError = void 0;
        var FleekError_1 = require_FleekError2();
        var MissingExpectedDataError22 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "MissingExpectedDataError";
            this.toString = () => "Oops! This is embarassing but the app is missing important data. Please report this issue to the team.";
          }
        };
        exports22.MissingExpectedDataError = MissingExpectedDataError22;
      }
    });
    var require_EnvNotSetError2 = __commonJS2({
      "../../errors/dist/EnvNotSetError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnvNotSetError = void 0;
        var FleekError_1 = require_FleekError2();
        var EnvNotSetError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "EnvNotSetError";
            this.toString = () => this.data ? `Environment variable "${this.data}" is not set.` : `Missing the defined object key pair values.`;
          }
        };
        exports22.EnvNotSetError = EnvNotSetError;
      }
    });
    var require_GitSecretsFailedToEncryptError2 = __commonJS2({
      "../../errors/dist/GitSecretsFailedToEncryptError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitSecretsFailedToEncryptError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitSecretsFailedToEncryptError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitSecretsFailedToEncryptError";
            this.toString = () => "Failed to encrypt Git Secrets.";
          }
        };
        exports22.GitSecretsFailedToEncryptError = GitSecretsFailedToEncryptError;
      }
    });
    var require_GitConfigFailedToParseError2 = __commonJS2({
      "../../errors/dist/GitConfigFailedToParseError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitConfigFailedToParseError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitConfigFailedToParseError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitSecretsFailedToEncryptError";
            this.toString = () => "Failed to parse Git Configs.";
          }
        };
        exports22.GitConfigFailedToParseError = GitConfigFailedToParseError;
      }
    });
    var require_PathIsNotAFileError2 = __commonJS2({
      "../../errors/dist/PathIsNotAFileError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PathIsNotAFileError = void 0;
        var FleekError_1 = require_FleekError2();
        var PathIsNotAFileError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PathIsNotAFileError";
            this.toString = () => {
              return `Given path ${this.data.path} is not a file.`;
            };
          }
        };
        exports22.PathIsNotAFileError = PathIsNotAFileError;
      }
    });
    var require_FleekFunctionBundlingFailedError2 = __commonJS2({
      "../../errors/dist/FleekFunctionBundlingFailedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionBundlingFailedError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionBundlingFailedError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionBundlingFailedError";
            this.toString = () => {
              return `Bundle creation failed. For information on supported packages, please consult our documentation.
Error: ${this.data.error}`;
            };
          }
        };
        exports22.FleekFunctionBundlingFailedError = FleekFunctionBundlingFailedError2;
      }
    });
    var require_GitIntegrationNotFoundError2 = __commonJS2({
      "../../errors/dist/GitIntegrationNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitIntegrationNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitIntegrationNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitIntegrationNotFoundError";
            this.toString = () => {
              let infix = "";
              if ("siteId" in this.data) {
                infix = `for site ${this.data.siteId}`;
              } else if ("id" in this.data) {
                infix = `with id ${this.data.id}`;
              }
              return `Git Integration ${infix} not found`;
            };
          }
        };
        exports22.GitIntegrationNotFoundError = GitIntegrationNotFoundError;
      }
    });
    var require_GitProviderNotFoundError2 = __commonJS2({
      "../../errors/dist/GitProviderNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitProviderNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitProviderNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitProviderNotFoundError";
            this.toString = () => {
              return `No Git Provider found with id: ${this.data.providerId}`;
            };
          }
        };
        exports22.GitProviderNotFoundError = GitProviderNotFoundError;
      }
    });
    var require_ExpectedOneOfValuesError2 = __commonJS2({
      "../../errors/dist/ExpectedOneOfValuesError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ExpectedOneOfValuesError = void 0;
        var FleekError_1 = require_FleekError2();
        var ExpectedOneOfValuesError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ExpectedOneOfValuesError";
            this.toString = () => `Expected one of ${this.data.expectedValues.join(", ")} but got ${this.data.receivedValue}`;
          }
        };
        exports22.ExpectedOneOfValuesError = ExpectedOneOfValuesError2;
      }
    });
    var require_InvalidJSONFormat2 = __commonJS2({
      "../../errors/dist/InvalidJSONFormat.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.InvalidJSONFormat = void 0;
        var FleekError_1 = require_FleekError2();
        var InvalidJSONFormat2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "InvalidJSONFormat";
            this.toString = () => `Invalid JSON format.`;
          }
        };
        exports22.InvalidJSONFormat = InvalidJSONFormat2;
      }
    });
    var require_StorageUploadFileCountQuotaExceededError2 = __commonJS2({
      "../../errors/dist/StorageUploadFileCountQuotaExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.StorageUploadFileCountQuotaExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var StorageUploadFileCountQuotaExceededError = class extends FleekError_1.FleekError {
          constructor(data = {}) {
            super(data);
            this.name = "StorageUploadFileCountQuotaExceededError";
            this.toString = () => {
              if (this.data?.quota) {
                return `Sorry, you have reached your daily limit of ${this.data.quota} file uploads. We are unable to process your request.`;
              }
              return "You have exceeded your file upload limit for the past 24 hours.";
            };
          }
        };
        exports22.StorageUploadFileCountQuotaExceededError = StorageUploadFileCountQuotaExceededError;
      }
    });
    var require_StorageUploadTotalSizeQuotaExceededError2 = __commonJS2({
      "../../errors/dist/StorageUploadTotalSizeQuotaExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.StorageUploadTotalSizeQuotaExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var StorageUploadTotalSizeQuotaExceededError = class extends FleekError_1.FleekError {
          constructor(data = {}) {
            super(data);
            this.name = "StorageUploadTotalSizeQuotaExceededError";
            this.toString = () => {
              if (this.data?.quota) {
                return `Sorry, you have reached your daily upload limit of ${Math.round(this.data.quota / 1e3 ** 3)}GB. We are unable to process your request.`;
              }
              return "You have exceeded your storage upload quota for the last 24 hours.";
            };
          }
        };
        exports22.StorageUploadTotalSizeQuotaExceededError = StorageUploadTotalSizeQuotaExceededError;
      }
    });
    var require_GitProviderNotSupportedError2 = __commonJS2({
      "../../errors/dist/GitProviderNotSupportedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitProviderNotSupportedError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitProviderNotSupportedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitProviderNotSupportedError";
            this.toString = () => `Git provider: ${this.data.provider} not Supported`;
          }
        };
        exports22.GitProviderNotSupportedError = GitProviderNotSupportedError;
      }
    });
    var require_GitProviderNotAuthorizedError2 = __commonJS2({
      "../../errors/dist/GitProviderNotAuthorizedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitProviderNotAuthorizedError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitProviderNotAuthorizedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitProviderNotAuthorizedError";
            this.toString = () => `The user has not authorized the Git provider: ${this.data.provider}`;
          }
        };
        exports22.GitProviderNotAuthorizedError = GitProviderNotAuthorizedError;
      }
    });
    var require_GitAccessTokenInvalidError2 = __commonJS2({
      "../../errors/dist/GitAccessTokenInvalidError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitAccessTokenInvalidError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitAccessTokenInvalidError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitAccessTokenInvalidError";
            this.toString = () => {
              return "The git access token for the user is invalid";
            };
          }
        };
        exports22.GitAccessTokenInvalidError = GitAccessTokenInvalidError;
      }
    });
    var require_QueuedDeploymentsLimitError2 = __commonJS2({
      "../../errors/dist/QueuedDeploymentsLimitError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.QueuedDeploymentsLimitError = void 0;
        var FleekError_1 = require_FleekError2();
        var QueuedDeploymentsLimitError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "QueuedDeploymentsLimitError";
            this.toString = () => `You've reached the limit of ${this.data.limit} queued deployments.`;
          }
        };
        exports22.QueuedDeploymentsLimitError = QueuedDeploymentsLimitError;
      }
    });
    var require_GitIntegrationInstallationConflictError2 = __commonJS2({
      "../../errors/dist/GitIntegrationInstallationConflictError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitIntegrationInstallationConflictError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitIntegrationInstallationConflictError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitIntegrationInstallationConflictError";
            this.toString = () => `The Git Integration installation for this provider already exists in this project`;
          }
        };
        exports22.GitIntegrationInstallationConflictError = GitIntegrationInstallationConflictError;
      }
    });
    var require_GitLinkMultipleAccountError2 = __commonJS2({
      "../../errors/dist/GitLinkMultipleAccountError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitLinkMultipleAccountError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitLinkMultipleAccountError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitLinkMultipleAccountError";
            this.toString = () => `Oops! You already have a Git profile linked to your Fleek account. We don't allow multiple connections`;
          }
        };
        exports22.GitLinkMultipleAccountError = GitLinkMultipleAccountError;
      }
    });
    var require_GitRepoByNameAndOwnerNotFoundError2 = __commonJS2({
      "../../errors/dist/GitRepoByNameAndOwnerNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitRepoByNameAndOwnerNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitRepoByNameAndOwnerNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitRepoByNameAndOwnerNotFoundError";
            this.toString = () => `Git repo "${this.data.owner}/${this.data.repo}" not found`;
          }
        };
        exports22.GitRepoByNameAndOwnerNotFoundError = GitRepoByNameAndOwnerNotFoundError;
      }
    });
    var require_GitAccessTokenNotFoundError2 = __commonJS2({
      "../../errors/dist/GitAccessTokenNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GitAccessTokenNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var GitAccessTokenNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "GitAccessTokenNotFoundError";
            this.toString = () => {
              return "The git access token for the user is not found";
            };
          }
        };
        exports22.GitAccessTokenNotFoundError = GitAccessTokenNotFoundError;
      }
    });
    var require_FolderNotFoundError2 = __commonJS2({
      "../../errors/dist/FolderNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FolderNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var FolderNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FolderNotFoundError";
            this.toString = () => `Folder was not found.`;
          }
        };
        exports22.FolderNotFoundError = FolderNotFoundError;
      }
    });
    var require_FolderAlreadyExistsError2 = __commonJS2({
      "../../errors/dist/FolderAlreadyExistsError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FolderAlreadyExistsError = void 0;
        var FleekError_1 = require_FleekError2();
        var FolderAlreadyExistsError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FolderAlreadyExistsError";
            this.toString = () => `Folder ${this.data.folder.name} already exists in ${this.data.folder.parentFolderId ? "parent" : "root project"} folder.`;
          }
        };
        exports22.FolderAlreadyExistsError = FolderAlreadyExistsError;
      }
    });
    var require_FolderNameContainsReservedWordError2 = __commonJS2({
      "../../errors/dist/FolderNameContainsReservedWordError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FolderNameContainsReservedWordError = void 0;
        var FleekError_1 = require_FleekError2();
        var FolderNameContainsReservedWordError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FolderNameContainsReservedWorkError";
            this.toString = () => `Folder name ${this.data.name} is reserved word and you cannot use it.`;
          }
        };
        exports22.FolderNameContainsReservedWordError = FolderNameContainsReservedWordError;
      }
    });
    var require_PinsNotFoundError2 = __commonJS2({
      "../../errors/dist/PinsNotFoundError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.PinsNotFoundError = void 0;
        var FleekError_1 = require_FleekError2();
        var PinsNotFoundError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "PinsNotFoundError";
            this.toString = () => {
              return "No pins found.";
            };
          }
        };
        exports22.PinsNotFoundError = PinsNotFoundError;
      }
    });
    var require_SiteCreationFailedError2 = __commonJS2({
      "../../errors/dist/SiteCreationFailedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SiteCreationFailedError = void 0;
        var FleekError_1 = require_FleekError2();
        var SiteCreationFailedError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "SiteCreationFailedError";
            this.toString = () => `Site creation failed.`;
          }
        };
        exports22.SiteCreationFailedError = SiteCreationFailedError;
      }
    });
    var require_FleekFunctionInvalidWasmCodeError2 = __commonJS2({
      "../../errors/dist/FleekFunctionInvalidWasmCodeError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionInvalidWasmCodeError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionInvalidWasmCodeError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionInvalidWasmCodeError";
            this.toString = () => {
              return `Fleek function encountered corrupt or invalid WASM code.`;
            };
          }
        };
        exports22.FleekFunctionInvalidWasmCodeError = FleekFunctionInvalidWasmCodeError2;
      }
    });
    var require_FleekFunctionWasmEncryptionFailedError2 = __commonJS2({
      "../../errors/dist/FleekFunctionWasmEncryptionFailedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekFunctionWasmEncryptionFailedError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekFunctionWasmEncryptionFailedError2 = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekFunctionWasmEncryptionFailedError";
            this.toString = () => {
              return `Unable to encrypt WASM code for Fleek function`;
            };
          }
        };
        exports22.FleekFunctionWasmEncryptionFailedError = FleekFunctionWasmEncryptionFailedError2;
      }
    });
    var require_UploadProxyStoreAsCarError2 = __commonJS2({
      "../../errors/dist/UploadProxyStoreAsCarError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UploadProxyStoreAsCarError = void 0;
        var FleekError_1 = require_FleekError2();
        var UploadProxyStoreAsCarError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UploadProxyStoreAsCarError";
            this.toString = () => `Failed to Store as a CAR file.`;
          }
        };
        exports22.UploadProxyStoreAsCarError = UploadProxyStoreAsCarError;
      }
    });
    var require_UploadProxyUploadFileError2 = __commonJS2({
      "../../errors/dist/UploadProxyUploadFileError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UploadProxyUploadFileError = void 0;
        var FleekError_1 = require_FleekError2();
        var UploadProxyUploadFileError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UploadProxyUploadFileError";
            this.toString = () => `Failed to Upload file.`;
          }
        };
        exports22.UploadProxyUploadFileError = UploadProxyUploadFileError;
      }
    });
    var require_IpfsDenylistUpdateWorkflowTriggerFailedError2 = __commonJS2({
      "../../errors/dist/IpfsDenylistUpdateWorkflowTriggerFailedError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.IpfsDenylistUpdateWorkflowTriggerFailedError = void 0;
        var FleekError_1 = require_FleekError2();
        var IpfsDenylistUpdateWorkflowTriggerFailedError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "IpfsDenylistUpdateWorkflowTriggerFailedError";
            this.toString = () => {
              return `Failed to trigger IPFS denylist update workflow: ${this.data.error}`;
            };
          }
        };
        exports22.IpfsDenylistUpdateWorkflowTriggerFailedError = IpfsDenylistUpdateWorkflowTriggerFailedError;
      }
    });
    var require_ProjectSiteLimitExceededError2 = __commonJS2({
      "../../errors/dist/ProjectSiteLimitExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectSiteLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectSiteLimitExceededError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectSiteLimitExceededError";
            this.toString = () => `You've reached the maximum number of sites for this project. Contact our Support team if you have any questions.`;
          }
        };
        exports22.ProjectSiteLimitExceededError = ProjectSiteLimitExceededError;
      }
    });
    var require_ProjectFleekFunctionLimitExceededError2 = __commonJS2({
      "../../errors/dist/ProjectFleekFunctionLimitExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectFleekFunctionLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectFleekFunctionLimitExceededError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "ProjectFleekFunctionLimitExceededError";
            this.toString = () => `You've reached the maximum number of Fleek functions for this project. Contact our Support team if you have any questions.`;
          }
        };
        exports22.ProjectFleekFunctionLimitExceededError = ProjectFleekFunctionLimitExceededError;
      }
    });
    var require_UserProjectLimitExceededError2 = __commonJS2({
      "../../errors/dist/UserProjectLimitExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UserProjectLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var UserProjectLimitExceededError = class extends FleekError_1.FleekError {
          constructor() {
            super({});
            this.name = "UserProjectLimitExceededError";
            this.toString = () => `You've reached the maximum number of projects for your account. Contact our Support team if you have any questions.`;
          }
        };
        exports22.UserProjectLimitExceededError = UserProjectLimitExceededError;
      }
    });
    var require_ProjectDomainsLimitExceededError = __commonJS2({
      "../../errors/dist/ProjectDomainsLimitExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectDomainsLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectDomainsLimitExceededError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectDomainsLimitExceededError";
            this.toString = () => `You've reached the maximum number of domains for this project. Contact our Support team if you have any questions.`;
          }
        };
        exports22.ProjectDomainsLimitExceededError = ProjectDomainsLimitExceededError;
      }
    });
    var require_ProjectMembershipsLimitExceededError = __commonJS2({
      "../../errors/dist/ProjectMembershipsLimitExceededError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProjectMembershipsLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        var ProjectMembershipsLimitExceededError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "ProjectMembershipsLimitExceededError";
            this.toString = () => `You've reached the maximum number of memberships for this project. Contact our Support team if you have any questions.`;
          }
        };
        exports22.ProjectMembershipsLimitExceededError = ProjectMembershipsLimitExceededError;
      }
    });
    var require_FleekRestApiInternalError = __commonJS2({
      "../../errors/dist/FleekRestApiInternalError.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FleekRestApiInternalError = void 0;
        var FleekError_1 = require_FleekError2();
        var FleekRestApiInternalError = class extends FleekError_1.FleekError {
          constructor() {
            super(...arguments);
            this.name = "FleekRestApiInternalError";
            this.toString = () => this.data.message;
          }
        };
        exports22.FleekRestApiInternalError = FleekRestApiInternalError;
      }
    });
    var require_dist9 = __commonJS2({
      "../../errors/dist/index.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EnsRecordInPendingStateError = exports22.EnsNameInvalidError = exports22.EnsRecordAlreadyExistsInProjectError = exports22.EnsRecordNotFoundError = exports22.ApplicationNameInvalidError = exports22.ApplicationNotFoundError = exports22.ApplicationsNotFoundError = exports22.ApplicationAlreadyExistsError = exports22.ApplicationWhitelistDomainDuplicityError = exports22.FleekConfigMissingFileError = exports22.FleekConfigInvalidContentError = exports22.UnauthorizedError = exports22.DomainZoneInvalidTypeError = exports22.DomainNotFoundUnderPullzoneError = exports22.DomainZoneInPendingStateError = exports22.DomainZoneHasDependentsError = exports22.DomainZoneNotFoundError = exports22.UnauthenticatedError = exports22.VerificationSessionAlreadyExistsError = exports22.PublicKeyAlreadyExistsError = exports22.ProjectInvalidNameError = exports22.ProjectHasDependentsError = exports22.ProjectsNotFoundError = exports22.ProjectNotFoundError = exports22.UserAlreadyExistsError = exports22.UserNotFoundError = exports22.GithubAppInstallationNotFoundError = exports22.ProjectMembershipNotFoundError = exports22.AuthorizationError = exports22.SdkRequiredNodeRuntimeError = exports22.StorageIpfsUploadFailedError = exports22.IpnsRecordsForSiteLimitError = exports22.IpnsFailToDecryptKeyError = exports22.IpnsRecordsNotFoundError = exports22.IpnsRecordNotFoundError = exports22.SiteNotDeployedError = exports22.SiteHasNoSourceProviderError = exports22.SiteHasDependentsError = exports22.SiteDeploymentNotFoundError = exports22.SiteAlreadyExistsError = exports22.SitesNotFoundError = exports22.SiteNotFoundError = exports22.UnknownError = exports22.DomainHostnameInvalidError = exports22.DomainInPendingStateError = exports22.DomainAlreadyExistsInProjectError = exports22.DomainsNotFoundError = exports22.DomainNotFoundError = exports22.BunnyPullZoneNotFoundError = exports22.FleekError = void 0;
        exports22.EnsNameContentHashUndefinedError = exports22.EnsNameContentHashCodecMistmatchError = exports22.UserInBlocklistError = exports22.ValidationError = exports22.InvalidCidError = exports22.UserHasNoAccessToFeatureError = exports22.MaintenanceError = exports22.FleekFunctionSlugNotValidError = exports22.FleekFunctionStatusNotValidError = exports22.FleekFunctionNameNotValidError = exports22.FleekFunctionPathNotValidError = exports22.FleekFunctionsNotFoundError = exports22.FleekFunctionDeploymentNotFoundError = exports22.FleekFunctionNotFoundError = exports22.FleekFunctionAlreadyExistsError = exports22.PathIsNotADirectoryError = exports22.UploadedS3KeyNotFoundError = exports22.ProjectMembershipNoOwnersError = exports22.ProjectMembershipAlreadyExistError = exports22.ProjectInvitationAlreadyExistError = exports22.MigrationRequestInPendingStateError = exports22.MigrationRequestNotFoundError = exports22.MigrationRequestsAlreadyExistError = exports22.MigrationTokenInvalidError = exports22.InvitationNotFoundError = exports22.IpfsGatewayContentUnreachableError = exports22.InvalidDeploymentTriggerError = exports22.SiteDeploymentNotReleasedError = exports22.UnstoppableDeploymentError = exports22.PinAlreadyExistsInProjectError = exports22.PinNotFoundError = exports22.SecretFailToEncryptError = exports22.SecretKeyAlreadyExistsError = exports22.SecretVisibilityAlreadyEncryptedError = exports22.SecretNotFoundError = exports22.SecretGroupNotFoundError = exports22.ProjectMembershipHasInefficientRoleError = exports22.TemplateDeploymentNotFoundError = exports22.TemplateCategoryNotFoundError = exports22.SiteFrameworkNotFoundError = exports22.SiteFrameworkAlreadyExistsError = exports22.UserHasNoAccessToAnotherUserError = exports22.TemplateNotFoundError = exports22.TemplateAlreadyExistsError = exports22.PrivateGatewaysNotFoundError = exports22.PrivateGatewayNameInvalidError = exports22.PrivateGatewayAlreadyExistsError = exports22.PrivateGatewayNotFoundError = exports22.PersonalAccessTokenNotFoundError = exports22.InvalidPersonalAccessTokenError = void 0;
        exports22.ProjectFleekFunctionLimitExceededError = exports22.ProjectSiteLimitExceededError = exports22.IpfsDenylistUpdateWorkflowTriggerFailedError = exports22.UploadProxyUploadFileError = exports22.UploadProxyStoreAsCarError = exports22.FleekFunctionWasmEncryptionFailedError = exports22.FleekFunctionInvalidWasmCodeError = exports22.SiteCreationFailedError = exports22.PinsNotFoundError = exports22.FolderNameContainsReservedWordError = exports22.FolderAlreadyExistsError = exports22.FolderNotFoundError = exports22.GitAccessTokenNotFoundError = exports22.GitRepoByNameAndOwnerNotFoundError = exports22.GitLinkMultipleAccountError = exports22.GitIntegrationInstallationConflictError = exports22.QueuedDeploymentsLimitError = exports22.GitAccessTokenInvalidError = exports22.GitProviderNotAuthorizedError = exports22.GitProviderNotSupportedError = exports22.StorageUploadTotalSizeQuotaExceededError = exports22.StorageUploadFileCountQuotaExceededError = exports22.InvalidJSONFormat = exports22.ExpectedOneOfValuesError = exports22.GitProviderNotFoundError = exports22.GitIntegrationNotFoundError = exports22.FleekFunctionBundlingFailedError = exports22.PathIsNotAFileError = exports22.GitConfigFailedToParseError = exports22.GitSecretsFailedToEncryptError = exports22.EnvNotSetError = exports22.MissingExpectedDataError = exports22.InvalidAdminAccessTokenError = exports22.PermissionScopeError = exports22.PermissionGroupNotFoundError = exports22.RecoveryCodeFailedToDecryptError = exports22.RecoveryCodeFailedToEncryptError = exports22.PullzoneNotFoundForZoneIdError = exports22.DeploymentInProgressError = exports22.MissingTwoFactorProtectionCredentialsError = exports22.InvalidRecoveryCodeError = exports22.InvalidTOTPTokenError = exports22.WriteFileFromStreamError = exports22.RecoveryCodesAlreadyExistsError = exports22.TwoFactorSecretKeyFailedToDecryptError = exports22.UserSecretKeyNotFoundError = exports22.UserSecretKeyAlreadyExistsError = exports22.TwoFactorSecretKeyFailedToEncryptError = exports22.DnsConfigNotFoundError = exports22.DnsConfigAlreadyExistsError = void 0;
        exports22.FleekRestApiInternalError = exports22.ProjectMembershipsLimitExceededError = exports22.ProjectDomainsLimitExceededError = exports22.UserProjectLimitExceededError = void 0;
        var FleekError_1 = require_FleekError2();
        Object.defineProperty(exports22, "FleekError", { enumerable: true, get: function() {
          return FleekError_1.FleekError;
        } });
        var BunnyPullZoneNotFoundError_1 = require_BunnyPullZoneNotFoundError2();
        Object.defineProperty(exports22, "BunnyPullZoneNotFoundError", { enumerable: true, get: function() {
          return BunnyPullZoneNotFoundError_1.BunnyPullZoneNotFoundError;
        } });
        var DomainNotFoundError_1 = require_DomainNotFoundError2();
        Object.defineProperty(exports22, "DomainNotFoundError", { enumerable: true, get: function() {
          return DomainNotFoundError_1.DomainNotFoundError;
        } });
        var DomainsNotFoundError_1 = require_DomainsNotFoundError2();
        Object.defineProperty(exports22, "DomainsNotFoundError", { enumerable: true, get: function() {
          return DomainsNotFoundError_1.DomainsNotFoundError;
        } });
        var DomainAlreadyExistsInProjectError_1 = require_DomainAlreadyExistsInProjectError2();
        Object.defineProperty(exports22, "DomainAlreadyExistsInProjectError", { enumerable: true, get: function() {
          return DomainAlreadyExistsInProjectError_1.DomainAlreadyExistsInProjectError;
        } });
        var DomainInPendingStateError_1 = require_DomainInPendingStateError2();
        Object.defineProperty(exports22, "DomainInPendingStateError", { enumerable: true, get: function() {
          return DomainInPendingStateError_1.DomainInPendingStateError;
        } });
        var DomainHostnameInvalidError_1 = require_DomainHostnameInvalidError2();
        Object.defineProperty(exports22, "DomainHostnameInvalidError", { enumerable: true, get: function() {
          return DomainHostnameInvalidError_1.DomainHostnameInvalidError;
        } });
        var UnknownError_1 = require_UnknownError2();
        Object.defineProperty(exports22, "UnknownError", { enumerable: true, get: function() {
          return UnknownError_1.UnknownError;
        } });
        var SiteNotFoundError_1 = require_SiteNotFoundError2();
        Object.defineProperty(exports22, "SiteNotFoundError", { enumerable: true, get: function() {
          return SiteNotFoundError_1.SiteNotFoundError;
        } });
        var SitesNotFoundError_1 = require_SitesNotFoundError2();
        Object.defineProperty(exports22, "SitesNotFoundError", { enumerable: true, get: function() {
          return SitesNotFoundError_1.SitesNotFoundError;
        } });
        var SiteAlreadyExistsError_1 = require_SiteAlreadyExistsError2();
        Object.defineProperty(exports22, "SiteAlreadyExistsError", { enumerable: true, get: function() {
          return SiteAlreadyExistsError_1.SiteAlreadyExistsError;
        } });
        var SiteDeploymentNotFoundError_1 = require_SiteDeploymentNotFoundError2();
        Object.defineProperty(exports22, "SiteDeploymentNotFoundError", { enumerable: true, get: function() {
          return SiteDeploymentNotFoundError_1.SiteDeploymentNotFoundError;
        } });
        var SiteHasDependentsError_1 = require_SiteHasDependentsError2();
        Object.defineProperty(exports22, "SiteHasDependentsError", { enumerable: true, get: function() {
          return SiteHasDependentsError_1.SiteHasDependentsError;
        } });
        var SiteHasNoSourceProviderError_1 = require_SiteHasNoSourceProviderError2();
        Object.defineProperty(exports22, "SiteHasNoSourceProviderError", { enumerable: true, get: function() {
          return SiteHasNoSourceProviderError_1.SiteHasNoSourceProviderError;
        } });
        var SiteNotDeployedError_1 = require_SiteNotDeployedError2();
        Object.defineProperty(exports22, "SiteNotDeployedError", { enumerable: true, get: function() {
          return SiteNotDeployedError_1.SiteNotDeployedError;
        } });
        var IpnsRecordNotFoundError_1 = require_IpnsRecordNotFoundError2();
        Object.defineProperty(exports22, "IpnsRecordNotFoundError", { enumerable: true, get: function() {
          return IpnsRecordNotFoundError_1.IpnsRecordNotFoundError;
        } });
        var IpnsRecordsNotFoundError_1 = require_IpnsRecordsNotFoundError2();
        Object.defineProperty(exports22, "IpnsRecordsNotFoundError", { enumerable: true, get: function() {
          return IpnsRecordsNotFoundError_1.IpnsRecordsNotFoundError;
        } });
        var IpnsFailToDecryptKeyError_1 = require_IpnsFailToDecryptKeyError2();
        Object.defineProperty(exports22, "IpnsFailToDecryptKeyError", { enumerable: true, get: function() {
          return IpnsFailToDecryptKeyError_1.IpnsFailToDecryptKeyError;
        } });
        var IpnsRecordsForSiteLimitError_1 = require_IpnsRecordsForSiteLimitError2();
        Object.defineProperty(exports22, "IpnsRecordsForSiteLimitError", { enumerable: true, get: function() {
          return IpnsRecordsForSiteLimitError_1.IpnsRecordsForSiteLimitError;
        } });
        var StorageIpfsUploadFailedError_1 = require_StorageIpfsUploadFailedError2();
        Object.defineProperty(exports22, "StorageIpfsUploadFailedError", { enumerable: true, get: function() {
          return StorageIpfsUploadFailedError_1.StorageIpfsUploadFailedError;
        } });
        var SdkRequiredNodeRuntimeError_1 = require_SdkRequiredNodeRuntimeError2();
        Object.defineProperty(exports22, "SdkRequiredNodeRuntimeError", { enumerable: true, get: function() {
          return SdkRequiredNodeRuntimeError_1.SdkRequiredNodeRuntimeError;
        } });
        var AuthorizationError_1 = require_AuthorizationError2();
        Object.defineProperty(exports22, "AuthorizationError", { enumerable: true, get: function() {
          return AuthorizationError_1.AuthorizationError;
        } });
        var ProjectMembershipNotFoundError_1 = require_ProjectMembershipNotFoundError2();
        Object.defineProperty(exports22, "ProjectMembershipNotFoundError", { enumerable: true, get: function() {
          return ProjectMembershipNotFoundError_1.ProjectMembershipNotFoundError;
        } });
        var GithubAppInstallationNotFoundError_1 = require_GithubAppInstallationNotFoundError2();
        Object.defineProperty(exports22, "GithubAppInstallationNotFoundError", { enumerable: true, get: function() {
          return GithubAppInstallationNotFoundError_1.GithubAppInstallationNotFoundError;
        } });
        var UserNotFoundError_1 = require_UserNotFoundError2();
        Object.defineProperty(exports22, "UserNotFoundError", { enumerable: true, get: function() {
          return UserNotFoundError_1.UserNotFoundError;
        } });
        var UserAlreadyExistsError_1 = require_UserAlreadyExistsError2();
        Object.defineProperty(exports22, "UserAlreadyExistsError", { enumerable: true, get: function() {
          return UserAlreadyExistsError_1.UserAlreadyExistsError;
        } });
        var ProjectNotFoundError_1 = require_ProjectNotFoundError2();
        Object.defineProperty(exports22, "ProjectNotFoundError", { enumerable: true, get: function() {
          return ProjectNotFoundError_1.ProjectNotFoundError;
        } });
        var ProjectsNotFoundError_1 = require_ProjectsNotFoundError2();
        Object.defineProperty(exports22, "ProjectsNotFoundError", { enumerable: true, get: function() {
          return ProjectsNotFoundError_1.ProjectsNotFoundError;
        } });
        var ProjectHasDependentsError_1 = require_ProjectHasDependentsError2();
        Object.defineProperty(exports22, "ProjectHasDependentsError", { enumerable: true, get: function() {
          return ProjectHasDependentsError_1.ProjectHasDependentsError;
        } });
        var ProjectInvalidNameError_1 = require_ProjectInvalidNameError2();
        Object.defineProperty(exports22, "ProjectInvalidNameError", { enumerable: true, get: function() {
          return ProjectInvalidNameError_1.ProjectInvalidNameError;
        } });
        var PublicKeyAlreadyExistsError_1 = require_PublicKeyAlreadyExistsError2();
        Object.defineProperty(exports22, "PublicKeyAlreadyExistsError", { enumerable: true, get: function() {
          return PublicKeyAlreadyExistsError_1.PublicKeyAlreadyExistsError;
        } });
        var VerificationSessionAlreadyExistsError_1 = require_VerificationSessionAlreadyExistsError2();
        Object.defineProperty(exports22, "VerificationSessionAlreadyExistsError", { enumerable: true, get: function() {
          return VerificationSessionAlreadyExistsError_1.VerificationSessionAlreadyExistsError;
        } });
        var UnauthenticatedError_1 = require_UnauthenticatedError2();
        Object.defineProperty(exports22, "UnauthenticatedError", { enumerable: true, get: function() {
          return UnauthenticatedError_1.UnauthenticatedError;
        } });
        var DomainZoneNotFoundError_1 = require_DomainZoneNotFoundError2();
        Object.defineProperty(exports22, "DomainZoneNotFoundError", { enumerable: true, get: function() {
          return DomainZoneNotFoundError_1.DomainZoneNotFoundError;
        } });
        var DomainZoneHasDependentsError_1 = require_DomainZoneHasDependentsError2();
        Object.defineProperty(exports22, "DomainZoneHasDependentsError", { enumerable: true, get: function() {
          return DomainZoneHasDependentsError_1.DomainZoneHasDependentsError;
        } });
        var DomainZoneInPendingStateError_1 = require_DomainZoneInPendingStateError2();
        Object.defineProperty(exports22, "DomainZoneInPendingStateError", { enumerable: true, get: function() {
          return DomainZoneInPendingStateError_1.DomainZoneInPendingStateError;
        } });
        var DomainNotFoundUnderPullzoneError_1 = require_DomainNotFoundUnderPullzoneError2();
        Object.defineProperty(exports22, "DomainNotFoundUnderPullzoneError", { enumerable: true, get: function() {
          return DomainNotFoundUnderPullzoneError_1.DomainNotFoundUnderPullzoneError;
        } });
        var DomainZoneInvalidTypeError_1 = require_DomainZoneInvalidTypeError2();
        Object.defineProperty(exports22, "DomainZoneInvalidTypeError", { enumerable: true, get: function() {
          return DomainZoneInvalidTypeError_1.DomainZoneInvalidTypeError;
        } });
        var UnauthorizedError_1 = require_UnauthorizedError2();
        Object.defineProperty(exports22, "UnauthorizedError", { enumerable: true, get: function() {
          return UnauthorizedError_1.UnauthorizedError;
        } });
        var FleekConfigInvalidContentError_1 = require_FleekConfigInvalidContentError2();
        Object.defineProperty(exports22, "FleekConfigInvalidContentError", { enumerable: true, get: function() {
          return FleekConfigInvalidContentError_1.FleekConfigInvalidContentError;
        } });
        var FleekConfigMissingFileError_1 = require_FleekConfigMissingFileError2();
        Object.defineProperty(exports22, "FleekConfigMissingFileError", { enumerable: true, get: function() {
          return FleekConfigMissingFileError_1.FleekConfigMissingFileError;
        } });
        var ApplicationWhitelistDomainDuplicityError_1 = require_ApplicationWhitelistDomainDuplicityError2();
        Object.defineProperty(exports22, "ApplicationWhitelistDomainDuplicityError", { enumerable: true, get: function() {
          return ApplicationWhitelistDomainDuplicityError_1.ApplicationWhitelistDomainDuplicityError;
        } });
        var ApplicationAlreadyExistsError_1 = require_ApplicationAlreadyExistsError2();
        Object.defineProperty(exports22, "ApplicationAlreadyExistsError", { enumerable: true, get: function() {
          return ApplicationAlreadyExistsError_1.ApplicationAlreadyExistsError;
        } });
        var ApplicationsNotFoundError_1 = require_ApplicationsNotFoundError2();
        Object.defineProperty(exports22, "ApplicationsNotFoundError", { enumerable: true, get: function() {
          return ApplicationsNotFoundError_1.ApplicationsNotFoundError;
        } });
        var ApplicationNotFoundError_1 = require_ApplicationNotFoundError2();
        Object.defineProperty(exports22, "ApplicationNotFoundError", { enumerable: true, get: function() {
          return ApplicationNotFoundError_1.ApplicationNotFoundError;
        } });
        var ApplicationNameInvalidError_1 = require_ApplicationNameInvalidError2();
        Object.defineProperty(exports22, "ApplicationNameInvalidError", { enumerable: true, get: function() {
          return ApplicationNameInvalidError_1.ApplicationNameInvalidError;
        } });
        var EnsRecordNotFoundError_1 = require_EnsRecordNotFoundError2();
        Object.defineProperty(exports22, "EnsRecordNotFoundError", { enumerable: true, get: function() {
          return EnsRecordNotFoundError_1.EnsRecordNotFoundError;
        } });
        var EnsRecordAlreadyExistsInProjectError_1 = require_EnsRecordAlreadyExistsInProjectError2();
        Object.defineProperty(exports22, "EnsRecordAlreadyExistsInProjectError", { enumerable: true, get: function() {
          return EnsRecordAlreadyExistsInProjectError_1.EnsRecordAlreadyExistsInProjectError;
        } });
        var EnsNameInvalidError_1 = require_EnsNameInvalidError2();
        Object.defineProperty(exports22, "EnsNameInvalidError", { enumerable: true, get: function() {
          return EnsNameInvalidError_1.EnsNameInvalidError;
        } });
        var EnsRecordInPendingStateError_1 = require_EnsRecordInPendingStateError2();
        Object.defineProperty(exports22, "EnsRecordInPendingStateError", { enumerable: true, get: function() {
          return EnsRecordInPendingStateError_1.EnsRecordInPendingStateError;
        } });
        var InvalidPersonalAccessTokenError_1 = require_InvalidPersonalAccessTokenError2();
        Object.defineProperty(exports22, "InvalidPersonalAccessTokenError", { enumerable: true, get: function() {
          return InvalidPersonalAccessTokenError_1.InvalidPersonalAccessTokenError;
        } });
        var PersonalAccessTokenNotFoundError_1 = require_PersonalAccessTokenNotFoundError2();
        Object.defineProperty(exports22, "PersonalAccessTokenNotFoundError", { enumerable: true, get: function() {
          return PersonalAccessTokenNotFoundError_1.PersonalAccessTokenNotFoundError;
        } });
        var PrivateGatewayNotFoundError_1 = require_PrivateGatewayNotFoundError2();
        Object.defineProperty(exports22, "PrivateGatewayNotFoundError", { enumerable: true, get: function() {
          return PrivateGatewayNotFoundError_1.PrivateGatewayNotFoundError;
        } });
        var PrivateGatewayAlreadyExistsError_1 = require_PrivateGatewayAlreadyExistsError2();
        Object.defineProperty(exports22, "PrivateGatewayAlreadyExistsError", { enumerable: true, get: function() {
          return PrivateGatewayAlreadyExistsError_1.PrivateGatewayAlreadyExistsError;
        } });
        var PrivateGatewayNameInvalidError_1 = require_PrivateGatewayNameInvalidError2();
        Object.defineProperty(exports22, "PrivateGatewayNameInvalidError", { enumerable: true, get: function() {
          return PrivateGatewayNameInvalidError_1.PrivateGatewayNameInvalidError;
        } });
        var PrivateGatewaysNotFoundError_1 = require_PrivateGatewaysNotFoundError2();
        Object.defineProperty(exports22, "PrivateGatewaysNotFoundError", { enumerable: true, get: function() {
          return PrivateGatewaysNotFoundError_1.PrivateGatewaysNotFoundError;
        } });
        var TemplateAlreadyExistsError_1 = require_TemplateAlreadyExistsError2();
        Object.defineProperty(exports22, "TemplateAlreadyExistsError", { enumerable: true, get: function() {
          return TemplateAlreadyExistsError_1.TemplateAlreadyExistsError;
        } });
        var TemplateNotFoundError_1 = require_TemplateNotFoundError2();
        Object.defineProperty(exports22, "TemplateNotFoundError", { enumerable: true, get: function() {
          return TemplateNotFoundError_1.TemplateNotFoundError;
        } });
        var UserHasNoAccessToAnotherUserError_1 = require_UserHasNoAccessToAnotherUserError2();
        Object.defineProperty(exports22, "UserHasNoAccessToAnotherUserError", { enumerable: true, get: function() {
          return UserHasNoAccessToAnotherUserError_1.UserHasNoAccessToAnotherUserError;
        } });
        var SiteFrameworkAlreadyExistsError_1 = require_SiteFrameworkAlreadyExistsError2();
        Object.defineProperty(exports22, "SiteFrameworkAlreadyExistsError", { enumerable: true, get: function() {
          return SiteFrameworkAlreadyExistsError_1.SiteFrameworkAlreadyExistsError;
        } });
        var SiteFrameworkNotFoundError_1 = require_SiteFrameworkNotFoundError2();
        Object.defineProperty(exports22, "SiteFrameworkNotFoundError", { enumerable: true, get: function() {
          return SiteFrameworkNotFoundError_1.SiteFrameworkNotFoundError;
        } });
        var TemplateCategoryNotFoundError_1 = require_TemplateCategoryNotFoundError2();
        Object.defineProperty(exports22, "TemplateCategoryNotFoundError", { enumerable: true, get: function() {
          return TemplateCategoryNotFoundError_1.TemplateCategoryNotFoundError;
        } });
        var TemplateDeploymentNotFoundError_1 = require_TemplateDeploymentNotFoundError2();
        Object.defineProperty(exports22, "TemplateDeploymentNotFoundError", { enumerable: true, get: function() {
          return TemplateDeploymentNotFoundError_1.TemplateDeploymentNotFoundError;
        } });
        var ProjectMembershipHasInefficientRoleError_1 = require_ProjectMembershipHasInefficientRoleError2();
        Object.defineProperty(exports22, "ProjectMembershipHasInefficientRoleError", { enumerable: true, get: function() {
          return ProjectMembershipHasInefficientRoleError_1.ProjectMembershipHasInefficientRoleError;
        } });
        var SecretGroupNotFoundError_1 = require_SecretGroupNotFoundError2();
        Object.defineProperty(exports22, "SecretGroupNotFoundError", { enumerable: true, get: function() {
          return SecretGroupNotFoundError_1.SecretGroupNotFoundError;
        } });
        var SecretNotFoundError_1 = require_SecretNotFoundError2();
        Object.defineProperty(exports22, "SecretNotFoundError", { enumerable: true, get: function() {
          return SecretNotFoundError_1.SecretNotFoundError;
        } });
        var SecretVisibilityAlreadyEncryptedError_1 = require_SecretVisibilityAlreadyEncryptedError2();
        Object.defineProperty(exports22, "SecretVisibilityAlreadyEncryptedError", { enumerable: true, get: function() {
          return SecretVisibilityAlreadyEncryptedError_1.SecretVisibilityAlreadyEncryptedError;
        } });
        var SecretKeyAlreadyExistsError_1 = require_SecretKeyAlreadyExistsError2();
        Object.defineProperty(exports22, "SecretKeyAlreadyExistsError", { enumerable: true, get: function() {
          return SecretKeyAlreadyExistsError_1.SecretKeyAlreadyExistsError;
        } });
        var SecretFailToEncryptError_1 = require_SecretFailToEncryptError2();
        Object.defineProperty(exports22, "SecretFailToEncryptError", { enumerable: true, get: function() {
          return SecretFailToEncryptError_1.SecretFailToEncryptError;
        } });
        var PinNotFoundError_1 = require_PinNotFoundError2();
        Object.defineProperty(exports22, "PinNotFoundError", { enumerable: true, get: function() {
          return PinNotFoundError_1.PinNotFoundError;
        } });
        var PinAlreadyExistsInProjectError_1 = require_PinAlreadyExistsInProjectError2();
        Object.defineProperty(exports22, "PinAlreadyExistsInProjectError", { enumerable: true, get: function() {
          return PinAlreadyExistsInProjectError_1.PinAlreadyExistsInProjectError;
        } });
        var UnstoppableDeploymentError_1 = require_UnstoppableDeploymentError2();
        Object.defineProperty(exports22, "UnstoppableDeploymentError", { enumerable: true, get: function() {
          return UnstoppableDeploymentError_1.UnstoppableDeploymentError;
        } });
        var SiteDeploymentNotReleasedError_1 = require_SiteDeploymentNotReleasedError2();
        Object.defineProperty(exports22, "SiteDeploymentNotReleasedError", { enumerable: true, get: function() {
          return SiteDeploymentNotReleasedError_1.SiteDeploymentNotReleasedError;
        } });
        var InvalidDeploymentTriggerError_1 = require_InvalidDeploymentTriggerError2();
        Object.defineProperty(exports22, "InvalidDeploymentTriggerError", { enumerable: true, get: function() {
          return InvalidDeploymentTriggerError_1.InvalidDeploymentTriggerError;
        } });
        var IpfsGatewayContentUnreachableError_1 = require_IpfsGatewayContentUnreachableError2();
        Object.defineProperty(exports22, "IpfsGatewayContentUnreachableError", { enumerable: true, get: function() {
          return IpfsGatewayContentUnreachableError_1.IpfsGatewayContentUnreachableError;
        } });
        var InvitationNotFoundError_1 = require_InvitationNotFoundError2();
        Object.defineProperty(exports22, "InvitationNotFoundError", { enumerable: true, get: function() {
          return InvitationNotFoundError_1.InvitationNotFoundError;
        } });
        var MigrationTokenInvalidError_1 = require_MigrationTokenInvalidError2();
        Object.defineProperty(exports22, "MigrationTokenInvalidError", { enumerable: true, get: function() {
          return MigrationTokenInvalidError_1.MigrationTokenInvalidError;
        } });
        var MigrationRequestsAlreadyExistError_1 = require_MigrationRequestsAlreadyExistError2();
        Object.defineProperty(exports22, "MigrationRequestsAlreadyExistError", { enumerable: true, get: function() {
          return MigrationRequestsAlreadyExistError_1.MigrationRequestsAlreadyExistError;
        } });
        var MigrationRequestNotFoundError_1 = require_MigrationRequestNotFoundError2();
        Object.defineProperty(exports22, "MigrationRequestNotFoundError", { enumerable: true, get: function() {
          return MigrationRequestNotFoundError_1.MigrationRequestNotFoundError;
        } });
        var MigrationRequestInPendingStateError_1 = require_MigrationRequestInPendingStateError2();
        Object.defineProperty(exports22, "MigrationRequestInPendingStateError", { enumerable: true, get: function() {
          return MigrationRequestInPendingStateError_1.MigrationRequestInPendingStateError;
        } });
        var ProjectInvitationAlreadyExistError_1 = require_ProjectInvitationAlreadyExistError2();
        Object.defineProperty(exports22, "ProjectInvitationAlreadyExistError", { enumerable: true, get: function() {
          return ProjectInvitationAlreadyExistError_1.ProjectInvitationAlreadyExistError;
        } });
        var ProjectMembershipAlreadyExistError_1 = require_ProjectMembershipAlreadyExistError2();
        Object.defineProperty(exports22, "ProjectMembershipAlreadyExistError", { enumerable: true, get: function() {
          return ProjectMembershipAlreadyExistError_1.ProjectMembershipAlreadyExistError;
        } });
        var ProjectMembershipNoOwnersError_1 = require_ProjectMembershipNoOwnersError2();
        Object.defineProperty(exports22, "ProjectMembershipNoOwnersError", { enumerable: true, get: function() {
          return ProjectMembershipNoOwnersError_1.ProjectMembershipNoOwnersError;
        } });
        var UploadedS3KeyNotFoundError_1 = require_UploadedS3KeyNotFoundError2();
        Object.defineProperty(exports22, "UploadedS3KeyNotFoundError", { enumerable: true, get: function() {
          return UploadedS3KeyNotFoundError_1.UploadedS3KeyNotFoundError;
        } });
        var PathIsNotADirectoryError_1 = require_PathIsNotADirectoryError2();
        Object.defineProperty(exports22, "PathIsNotADirectoryError", { enumerable: true, get: function() {
          return PathIsNotADirectoryError_1.PathIsNotADirectoryError;
        } });
        var FleekFunctionAlreadyExistsError_1 = require_FleekFunctionAlreadyExistsError2();
        Object.defineProperty(exports22, "FleekFunctionAlreadyExistsError", { enumerable: true, get: function() {
          return FleekFunctionAlreadyExistsError_1.FleekFunctionAlreadyExistsError;
        } });
        var FleekFunctionNotFoundError_1 = require_FleekFunctionNotFoundError2();
        Object.defineProperty(exports22, "FleekFunctionNotFoundError", { enumerable: true, get: function() {
          return FleekFunctionNotFoundError_1.FleekFunctionNotFoundError;
        } });
        var FleekFunctionDeploymentNotFoundError_1 = require_FleekFunctionDeploymentNotFoundError2();
        Object.defineProperty(exports22, "FleekFunctionDeploymentNotFoundError", { enumerable: true, get: function() {
          return FleekFunctionDeploymentNotFoundError_1.FleekFunctionDeploymentNotFoundError;
        } });
        var FleekFunctionsNotFoundError_1 = require_FleekFunctionsNotFoundError2();
        Object.defineProperty(exports22, "FleekFunctionsNotFoundError", { enumerable: true, get: function() {
          return FleekFunctionsNotFoundError_1.FleekFunctionsNotFoundError;
        } });
        var FleekFunctionPathNotValidError_1 = require_FleekFunctionPathNotValidError2();
        Object.defineProperty(exports22, "FleekFunctionPathNotValidError", { enumerable: true, get: function() {
          return FleekFunctionPathNotValidError_1.FleekFunctionPathNotValidError;
        } });
        var FleekFunctionNameNotValidError_1 = require_FleekFunctionNameNotValidError2();
        Object.defineProperty(exports22, "FleekFunctionNameNotValidError", { enumerable: true, get: function() {
          return FleekFunctionNameNotValidError_1.FleekFunctionNameNotValidError;
        } });
        var FleekFunctionStatusNotValidError_1 = require_FleekFunctionStatusNotValidError2();
        Object.defineProperty(exports22, "FleekFunctionStatusNotValidError", { enumerable: true, get: function() {
          return FleekFunctionStatusNotValidError_1.FleekFunctionStatusNotValidError;
        } });
        var FleekFunctionSlugNotValidError_1 = require_FleekFunctionSlugNotValidError2();
        Object.defineProperty(exports22, "FleekFunctionSlugNotValidError", { enumerable: true, get: function() {
          return FleekFunctionSlugNotValidError_1.FleekFunctionSlugNotValidError;
        } });
        var MaintenanceError_1 = require_MaintenanceError2();
        Object.defineProperty(exports22, "MaintenanceError", { enumerable: true, get: function() {
          return MaintenanceError_1.MaintenanceError;
        } });
        var UserHasNoAccessToFeatureError_1 = require_UserHasNoAccessToFeatureError2();
        Object.defineProperty(exports22, "UserHasNoAccessToFeatureError", { enumerable: true, get: function() {
          return UserHasNoAccessToFeatureError_1.UserHasNoAccessToFeatureError;
        } });
        var InvalidCidError_1 = require_InvalidCidError2();
        Object.defineProperty(exports22, "InvalidCidError", { enumerable: true, get: function() {
          return InvalidCidError_1.InvalidCidError;
        } });
        var ValidationError_1 = require_ValidationError2();
        Object.defineProperty(exports22, "ValidationError", { enumerable: true, get: function() {
          return ValidationError_1.ValidationError;
        } });
        var UserInBlocklistError_1 = require_UserInBlocklistError2();
        Object.defineProperty(exports22, "UserInBlocklistError", { enumerable: true, get: function() {
          return UserInBlocklistError_1.UserInBlocklistError;
        } });
        var EnsNameContentHashCodecMistmatchError_1 = require_EnsNameContentHashCodecMistmatchError2();
        Object.defineProperty(exports22, "EnsNameContentHashCodecMistmatchError", { enumerable: true, get: function() {
          return EnsNameContentHashCodecMistmatchError_1.EnsNameContentHashCodecMistmatchError;
        } });
        var EnsNameContentHashUndefinedError_1 = require_EnsNameContentHashUndefinedError2();
        Object.defineProperty(exports22, "EnsNameContentHashUndefinedError", { enumerable: true, get: function() {
          return EnsNameContentHashUndefinedError_1.EnsNameContentHashUndefinedError;
        } });
        var DnsConfigAlreadyExistsError_1 = require_DnsConfigAlreadyExistsError2();
        Object.defineProperty(exports22, "DnsConfigAlreadyExistsError", { enumerable: true, get: function() {
          return DnsConfigAlreadyExistsError_1.DnsConfigAlreadyExistsError;
        } });
        var DnsConfigNotFoundError_1 = require_DnsConfigNotFoundError2();
        Object.defineProperty(exports22, "DnsConfigNotFoundError", { enumerable: true, get: function() {
          return DnsConfigNotFoundError_1.DnsConfigNotFoundError;
        } });
        var TwoFactorSecretKeyFailedToEncryptError_1 = require_TwoFactorSecretKeyFailedToEncryptError2();
        Object.defineProperty(exports22, "TwoFactorSecretKeyFailedToEncryptError", { enumerable: true, get: function() {
          return TwoFactorSecretKeyFailedToEncryptError_1.TwoFactorSecretKeyFailedToEncryptError;
        } });
        var UserSecretKeyAlreadyExistsError_1 = require_UserSecretKeyAlreadyExistsError2();
        Object.defineProperty(exports22, "UserSecretKeyAlreadyExistsError", { enumerable: true, get: function() {
          return UserSecretKeyAlreadyExistsError_1.UserSecretKeyAlreadyExistsError;
        } });
        var UserSecretKeyNotFoundError_1 = require_UserSecretKeyNotFoundError2();
        Object.defineProperty(exports22, "UserSecretKeyNotFoundError", { enumerable: true, get: function() {
          return UserSecretKeyNotFoundError_1.UserSecretKeyNotFoundError;
        } });
        var TwoFactorSecretKeyFailedToDecryptError_1 = require_TwoFactorSecretKeyFailedToDecryptError2();
        Object.defineProperty(exports22, "TwoFactorSecretKeyFailedToDecryptError", { enumerable: true, get: function() {
          return TwoFactorSecretKeyFailedToDecryptError_1.TwoFactorSecretKeyFailedToDecryptError;
        } });
        var RecoveryCodesAlreadyExistsError_1 = require_RecoveryCodesAlreadyExistsError2();
        Object.defineProperty(exports22, "RecoveryCodesAlreadyExistsError", { enumerable: true, get: function() {
          return RecoveryCodesAlreadyExistsError_1.RecoveryCodesAlreadyExistsError;
        } });
        var WriteFileFromStreamError_1 = require_WriteFileFromStreamError2();
        Object.defineProperty(exports22, "WriteFileFromStreamError", { enumerable: true, get: function() {
          return WriteFileFromStreamError_1.WriteFileFromStreamError;
        } });
        var InvalidTOTPTokenError_1 = require_InvalidTOTPTokenError2();
        Object.defineProperty(exports22, "InvalidTOTPTokenError", { enumerable: true, get: function() {
          return InvalidTOTPTokenError_1.InvalidTOTPTokenError;
        } });
        var InvalidRecoveryCodeError_1 = require_InvalidRecoveryCodeError2();
        Object.defineProperty(exports22, "InvalidRecoveryCodeError", { enumerable: true, get: function() {
          return InvalidRecoveryCodeError_1.InvalidRecoveryCodeError;
        } });
        var MissingTwoFactorProtectionCredentialsError_1 = require_MissingTwoFactorProtectionCredentialsError2();
        Object.defineProperty(exports22, "MissingTwoFactorProtectionCredentialsError", { enumerable: true, get: function() {
          return MissingTwoFactorProtectionCredentialsError_1.MissingTwoFactorProtectionCredentialsError;
        } });
        var DeploymentInProgressError_1 = require_DeploymentInProgressError2();
        Object.defineProperty(exports22, "DeploymentInProgressError", { enumerable: true, get: function() {
          return DeploymentInProgressError_1.DeploymentInProgressError;
        } });
        var PullzoneNotFoundForZoneIdError_1 = require_PullzoneNotFoundForZoneIdError2();
        Object.defineProperty(exports22, "PullzoneNotFoundForZoneIdError", { enumerable: true, get: function() {
          return PullzoneNotFoundForZoneIdError_1.PullzoneNotFoundForZoneIdError;
        } });
        var RecoveryCodeFailedToEncryptError_1 = require_RecoveryCodeFailedToEncryptError2();
        Object.defineProperty(exports22, "RecoveryCodeFailedToEncryptError", { enumerable: true, get: function() {
          return RecoveryCodeFailedToEncryptError_1.RecoveryCodeFailedToEncryptError;
        } });
        var RecoveryCodeFailedToDecryptError_1 = require_RecoveryCodeFailedToDecryptError2();
        Object.defineProperty(exports22, "RecoveryCodeFailedToDecryptError", { enumerable: true, get: function() {
          return RecoveryCodeFailedToDecryptError_1.RecoveryCodeFailedToDecryptError;
        } });
        var PermissionGroupNotFoundError_1 = require_PermissionGroupNotFoundError2();
        Object.defineProperty(exports22, "PermissionGroupNotFoundError", { enumerable: true, get: function() {
          return PermissionGroupNotFoundError_1.PermissionGroupNotFoundError;
        } });
        var PermissionScopeError_1 = require_PermissionScopeError2();
        Object.defineProperty(exports22, "PermissionScopeError", { enumerable: true, get: function() {
          return PermissionScopeError_1.PermissionScopeError;
        } });
        var InvalidAdminAccessTokenError_1 = require_InvalidAdminAccessTokenError2();
        Object.defineProperty(exports22, "InvalidAdminAccessTokenError", { enumerable: true, get: function() {
          return InvalidAdminAccessTokenError_1.InvalidAdminAccessTokenError;
        } });
        var MissingExpectedDataError_1 = require_MissingExpectedDataError2();
        Object.defineProperty(exports22, "MissingExpectedDataError", { enumerable: true, get: function() {
          return MissingExpectedDataError_1.MissingExpectedDataError;
        } });
        var EnvNotSetError_1 = require_EnvNotSetError2();
        Object.defineProperty(exports22, "EnvNotSetError", { enumerable: true, get: function() {
          return EnvNotSetError_1.EnvNotSetError;
        } });
        var GitSecretsFailedToEncryptError_1 = require_GitSecretsFailedToEncryptError2();
        Object.defineProperty(exports22, "GitSecretsFailedToEncryptError", { enumerable: true, get: function() {
          return GitSecretsFailedToEncryptError_1.GitSecretsFailedToEncryptError;
        } });
        var GitConfigFailedToParseError_1 = require_GitConfigFailedToParseError2();
        Object.defineProperty(exports22, "GitConfigFailedToParseError", { enumerable: true, get: function() {
          return GitConfigFailedToParseError_1.GitConfigFailedToParseError;
        } });
        var PathIsNotAFileError_1 = require_PathIsNotAFileError2();
        Object.defineProperty(exports22, "PathIsNotAFileError", { enumerable: true, get: function() {
          return PathIsNotAFileError_1.PathIsNotAFileError;
        } });
        var FleekFunctionBundlingFailedError_1 = require_FleekFunctionBundlingFailedError2();
        Object.defineProperty(exports22, "FleekFunctionBundlingFailedError", { enumerable: true, get: function() {
          return FleekFunctionBundlingFailedError_1.FleekFunctionBundlingFailedError;
        } });
        var GitIntegrationNotFoundError_1 = require_GitIntegrationNotFoundError2();
        Object.defineProperty(exports22, "GitIntegrationNotFoundError", { enumerable: true, get: function() {
          return GitIntegrationNotFoundError_1.GitIntegrationNotFoundError;
        } });
        var GitProviderNotFoundError_1 = require_GitProviderNotFoundError2();
        Object.defineProperty(exports22, "GitProviderNotFoundError", { enumerable: true, get: function() {
          return GitProviderNotFoundError_1.GitProviderNotFoundError;
        } });
        var ExpectedOneOfValuesError_1 = require_ExpectedOneOfValuesError2();
        Object.defineProperty(exports22, "ExpectedOneOfValuesError", { enumerable: true, get: function() {
          return ExpectedOneOfValuesError_1.ExpectedOneOfValuesError;
        } });
        var InvalidJSONFormat_1 = require_InvalidJSONFormat2();
        Object.defineProperty(exports22, "InvalidJSONFormat", { enumerable: true, get: function() {
          return InvalidJSONFormat_1.InvalidJSONFormat;
        } });
        var StorageUploadFileCountQuotaExceededError_1 = require_StorageUploadFileCountQuotaExceededError2();
        Object.defineProperty(exports22, "StorageUploadFileCountQuotaExceededError", { enumerable: true, get: function() {
          return StorageUploadFileCountQuotaExceededError_1.StorageUploadFileCountQuotaExceededError;
        } });
        var StorageUploadTotalSizeQuotaExceededError_1 = require_StorageUploadTotalSizeQuotaExceededError2();
        Object.defineProperty(exports22, "StorageUploadTotalSizeQuotaExceededError", { enumerable: true, get: function() {
          return StorageUploadTotalSizeQuotaExceededError_1.StorageUploadTotalSizeQuotaExceededError;
        } });
        var GitProviderNotSupportedError_1 = require_GitProviderNotSupportedError2();
        Object.defineProperty(exports22, "GitProviderNotSupportedError", { enumerable: true, get: function() {
          return GitProviderNotSupportedError_1.GitProviderNotSupportedError;
        } });
        var GitProviderNotAuthorizedError_1 = require_GitProviderNotAuthorizedError2();
        Object.defineProperty(exports22, "GitProviderNotAuthorizedError", { enumerable: true, get: function() {
          return GitProviderNotAuthorizedError_1.GitProviderNotAuthorizedError;
        } });
        var GitAccessTokenInvalidError_1 = require_GitAccessTokenInvalidError2();
        Object.defineProperty(exports22, "GitAccessTokenInvalidError", { enumerable: true, get: function() {
          return GitAccessTokenInvalidError_1.GitAccessTokenInvalidError;
        } });
        var QueuedDeploymentsLimitError_1 = require_QueuedDeploymentsLimitError2();
        Object.defineProperty(exports22, "QueuedDeploymentsLimitError", { enumerable: true, get: function() {
          return QueuedDeploymentsLimitError_1.QueuedDeploymentsLimitError;
        } });
        var GitIntegrationInstallationConflictError_1 = require_GitIntegrationInstallationConflictError2();
        Object.defineProperty(exports22, "GitIntegrationInstallationConflictError", { enumerable: true, get: function() {
          return GitIntegrationInstallationConflictError_1.GitIntegrationInstallationConflictError;
        } });
        var GitLinkMultipleAccountError_1 = require_GitLinkMultipleAccountError2();
        Object.defineProperty(exports22, "GitLinkMultipleAccountError", { enumerable: true, get: function() {
          return GitLinkMultipleAccountError_1.GitLinkMultipleAccountError;
        } });
        var GitRepoByNameAndOwnerNotFoundError_1 = require_GitRepoByNameAndOwnerNotFoundError2();
        Object.defineProperty(exports22, "GitRepoByNameAndOwnerNotFoundError", { enumerable: true, get: function() {
          return GitRepoByNameAndOwnerNotFoundError_1.GitRepoByNameAndOwnerNotFoundError;
        } });
        var GitAccessTokenNotFoundError_1 = require_GitAccessTokenNotFoundError2();
        Object.defineProperty(exports22, "GitAccessTokenNotFoundError", { enumerable: true, get: function() {
          return GitAccessTokenNotFoundError_1.GitAccessTokenNotFoundError;
        } });
        var FolderNotFoundError_1 = require_FolderNotFoundError2();
        Object.defineProperty(exports22, "FolderNotFoundError", { enumerable: true, get: function() {
          return FolderNotFoundError_1.FolderNotFoundError;
        } });
        var FolderAlreadyExistsError_1 = require_FolderAlreadyExistsError2();
        Object.defineProperty(exports22, "FolderAlreadyExistsError", { enumerable: true, get: function() {
          return FolderAlreadyExistsError_1.FolderAlreadyExistsError;
        } });
        var FolderNameContainsReservedWordError_1 = require_FolderNameContainsReservedWordError2();
        Object.defineProperty(exports22, "FolderNameContainsReservedWordError", { enumerable: true, get: function() {
          return FolderNameContainsReservedWordError_1.FolderNameContainsReservedWordError;
        } });
        var PinsNotFoundError_1 = require_PinsNotFoundError2();
        Object.defineProperty(exports22, "PinsNotFoundError", { enumerable: true, get: function() {
          return PinsNotFoundError_1.PinsNotFoundError;
        } });
        var SiteCreationFailedError_1 = require_SiteCreationFailedError2();
        Object.defineProperty(exports22, "SiteCreationFailedError", { enumerable: true, get: function() {
          return SiteCreationFailedError_1.SiteCreationFailedError;
        } });
        var FleekFunctionInvalidWasmCodeError_1 = require_FleekFunctionInvalidWasmCodeError2();
        Object.defineProperty(exports22, "FleekFunctionInvalidWasmCodeError", { enumerable: true, get: function() {
          return FleekFunctionInvalidWasmCodeError_1.FleekFunctionInvalidWasmCodeError;
        } });
        var FleekFunctionWasmEncryptionFailedError_1 = require_FleekFunctionWasmEncryptionFailedError2();
        Object.defineProperty(exports22, "FleekFunctionWasmEncryptionFailedError", { enumerable: true, get: function() {
          return FleekFunctionWasmEncryptionFailedError_1.FleekFunctionWasmEncryptionFailedError;
        } });
        var UploadProxyStoreAsCarError_1 = require_UploadProxyStoreAsCarError2();
        Object.defineProperty(exports22, "UploadProxyStoreAsCarError", { enumerable: true, get: function() {
          return UploadProxyStoreAsCarError_1.UploadProxyStoreAsCarError;
        } });
        var UploadProxyUploadFileError_1 = require_UploadProxyUploadFileError2();
        Object.defineProperty(exports22, "UploadProxyUploadFileError", { enumerable: true, get: function() {
          return UploadProxyUploadFileError_1.UploadProxyUploadFileError;
        } });
        var IpfsDenylistUpdateWorkflowTriggerFailedError_1 = require_IpfsDenylistUpdateWorkflowTriggerFailedError2();
        Object.defineProperty(exports22, "IpfsDenylistUpdateWorkflowTriggerFailedError", { enumerable: true, get: function() {
          return IpfsDenylistUpdateWorkflowTriggerFailedError_1.IpfsDenylistUpdateWorkflowTriggerFailedError;
        } });
        var ProjectSiteLimitExceededError_1 = require_ProjectSiteLimitExceededError2();
        Object.defineProperty(exports22, "ProjectSiteLimitExceededError", { enumerable: true, get: function() {
          return ProjectSiteLimitExceededError_1.ProjectSiteLimitExceededError;
        } });
        var ProjectFleekFunctionLimitExceededError_1 = require_ProjectFleekFunctionLimitExceededError2();
        Object.defineProperty(exports22, "ProjectFleekFunctionLimitExceededError", { enumerable: true, get: function() {
          return ProjectFleekFunctionLimitExceededError_1.ProjectFleekFunctionLimitExceededError;
        } });
        var UserProjectLimitExceededError_1 = require_UserProjectLimitExceededError2();
        Object.defineProperty(exports22, "UserProjectLimitExceededError", { enumerable: true, get: function() {
          return UserProjectLimitExceededError_1.UserProjectLimitExceededError;
        } });
        var ProjectDomainsLimitExceededError_1 = require_ProjectDomainsLimitExceededError();
        Object.defineProperty(exports22, "ProjectDomainsLimitExceededError", { enumerable: true, get: function() {
          return ProjectDomainsLimitExceededError_1.ProjectDomainsLimitExceededError;
        } });
        var ProjectMembershipsLimitExceededError_1 = require_ProjectMembershipsLimitExceededError();
        Object.defineProperty(exports22, "ProjectMembershipsLimitExceededError", { enumerable: true, get: function() {
          return ProjectMembershipsLimitExceededError_1.ProjectMembershipsLimitExceededError;
        } });
        var FleekRestApiInternalError_1 = require_FleekRestApiInternalError();
        Object.defineProperty(exports22, "FleekRestApiInternalError", { enumerable: true, get: function() {
          return FleekRestApiInternalError_1.FleekRestApiInternalError;
        } });
      }
    });
    var require_digest = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/digest.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var digest = (algorithm, data) => (0, crypto_1.createHash)(algorithm).update(data).digest();
        exports22.default = digest;
      }
    });
    var require_buffer_utils = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/buffer_utils.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.concatKdf = exports22.lengthAndInput = exports22.uint32be = exports22.uint64be = exports22.p2s = exports22.concat = exports22.decoder = exports22.encoder = void 0;
        var digest_js_1 = require_digest();
        exports22.encoder = new TextEncoder();
        exports22.decoder = new TextDecoder();
        var MAX_INT32 = 2 ** 32;
        function concat(...buffers) {
          const size = buffers.reduce((acc, { length }) => acc + length, 0);
          const buf = new Uint8Array(size);
          let i = 0;
          buffers.forEach((buffer) => {
            buf.set(buffer, i);
            i += buffer.length;
          });
          return buf;
        }
        exports22.concat = concat;
        function p2s(alg, p2sInput) {
          return concat(exports22.encoder.encode(alg), new Uint8Array([0]), p2sInput);
        }
        exports22.p2s = p2s;
        function writeUInt32BE(buf, value, offset) {
          if (value < 0 || value >= MAX_INT32) {
            throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
          }
          buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
        }
        function uint64be(value) {
          const high = Math.floor(value / MAX_INT32);
          const low = value % MAX_INT32;
          const buf = new Uint8Array(8);
          writeUInt32BE(buf, high, 0);
          writeUInt32BE(buf, low, 4);
          return buf;
        }
        exports22.uint64be = uint64be;
        function uint32be(value) {
          const buf = new Uint8Array(4);
          writeUInt32BE(buf, value);
          return buf;
        }
        exports22.uint32be = uint32be;
        function lengthAndInput(input) {
          return concat(uint32be(input.length), input);
        }
        exports22.lengthAndInput = lengthAndInput;
        async function concatKdf(secret, bits, value) {
          const iterations = Math.ceil((bits >> 3) / 32);
          const res = new Uint8Array(iterations * 32);
          for (let iter = 0; iter < iterations; iter++) {
            const buf = new Uint8Array(4 + secret.length + value.length);
            buf.set(uint32be(iter + 1));
            buf.set(secret, 4);
            buf.set(value, 4 + secret.length);
            res.set(await (0, digest_js_1.default)("sha256", buf), iter * 32);
          }
          return res.slice(0, bits >> 3);
        }
        exports22.concatKdf = concatKdf;
      }
    });
    var require_base64url = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/base64url.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decode = exports22.encode = exports22.encodeBase64 = exports22.decodeBase64 = void 0;
        var buffer_1 = require("buffer");
        var buffer_utils_js_1 = require_buffer_utils();
        var encode;
        exports22.encode = encode;
        function normalize(input) {
          let encoded = input;
          if (encoded instanceof Uint8Array) {
            encoded = buffer_utils_js_1.decoder.decode(encoded);
          }
          return encoded;
        }
        if (buffer_1.Buffer.isEncoding("base64url")) {
          exports22.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64url");
        } else {
          exports22.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        var decodeBase64 = (input) => buffer_1.Buffer.from(input, "base64");
        exports22.decodeBase64 = decodeBase64;
        var encodeBase64 = (input) => buffer_1.Buffer.from(input).toString("base64");
        exports22.encodeBase64 = encodeBase64;
        var decode = (input) => buffer_1.Buffer.from(normalize(input), "base64");
        exports22.decode = decode;
      }
    });
    var require_errors5 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/errors.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.JWSSignatureVerificationFailed = exports22.JWKSTimeout = exports22.JWKSMultipleMatchingKeys = exports22.JWKSNoMatchingKey = exports22.JWKSInvalid = exports22.JWKInvalid = exports22.JWTInvalid = exports22.JWSInvalid = exports22.JWEInvalid = exports22.JWEDecryptionFailed = exports22.JOSENotSupported = exports22.JOSEAlgNotAllowed = exports22.JWTExpired = exports22.JWTClaimValidationFailed = exports22.JOSEError = void 0;
        var JOSEError = class extends Error {
          static get code() {
            return "ERR_JOSE_GENERIC";
          }
          constructor(message) {
            var _a;
            super(message);
            this.code = "ERR_JOSE_GENERIC";
            this.name = this.constructor.name;
            (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
          }
        };
        exports22.JOSEError = JOSEError;
        var JWTClaimValidationFailed = class extends JOSEError {
          static get code() {
            return "ERR_JWT_CLAIM_VALIDATION_FAILED";
          }
          constructor(message, claim = "unspecified", reason = "unspecified") {
            super(message);
            this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
            this.claim = claim;
            this.reason = reason;
          }
        };
        exports22.JWTClaimValidationFailed = JWTClaimValidationFailed;
        var JWTExpired = class extends JOSEError {
          static get code() {
            return "ERR_JWT_EXPIRED";
          }
          constructor(message, claim = "unspecified", reason = "unspecified") {
            super(message);
            this.code = "ERR_JWT_EXPIRED";
            this.claim = claim;
            this.reason = reason;
          }
        };
        exports22.JWTExpired = JWTExpired;
        var JOSEAlgNotAllowed = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
          }
          static get code() {
            return "ERR_JOSE_ALG_NOT_ALLOWED";
          }
        };
        exports22.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
        var JOSENotSupported = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JOSE_NOT_SUPPORTED";
          }
          static get code() {
            return "ERR_JOSE_NOT_SUPPORTED";
          }
        };
        exports22.JOSENotSupported = JOSENotSupported;
        var JWEDecryptionFailed = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWE_DECRYPTION_FAILED";
            this.message = "decryption operation failed";
          }
          static get code() {
            return "ERR_JWE_DECRYPTION_FAILED";
          }
        };
        exports22.JWEDecryptionFailed = JWEDecryptionFailed;
        var JWEInvalid = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWE_INVALID";
          }
          static get code() {
            return "ERR_JWE_INVALID";
          }
        };
        exports22.JWEInvalid = JWEInvalid;
        var JWSInvalid = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWS_INVALID";
          }
          static get code() {
            return "ERR_JWS_INVALID";
          }
        };
        exports22.JWSInvalid = JWSInvalid;
        var JWTInvalid = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWT_INVALID";
          }
          static get code() {
            return "ERR_JWT_INVALID";
          }
        };
        exports22.JWTInvalid = JWTInvalid;
        var JWKInvalid = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWK_INVALID";
          }
          static get code() {
            return "ERR_JWK_INVALID";
          }
        };
        exports22.JWKInvalid = JWKInvalid;
        var JWKSInvalid = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWKS_INVALID";
          }
          static get code() {
            return "ERR_JWKS_INVALID";
          }
        };
        exports22.JWKSInvalid = JWKSInvalid;
        var JWKSNoMatchingKey = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWKS_NO_MATCHING_KEY";
            this.message = "no applicable key found in the JSON Web Key Set";
          }
          static get code() {
            return "ERR_JWKS_NO_MATCHING_KEY";
          }
        };
        exports22.JWKSNoMatchingKey = JWKSNoMatchingKey;
        var JWKSMultipleMatchingKeys = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
            this.message = "multiple matching keys found in the JSON Web Key Set";
          }
          static get code() {
            return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
          }
        };
        exports22.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
        var JWKSTimeout = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWKS_TIMEOUT";
            this.message = "request timed out";
          }
          static get code() {
            return "ERR_JWKS_TIMEOUT";
          }
        };
        exports22.JWKSTimeout = JWKSTimeout;
        var JWSSignatureVerificationFailed = class extends JOSEError {
          constructor() {
            super(...arguments);
            this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
            this.message = "signature verification failed";
          }
          static get code() {
            return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
          }
        };
        exports22.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
      }
    });
    var require_random = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/random.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.default = void 0;
        var crypto_1 = require("crypto");
        Object.defineProperty(exports22, "default", { enumerable: true, get: function() {
          return crypto_1.randomFillSync;
        } });
      }
    });
    var require_iv = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/iv.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.bitLength = void 0;
        var errors_js_1 = require_errors5();
        var random_js_1 = require_random();
        function bitLength(alg) {
          switch (alg) {
            case "A128GCM":
            case "A128GCMKW":
            case "A192GCM":
            case "A192GCMKW":
            case "A256GCM":
            case "A256GCMKW":
              return 96;
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              return 128;
            default:
              throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
          }
        }
        exports22.bitLength = bitLength;
        exports22.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
      }
    });
    var require_check_iv_length = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_iv_length.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        var iv_js_1 = require_iv();
        var checkIvLength = (enc, iv) => {
          if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
            throw new errors_js_1.JWEInvalid("Invalid Initialization Vector length");
          }
        };
        exports22.default = checkIvLength;
      }
    });
    var require_is_key_object = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_object.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var util = require("util");
        exports22.default = util.types.isKeyObject ? (obj) => util.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof crypto_1.KeyObject;
      }
    });
    var require_check_cek_length = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        var is_key_object_js_1 = require_is_key_object();
        var checkCekLength = (enc, cek) => {
          let expected;
          switch (enc) {
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              expected = parseInt(enc.slice(-3), 10);
              break;
            case "A128GCM":
            case "A192GCM":
            case "A256GCM":
              expected = parseInt(enc.slice(1, 4), 10);
              break;
            default:
              throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
          }
          if (cek instanceof Uint8Array) {
            const actual = cek.byteLength << 3;
            if (actual !== expected) {
              throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
            }
            return;
          }
          if ((0, is_key_object_js_1.default)(cek) && cek.type === "secret") {
            const actual = cek.symmetricKeySize << 3;
            if (actual !== expected) {
              throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
            }
            return;
          }
          throw new TypeError("Invalid Content Encryption Key type");
        };
        exports22.default = checkCekLength;
      }
    });
    var require_timing_safe_equal = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var timingSafeEqual = crypto_1.timingSafeEqual;
        exports22.default = timingSafeEqual;
      }
    });
    var require_cbc_tag = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var buffer_utils_js_1 = require_buffer_utils();
        function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
          const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
          const hmac = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
          hmac.update(macData);
          return hmac.digest().slice(0, keySize >> 3);
        }
        exports22.default = cbcTag;
      }
    });
    var require_webcrypto = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/webcrypto.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.isCryptoKey = void 0;
        var crypto = require("crypto");
        var util = require("util");
        var webcrypto = crypto.webcrypto;
        exports22.default = webcrypto;
        exports22.isCryptoKey = util.types.isCryptoKey ? (key) => util.types.isCryptoKey(key) : (key) => false;
      }
    });
    var require_env = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/env.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.isCloudflareWorkers = void 0;
        function isCloudflareWorkers() {
          return false;
        }
        exports22.isCloudflareWorkers = isCloudflareWorkers;
      }
    });
    var require_crypto_key = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/crypto_key.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.checkEncCryptoKey = exports22.checkSigCryptoKey = void 0;
        var env_js_1 = require_env();
        function unusable(name, prop = "algorithm.name") {
          return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
        }
        function isAlgorithm(algorithm, name) {
          return algorithm.name === name;
        }
        function getHashLength(hash) {
          return parseInt(hash.name.slice(4), 10);
        }
        function getNamedCurve(alg) {
          switch (alg) {
            case "ES256":
              return "P-256";
            case "ES384":
              return "P-384";
            case "ES512":
              return "P-521";
            default:
              throw new Error("unreachable");
          }
        }
        function checkUsage(key, usages) {
          if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
            let msg = "CryptoKey does not support this operation, its usages must include ";
            if (usages.length > 2) {
              const last = usages.pop();
              msg += `one of ${usages.join(", ")}, or ${last}.`;
            } else if (usages.length === 2) {
              msg += `one of ${usages[0]} or ${usages[1]}.`;
            } else {
              msg += `${usages[0]}.`;
            }
            throw new TypeError(msg);
          }
        }
        function checkSigCryptoKey(key, alg, ...usages) {
          switch (alg) {
            case "HS256":
            case "HS384":
            case "HS512": {
              if (!isAlgorithm(key.algorithm, "HMAC"))
                throw unusable("HMAC");
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                throw unusable(`SHA-${expected}`, "algorithm.hash");
              break;
            }
            case "RS256":
            case "RS384":
            case "RS512": {
              if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
                throw unusable("RSASSA-PKCS1-v1_5");
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                throw unusable(`SHA-${expected}`, "algorithm.hash");
              break;
            }
            case "PS256":
            case "PS384":
            case "PS512": {
              if (!isAlgorithm(key.algorithm, "RSA-PSS"))
                throw unusable("RSA-PSS");
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                throw unusable(`SHA-${expected}`, "algorithm.hash");
              break;
            }
            case ((0, env_js_1.isCloudflareWorkers)() && "EdDSA"): {
              if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
                throw unusable("NODE-ED25519");
              break;
            }
            case "EdDSA": {
              if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
                throw unusable("Ed25519 or Ed448");
              }
              break;
            }
            case "ES256":
            case "ES384":
            case "ES512": {
              if (!isAlgorithm(key.algorithm, "ECDSA"))
                throw unusable("ECDSA");
              const expected = getNamedCurve(alg);
              const actual = key.algorithm.namedCurve;
              if (actual !== expected)
                throw unusable(expected, "algorithm.namedCurve");
              break;
            }
            default:
              throw new TypeError("CryptoKey does not support this operation");
          }
          checkUsage(key, usages);
        }
        exports22.checkSigCryptoKey = checkSigCryptoKey;
        function checkEncCryptoKey(key, alg, ...usages) {
          switch (alg) {
            case "A128GCM":
            case "A192GCM":
            case "A256GCM": {
              if (!isAlgorithm(key.algorithm, "AES-GCM"))
                throw unusable("AES-GCM");
              const expected = parseInt(alg.slice(1, 4), 10);
              const actual = key.algorithm.length;
              if (actual !== expected)
                throw unusable(expected, "algorithm.length");
              break;
            }
            case "A128KW":
            case "A192KW":
            case "A256KW": {
              if (!isAlgorithm(key.algorithm, "AES-KW"))
                throw unusable("AES-KW");
              const expected = parseInt(alg.slice(1, 4), 10);
              const actual = key.algorithm.length;
              if (actual !== expected)
                throw unusable(expected, "algorithm.length");
              break;
            }
            case "ECDH": {
              switch (key.algorithm.name) {
                case "ECDH":
                case "X25519":
                case "X448":
                  break;
                default:
                  throw unusable("ECDH, X25519, or X448");
              }
              break;
            }
            case "PBES2-HS256+A128KW":
            case "PBES2-HS384+A192KW":
            case "PBES2-HS512+A256KW":
              if (!isAlgorithm(key.algorithm, "PBKDF2"))
                throw unusable("PBKDF2");
              break;
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512": {
              if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
                throw unusable("RSA-OAEP");
              const expected = parseInt(alg.slice(9), 10) || 1;
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                throw unusable(`SHA-${expected}`, "algorithm.hash");
              break;
            }
            default:
              throw new TypeError("CryptoKey does not support this operation");
          }
          checkUsage(key, usages);
        }
        exports22.checkEncCryptoKey = checkEncCryptoKey;
      }
    });
    var require_invalid_key_input = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.withAlg = void 0;
        function message(msg, actual, ...types) {
          if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}.`;
          } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}.`;
          } else {
            msg += `of type ${types[0]}.`;
          }
          if (actual == null) {
            msg += ` Received ${actual}`;
          } else if (typeof actual === "function" && actual.name) {
            msg += ` Received function ${actual.name}`;
          } else if (typeof actual === "object" && actual != null) {
            if (actual.constructor && actual.constructor.name) {
              msg += ` Received an instance of ${actual.constructor.name}`;
            }
          }
          return msg;
        }
        exports22.default = (actual, ...types) => {
          return message("Key must be ", actual, ...types);
        };
        function withAlg(alg, actual, ...types) {
          return message(`Key for the ${alg} algorithm must be `, actual, ...types);
        }
        exports22.withAlg = withAlg;
      }
    });
    var require_ciphers = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ciphers.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var ciphers;
        exports22.default = (algorithm) => {
          ciphers || (ciphers = new Set((0, crypto_1.getCiphers)()));
          return ciphers.has(algorithm);
        };
      }
    });
    var require_is_key_like = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_like.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.types = void 0;
        var webcrypto_js_1 = require_webcrypto();
        var is_key_object_js_1 = require_is_key_object();
        exports22.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
        var types = ["KeyObject"];
        exports22.types = types;
        if (globalThis.CryptoKey || (webcrypto_js_1.default === null || webcrypto_js_1.default === void 0 ? void 0 : webcrypto_js_1.default.CryptoKey)) {
          types.push("CryptoKey");
        }
      }
    });
    var require_decrypt = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/decrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var check_iv_length_js_1 = require_check_iv_length();
        var check_cek_length_js_1 = require_check_cek_length();
        var buffer_utils_js_1 = require_buffer_utils();
        var errors_js_1 = require_errors5();
        var timing_safe_equal_js_1 = require_timing_safe_equal();
        var cbc_tag_js_1 = require_cbc_tag();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var ciphers_js_1 = require_ciphers();
        var is_key_like_js_1 = require_is_key_like();
        function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
          const keySize = parseInt(enc.slice(1, 4), 10);
          if ((0, is_key_object_js_1.default)(cek)) {
            cek = cek.export();
          }
          const encKey = cek.subarray(keySize >> 3);
          const macKey = cek.subarray(0, keySize >> 3);
          const macSize = parseInt(enc.slice(-3), 10);
          const algorithm = `aes-${keySize}-cbc`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
          }
          const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
          let macCheckPassed;
          try {
            macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
          } catch {
          }
          if (!macCheckPassed) {
            throw new errors_js_1.JWEDecryptionFailed();
          }
          let plaintext;
          try {
            const decipher = (0, crypto_1.createDecipheriv)(algorithm, encKey, iv);
            plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
          } catch {
          }
          if (!plaintext) {
            throw new errors_js_1.JWEDecryptionFailed();
          }
          return plaintext;
        }
        function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
          const keySize = parseInt(enc.slice(1, 4), 10);
          const algorithm = `aes-${keySize}-gcm`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
          }
          try {
            const decipher = (0, crypto_1.createDecipheriv)(algorithm, cek, iv, { authTagLength: 16 });
            decipher.setAuthTag(tag);
            if (aad.byteLength) {
              decipher.setAAD(aad, { plaintextLength: ciphertext.length });
            }
            const plaintext = decipher.update(ciphertext);
            decipher.final();
            return plaintext;
          } catch {
            throw new errors_js_1.JWEDecryptionFailed();
          }
        }
        var decrypt = (enc, cek, ciphertext, iv, tag, aad) => {
          let key;
          if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "decrypt");
            key = crypto_1.KeyObject.from(cek);
          } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
            key = cek;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
          }
          (0, check_cek_length_js_1.default)(enc, key);
          (0, check_iv_length_js_1.default)(enc, iv);
          switch (enc) {
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
            case "A128GCM":
            case "A192GCM":
            case "A256GCM":
              return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
          }
        };
        exports22.default = decrypt;
      }
    });
    var require_zlib = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/zlib.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.deflate = exports22.inflate = void 0;
        var util_1 = require("util");
        var zlib_1 = require("zlib");
        var inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
        var deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
        var inflate = (input) => inflateRaw(input);
        exports22.inflate = inflate;
        var deflate = (input) => deflateRaw(input);
        exports22.deflate = deflate;
      }
    });
    var require_is_disjoint = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_disjoint.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var isDisjoint = (...headers) => {
          const sources = headers.filter(Boolean);
          if (sources.length === 0 || sources.length === 1) {
            return true;
          }
          let acc;
          for (const header of sources) {
            const parameters = Object.keys(header);
            if (!acc || acc.size === 0) {
              acc = new Set(parameters);
              continue;
            }
            for (const parameter of parameters) {
              if (acc.has(parameter)) {
                return false;
              }
              acc.add(parameter);
            }
          }
          return true;
        };
        exports22.default = isDisjoint;
      }
    });
    var require_is_object = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_object.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        function isObjectLike(value) {
          return typeof value === "object" && value !== null;
        }
        function isObject(input) {
          if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
            return false;
          }
          if (Object.getPrototypeOf(input) === null) {
            return true;
          }
          let proto = input;
          while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
          }
          return Object.getPrototypeOf(input) === proto;
        }
        exports22.default = isObject;
      }
    });
    var require_aeskw = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/aeskw.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.unwrap = exports22.wrap = void 0;
        var buffer_1 = require("buffer");
        var crypto_1 = require("crypto");
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var ciphers_js_1 = require_ciphers();
        var is_key_like_js_1 = require_is_key_like();
        function checkKeySize(key, alg) {
          if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
            throw new TypeError(`Invalid key size for alg: ${alg}`);
          }
        }
        function ensureKeyObject(key, alg, usage) {
          if ((0, is_key_object_js_1.default)(key)) {
            return key;
          }
          if (key instanceof Uint8Array) {
            return (0, crypto_1.createSecretKey)(key);
          }
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
            return crypto_1.KeyObject.from(key);
          }
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
        }
        var wrap = (alg, key, cek) => {
          const size = parseInt(alg.slice(1, 4), 10);
          const algorithm = `aes${size}-wrap`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
          }
          const keyObject = ensureKeyObject(key, alg, "wrapKey");
          checkKeySize(keyObject, alg);
          const cipher = (0, crypto_1.createCipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
          return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
        };
        exports22.wrap = wrap;
        var unwrap = (alg, key, encryptedKey) => {
          const size = parseInt(alg.slice(1, 4), 10);
          const algorithm = `aes${size}-wrap`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
          }
          const keyObject = ensureKeyObject(key, alg, "unwrapKey");
          checkKeySize(keyObject, alg);
          const cipher = (0, crypto_1.createDecipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
          return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
        };
        exports22.unwrap = unwrap;
      }
    });
    var require_get_named_curve = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.setCurve = exports22.weakMap = void 0;
        var buffer_1 = require("buffer");
        var crypto_1 = require("crypto");
        var errors_js_1 = require_errors5();
        var webcrypto_js_1 = require_webcrypto();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
        var p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
        var p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
        var secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
        exports22.weakMap = /* @__PURE__ */ new WeakMap();
        var namedCurveToJOSE = (namedCurve) => {
          switch (namedCurve) {
            case "prime256v1":
              return "P-256";
            case "secp384r1":
              return "P-384";
            case "secp521r1":
              return "P-521";
            case "secp256k1":
              return "secp256k1";
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
          }
        };
        var getNamedCurve = (kee, raw) => {
          var _a;
          let key;
          if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
            key = crypto_1.KeyObject.from(kee);
          } else if ((0, is_key_object_js_1.default)(kee)) {
            key = kee;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
          }
          if (key.type === "secret") {
            throw new TypeError('only "private" or "public" type keys can be used for this operation');
          }
          switch (key.asymmetricKeyType) {
            case "ed25519":
            case "ed448":
              return `Ed${key.asymmetricKeyType.slice(2)}`;
            case "x25519":
            case "x448":
              return `X${key.asymmetricKeyType.slice(1)}`;
            case "ec": {
              if (exports22.weakMap.has(key)) {
                return exports22.weakMap.get(key);
              }
              let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
              if (!namedCurve && key.type === "private") {
                namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
              } else if (!namedCurve) {
                const buf = key.export({ format: "der", type: "spki" });
                const i = buf[1] < 128 ? 14 : 15;
                const len = buf[i];
                const curveOid = buf.slice(i + 1, i + 1 + len);
                if (curveOid.equals(p256)) {
                  namedCurve = "prime256v1";
                } else if (curveOid.equals(p384)) {
                  namedCurve = "secp384r1";
                } else if (curveOid.equals(p521)) {
                  namedCurve = "secp521r1";
                } else if (curveOid.equals(secp256k1)) {
                  namedCurve = "secp256k1";
                } else {
                  throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
                }
              }
              if (raw)
                return namedCurve;
              const curve = namedCurveToJOSE(namedCurve);
              exports22.weakMap.set(key, curve);
              return curve;
            }
            default:
              throw new TypeError("Invalid asymmetric key type for this operation");
          }
        };
        function setCurve(keyObject, curve) {
          exports22.weakMap.set(keyObject, curve);
        }
        exports22.setCurve = setCurve;
        exports22.default = getNamedCurve;
      }
    });
    var require_ecdhes = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ecdhes.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ecdhAllowed = exports22.generateEpk = exports22.deriveKey = void 0;
        var crypto_1 = require("crypto");
        var util_1 = require("util");
        var get_named_curve_js_1 = require_get_named_curve();
        var buffer_utils_js_1 = require_buffer_utils();
        var errors_js_1 = require_errors5();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
        async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
          let publicKey;
          if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, "ECDH");
            publicKey = crypto_1.KeyObject.from(publicKee);
          } else if ((0, is_key_object_js_1.default)(publicKee)) {
            publicKey = publicKee;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
          }
          let privateKey;
          if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, "ECDH", "deriveBits");
            privateKey = crypto_1.KeyObject.from(privateKee);
          } else if ((0, is_key_object_js_1.default)(privateKee)) {
            privateKey = privateKee;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
          }
          const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
          const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
          return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
        }
        exports22.deriveKey = deriveKey;
        async function generateEpk(kee) {
          let key;
          if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
            key = crypto_1.KeyObject.from(kee);
          } else if ((0, is_key_object_js_1.default)(kee)) {
            key = kee;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
          }
          switch (key.asymmetricKeyType) {
            case "x25519":
              return generateKeyPair("x25519");
            case "x448": {
              return generateKeyPair("x448");
            }
            case "ec": {
              const namedCurve = (0, get_named_curve_js_1.default)(key);
              return generateKeyPair("ec", { namedCurve });
            }
            default:
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported EPK");
          }
        }
        exports22.generateEpk = generateEpk;
        var ecdhAllowed = (key) => ["P-256", "P-384", "P-521", "X25519", "X448"].includes((0, get_named_curve_js_1.default)(key));
        exports22.ecdhAllowed = ecdhAllowed;
      }
    });
    var require_check_p2s = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_p2s.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        function checkP2s(p2s) {
          if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
            throw new errors_js_1.JWEInvalid("PBES2 Salt Input must be 8 or more octets");
          }
        }
        exports22.default = checkP2s;
      }
    });
    var require_pbes2kw = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decrypt = exports22.encrypt = void 0;
        var util_1 = require("util");
        var crypto_1 = require("crypto");
        var random_js_1 = require_random();
        var buffer_utils_js_1 = require_buffer_utils();
        var base64url_js_1 = require_base64url();
        var aeskw_js_1 = require_aeskw();
        var check_p2s_js_1 = require_check_p2s();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
        function getPassword(key, alg) {
          if ((0, is_key_object_js_1.default)(key)) {
            return key.export();
          }
          if (key instanceof Uint8Array) {
            return key;
          }
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, "deriveBits", "deriveKey");
            return crypto_1.KeyObject.from(key).export();
          }
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
        }
        var encrypt2 = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
          (0, check_p2s_js_1.default)(p2s);
          const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
          const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
          const password = getPassword(key, alg);
          const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
          const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
          return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
        };
        exports22.encrypt = encrypt2;
        var decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
          (0, check_p2s_js_1.default)(p2s);
          const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
          const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
          const password = getPassword(key, alg);
          const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
          return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
        };
        exports22.decrypt = decrypt;
      }
    });
    var require_check_modulus_length = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.setModulusLength = exports22.weakMap = void 0;
        exports22.weakMap = /* @__PURE__ */ new WeakMap();
        var getLength = (buf, index) => {
          let len = buf.readUInt8(1);
          if ((len & 128) === 0) {
            if (index === 0) {
              return len;
            }
            return getLength(buf.subarray(2 + len), index - 1);
          }
          const num = len & 127;
          len = 0;
          for (let i = 0; i < num; i++) {
            len <<= 8;
            const j = buf.readUInt8(2 + i);
            len |= j;
          }
          if (index === 0) {
            return len;
          }
          return getLength(buf.subarray(2 + len), index - 1);
        };
        var getLengthOfSeqIndex = (sequence, index) => {
          const len = sequence.readUInt8(1);
          if ((len & 128) === 0) {
            return getLength(sequence.subarray(2), index);
          }
          const num = len & 127;
          return getLength(sequence.subarray(2 + num), index);
        };
        var getModulusLength = (key) => {
          var _a, _b2;
          if (exports22.weakMap.has(key)) {
            return exports22.weakMap.get(key);
          }
          const modulusLength = (_b2 = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b2 !== void 0 ? _b2 : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
          exports22.weakMap.set(key, modulusLength);
          return modulusLength;
        };
        var setModulusLength = (keyObject, modulusLength) => {
          exports22.weakMap.set(keyObject, modulusLength);
        };
        exports22.setModulusLength = setModulusLength;
        exports22.default = (key, alg) => {
          if (getModulusLength(key) < 2048) {
            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
          }
        };
      }
    });
    var require_rsaes = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/rsaes.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decrypt = exports22.encrypt = void 0;
        var crypto_1 = require("crypto");
        var check_modulus_length_js_1 = require_check_modulus_length();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var checkKey = (key, alg) => {
          if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
        };
        var resolvePadding = (alg) => {
          switch (alg) {
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512":
              return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
            case "RSA1_5":
              return crypto_1.constants.RSA_PKCS1_PADDING;
            default:
              return void 0;
          }
        };
        var resolveOaepHash = (alg) => {
          switch (alg) {
            case "RSA-OAEP":
              return "sha1";
            case "RSA-OAEP-256":
              return "sha256";
            case "RSA-OAEP-384":
              return "sha384";
            case "RSA-OAEP-512":
              return "sha512";
            default:
              return void 0;
          }
        };
        function ensureKeyObject(key, alg, ...usages) {
          if ((0, is_key_object_js_1.default)(key)) {
            return key;
          }
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
            return crypto_1.KeyObject.from(key);
          }
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
        }
        var encrypt2 = (alg, key, cek) => {
          const padding = resolvePadding(alg);
          const oaepHash = resolveOaepHash(alg);
          const keyObject = ensureKeyObject(key, alg, "wrapKey", "encrypt");
          checkKey(keyObject, alg);
          return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding }, cek);
        };
        exports22.encrypt = encrypt2;
        var decrypt = (alg, key, encryptedKey) => {
          const padding = resolvePadding(alg);
          const oaepHash = resolveOaepHash(alg);
          const keyObject = ensureKeyObject(key, alg, "unwrapKey", "decrypt");
          checkKey(keyObject, alg);
          return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding }, encryptedKey);
        };
        exports22.decrypt = decrypt;
      }
    });
    var require_cek = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/cek.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.bitLength = void 0;
        var errors_js_1 = require_errors5();
        var random_js_1 = require_random();
        function bitLength(alg) {
          switch (alg) {
            case "A128GCM":
              return 128;
            case "A192GCM":
              return 192;
            case "A256GCM":
            case "A128CBC-HS256":
              return 256;
            case "A192CBC-HS384":
              return 384;
            case "A256CBC-HS512":
              return 512;
            default:
              throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
          }
        }
        exports22.bitLength = bitLength;
        exports22.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
      }
    });
    var require_asn1 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.fromSPKI = exports22.fromPKCS8 = exports22.toPKCS8 = exports22.toSPKI = void 0;
        var crypto_1 = require("crypto");
        var buffer_1 = require("buffer");
        var webcrypto_js_1 = require_webcrypto();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var genericExport = (keyType, keyFormat, key) => {
          let keyObject;
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            if (!key.extractable) {
              throw new TypeError("CryptoKey is not extractable");
            }
            keyObject = crypto_1.KeyObject.from(key);
          } else if ((0, is_key_object_js_1.default)(key)) {
            keyObject = key;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
          }
          if (keyObject.type !== keyType) {
            throw new TypeError(`key is not a ${keyType} key`);
          }
          return keyObject.export({ format: "pem", type: keyFormat });
        };
        var toSPKI = (key) => {
          return genericExport("public", "spki", key);
        };
        exports22.toSPKI = toSPKI;
        var toPKCS8 = (key) => {
          return genericExport("private", "pkcs8", key);
        };
        exports22.toPKCS8 = toPKCS8;
        var fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
          key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ""), "base64"),
          type: "pkcs8",
          format: "der"
        });
        exports22.fromPKCS8 = fromPKCS8;
        var fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
          key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ""), "base64"),
          type: "spki",
          format: "der"
        });
        exports22.fromSPKI = fromSPKI;
      }
    });
    var require_asn1_sequence_encoder = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var buffer_1 = require("buffer");
        var errors_js_1 = require_errors5();
        var tagInteger = 2;
        var tagBitStr = 3;
        var tagOctStr = 4;
        var tagSequence = 48;
        var bZero = buffer_1.Buffer.from([0]);
        var bTagInteger = buffer_1.Buffer.from([tagInteger]);
        var bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
        var bTagSequence = buffer_1.Buffer.from([tagSequence]);
        var bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
        var encodeLength = (len) => {
          if (len < 128)
            return buffer_1.Buffer.from([len]);
          const buffer = buffer_1.Buffer.alloc(5);
          buffer.writeUInt32BE(len, 1);
          let offset = 1;
          while (buffer[offset] === 0)
            offset++;
          buffer[offset - 1] = 128 | 5 - offset;
          return buffer.slice(offset - 1);
        };
        var oids = /* @__PURE__ */ new Map([
          ["P-256", buffer_1.Buffer.from("06 08 2A 86 48 CE 3D 03 01 07".replace(/ /g, ""), "hex")],
          ["secp256k1", buffer_1.Buffer.from("06 05 2B 81 04 00 0A".replace(/ /g, ""), "hex")],
          ["P-384", buffer_1.Buffer.from("06 05 2B 81 04 00 22".replace(/ /g, ""), "hex")],
          ["P-521", buffer_1.Buffer.from("06 05 2B 81 04 00 23".replace(/ /g, ""), "hex")],
          ["ecPublicKey", buffer_1.Buffer.from("06 07 2A 86 48 CE 3D 02 01".replace(/ /g, ""), "hex")],
          ["X25519", buffer_1.Buffer.from("06 03 2B 65 6E".replace(/ /g, ""), "hex")],
          ["X448", buffer_1.Buffer.from("06 03 2B 65 6F".replace(/ /g, ""), "hex")],
          ["Ed25519", buffer_1.Buffer.from("06 03 2B 65 70".replace(/ /g, ""), "hex")],
          ["Ed448", buffer_1.Buffer.from("06 03 2B 65 71".replace(/ /g, ""), "hex")]
        ]);
        var DumbAsn1Encoder = class {
          constructor() {
            this.length = 0;
            this.elements = [];
          }
          oidFor(oid) {
            const bOid = oids.get(oid);
            if (!bOid) {
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported OID");
            }
            this.elements.push(bOid);
            this.length += bOid.length;
          }
          zero() {
            this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), bZero);
            this.length += 3;
          }
          one() {
            this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), buffer_1.Buffer.from([1]));
            this.length += 3;
          }
          unsignedInteger(integer) {
            if (integer[0] & 128) {
              const len = encodeLength(integer.length + 1);
              this.elements.push(bTagInteger, len, bZero, integer);
              this.length += 2 + len.length + integer.length;
            } else {
              let i = 0;
              while (integer[i] === 0 && (integer[i + 1] & 128) === 0)
                i++;
              const len = encodeLength(integer.length - i);
              this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));
              this.length += 1 + len.length + integer.length - i;
            }
          }
          octStr(octStr) {
            const len = encodeLength(octStr.length);
            this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
            this.length += 1 + len.length + octStr.length;
          }
          bitStr(bitS) {
            const len = encodeLength(bitS.length + 1);
            this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
            this.length += 1 + len.length + bitS.length + 1;
          }
          add(seq) {
            this.elements.push(seq);
            this.length += seq.length;
          }
          end(tag = bTagSequence) {
            const len = encodeLength(this.length);
            return buffer_1.Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);
          }
        };
        exports22.default = DumbAsn1Encoder;
      }
    });
    var require_flags = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/flags.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.jwkImport = exports22.jwkExport = exports22.rsaPssParams = exports22.oneShotCallback = void 0;
        var [major, minor] = process.versions.node.split(".").map((str) => parseInt(str, 10));
        exports22.oneShotCallback = major >= 16 || major === 15 && minor >= 13;
        exports22.rsaPssParams = !("electron" in process.versions) && (major >= 17 || major === 16 && minor >= 9);
        exports22.jwkExport = major >= 16 || major === 15 && minor >= 9;
        exports22.jwkImport = major >= 16 || major === 15 && minor >= 12;
      }
    });
    var require_jwk_to_key = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var buffer_1 = require("buffer");
        var crypto_1 = require("crypto");
        var base64url_js_1 = require_base64url();
        var errors_js_1 = require_errors5();
        var get_named_curve_js_1 = require_get_named_curve();
        var check_modulus_length_js_1 = require_check_modulus_length();
        var asn1_sequence_encoder_js_1 = require_asn1_sequence_encoder();
        var flags_js_1 = require_flags();
        var parse = (jwk) => {
          if (flags_js_1.jwkImport && jwk.kty !== "oct") {
            return jwk.d ? (0, crypto_1.createPrivateKey)({ format: "jwk", key: jwk }) : (0, crypto_1.createPublicKey)({ format: "jwk", key: jwk });
          }
          switch (jwk.kty) {
            case "oct": {
              return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
            }
            case "RSA": {
              const enc = new asn1_sequence_encoder_js_1.default();
              const isPrivate = jwk.d !== void 0;
              const modulus = buffer_1.Buffer.from(jwk.n, "base64");
              const exponent = buffer_1.Buffer.from(jwk.e, "base64");
              if (isPrivate) {
                enc.zero();
                enc.unsignedInteger(modulus);
                enc.unsignedInteger(exponent);
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, "base64"));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, "base64"));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, "base64"));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, "base64"));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, "base64"));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, "base64"));
              } else {
                enc.unsignedInteger(modulus);
                enc.unsignedInteger(exponent);
              }
              const der = enc.end();
              const createInput = {
                key: der,
                format: "der",
                type: "pkcs1"
              };
              const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
              (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
              return keyObject;
            }
            case "EC": {
              const enc = new asn1_sequence_encoder_js_1.default();
              const isPrivate = jwk.d !== void 0;
              const pub = buffer_1.Buffer.concat([
                buffer_1.Buffer.alloc(1, 4),
                buffer_1.Buffer.from(jwk.x, "base64"),
                buffer_1.Buffer.from(jwk.y, "base64")
              ]);
              if (isPrivate) {
                enc.zero();
                const enc$12 = new asn1_sequence_encoder_js_1.default();
                enc$12.oidFor("ecPublicKey");
                enc$12.oidFor(jwk.crv);
                enc.add(enc$12.end());
                const enc$2 = new asn1_sequence_encoder_js_1.default();
                enc$2.one();
                enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
                const enc$3 = new asn1_sequence_encoder_js_1.default();
                enc$3.bitStr(pub);
                const f2 = enc$3.end(buffer_1.Buffer.from([161]));
                enc$2.add(f2);
                const f = enc$2.end();
                const enc$4 = new asn1_sequence_encoder_js_1.default();
                enc$4.add(f);
                const f3 = enc$4.end(buffer_1.Buffer.from([4]));
                enc.add(f3);
                const der2 = enc.end();
                const keyObject2 = (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
                (0, get_named_curve_js_1.setCurve)(keyObject2, jwk.crv);
                return keyObject2;
              }
              const enc$1 = new asn1_sequence_encoder_js_1.default();
              enc$1.oidFor("ecPublicKey");
              enc$1.oidFor(jwk.crv);
              enc.add(enc$1.end());
              enc.bitStr(pub);
              const der = enc.end();
              const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
              (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
              return keyObject;
            }
            case "OKP": {
              const enc = new asn1_sequence_encoder_js_1.default();
              const isPrivate = jwk.d !== void 0;
              if (isPrivate) {
                enc.zero();
                const enc$12 = new asn1_sequence_encoder_js_1.default();
                enc$12.oidFor(jwk.crv);
                enc.add(enc$12.end());
                const enc$2 = new asn1_sequence_encoder_js_1.default();
                enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
                const f = enc$2.end(buffer_1.Buffer.from([4]));
                enc.add(f);
                const der2 = enc.end();
                return (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
              }
              const enc$1 = new asn1_sequence_encoder_js_1.default();
              enc$1.oidFor(jwk.crv);
              enc.add(enc$1.end());
              enc.bitStr(buffer_1.Buffer.from(jwk.x, "base64"));
              const der = enc.end();
              return (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
            }
            default:
              throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
          }
        };
        exports22.default = parse;
      }
    });
    var require_format_pem = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/format_pem.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.default = (b64, descriptor) => {
          const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
          return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
        };
      }
    });
    var require_import = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/import.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.importJWK = exports22.importPKCS8 = exports22.importX509 = exports22.importSPKI = void 0;
        var base64url_js_1 = require_base64url();
        var asn1_js_1 = require_asn1();
        var asn1_js_2 = require_asn1();
        var jwk_to_key_js_1 = require_jwk_to_key();
        var errors_js_1 = require_errors5();
        var format_pem_js_1 = require_format_pem();
        var is_object_js_1 = require_is_object();
        function getElement(seq) {
          let result = [];
          let next = 0;
          while (next < seq.length) {
            let nextPart = parseElement(seq.subarray(next));
            result.push(nextPart);
            next += nextPart.byteLength;
          }
          return result;
        }
        function parseElement(bytes) {
          let position = 0;
          let tag = bytes[0] & 31;
          position++;
          if (tag === 31) {
            tag = 0;
            while (bytes[position] >= 128) {
              tag = tag * 128 + bytes[position] - 128;
              position++;
            }
            tag = tag * 128 + bytes[position] - 128;
            position++;
          }
          let length = 0;
          if (bytes[position] < 128) {
            length = bytes[position];
            position++;
          } else if (length === 128) {
            length = 0;
            while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
              if (length > bytes.byteLength) {
                throw new TypeError("invalid indefinite form length");
              }
              length++;
            }
            const byteLength2 = position + length + 2;
            return {
              byteLength: byteLength2,
              contents: bytes.subarray(position, position + length),
              raw: bytes.subarray(0, byteLength2)
            };
          } else {
            let numberOfDigits = bytes[position] & 127;
            position++;
            length = 0;
            for (let i = 0; i < numberOfDigits; i++) {
              length = length * 256 + bytes[position];
              position++;
            }
          }
          const byteLength = position + length;
          return {
            byteLength,
            contents: bytes.subarray(position, byteLength),
            raw: bytes.subarray(0, byteLength)
          };
        }
        function spkiFromX509(buf) {
          const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
          return (0, base64url_js_1.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
        }
        function getSPKI(x509) {
          const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
          const raw = (0, base64url_js_1.decodeBase64)(pem);
          return (0, format_pem_js_1.default)(spkiFromX509(raw), "PUBLIC KEY");
        }
        async function importSPKI(spki, alg, options) {
          if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
            throw new TypeError('"spki" must be SPKI formatted string');
          }
          return (0, asn1_js_1.fromSPKI)(spki, alg, options);
        }
        exports22.importSPKI = importSPKI;
        async function importX509(x509, alg, options) {
          if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
            throw new TypeError('"x509" must be X.509 formatted string');
          }
          let spki;
          try {
            spki = getSPKI(x509);
          } catch (cause) {
            throw new TypeError("failed to parse the X.509 certificate", { cause });
          }
          return (0, asn1_js_1.fromSPKI)(spki, alg, options);
        }
        exports22.importX509 = importX509;
        async function importPKCS8(pkcs8, alg, options) {
          if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
            throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
          }
          return (0, asn1_js_2.fromPKCS8)(pkcs8, alg, options);
        }
        exports22.importPKCS8 = importPKCS8;
        async function importJWK(jwk, alg, octAsKeyObject) {
          var _a;
          if (!(0, is_object_js_1.default)(jwk)) {
            throw new TypeError("JWK must be an object");
          }
          alg || (alg = jwk.alg);
          if (typeof alg !== "string" || !alg) {
            throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
          }
          switch (jwk.kty) {
            case "oct":
              if (typeof jwk.k !== "string" || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
              }
              octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
              if (octAsKeyObject) {
                return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
              }
              return (0, base64url_js_1.decode)(jwk.k);
            case "RSA":
              if (jwk.oth !== void 0) {
                throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
              }
            case "EC":
            case "OKP":
              return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
            default:
              throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
          }
        }
        exports22.importJWK = importJWK;
      }
    });
    var require_check_key_type = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_key_type.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var symmetricTypeCheck = (alg, key) => {
          if (key instanceof Uint8Array)
            return;
          if (!(0, is_key_like_js_1.default)(key)) {
            throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, "Uint8Array"));
          }
          if (key.type !== "secret") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
          }
        };
        var asymmetricTypeCheck = (alg, key, usage) => {
          if (!(0, is_key_like_js_1.default)(key)) {
            throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types));
          }
          if (key.type === "secret") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
          }
          if (usage === "sign" && key.type === "public") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
          }
          if (usage === "decrypt" && key.type === "public") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
          }
          if (key.algorithm && usage === "verify" && key.type === "private") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
          }
          if (key.algorithm && usage === "encrypt" && key.type === "private") {
            throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
          }
        };
        var checkKeyType = (alg, key, usage) => {
          const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
          if (symmetric) {
            symmetricTypeCheck(alg, key);
          } else {
            asymmetricTypeCheck(alg, key, usage);
          }
        };
        exports22.default = checkKeyType;
      }
    });
    var require_encrypt = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/encrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var check_iv_length_js_1 = require_check_iv_length();
        var check_cek_length_js_1 = require_check_cek_length();
        var buffer_utils_js_1 = require_buffer_utils();
        var cbc_tag_js_1 = require_cbc_tag();
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var errors_js_1 = require_errors5();
        var ciphers_js_1 = require_ciphers();
        var is_key_like_js_1 = require_is_key_like();
        function cbcEncrypt(enc, plaintext, cek, iv, aad) {
          const keySize = parseInt(enc.slice(1, 4), 10);
          if ((0, is_key_object_js_1.default)(cek)) {
            cek = cek.export();
          }
          const encKey = cek.subarray(keySize >> 3);
          const macKey = cek.subarray(0, keySize >> 3);
          const algorithm = `aes-${keySize}-cbc`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
          }
          const cipher = (0, crypto_1.createCipheriv)(algorithm, encKey, iv);
          const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
          const macSize = parseInt(enc.slice(-3), 10);
          const tag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
          return { ciphertext, tag };
        }
        function gcmEncrypt(enc, plaintext, cek, iv, aad) {
          const keySize = parseInt(enc.slice(1, 4), 10);
          const algorithm = `aes-${keySize}-gcm`;
          if (!(0, ciphers_js_1.default)(algorithm)) {
            throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
          }
          const cipher = (0, crypto_1.createCipheriv)(algorithm, cek, iv, { authTagLength: 16 });
          if (aad.byteLength) {
            cipher.setAAD(aad, { plaintextLength: plaintext.length });
          }
          const ciphertext = cipher.update(plaintext);
          cipher.final();
          const tag = cipher.getAuthTag();
          return { ciphertext, tag };
        }
        var encrypt2 = (enc, plaintext, cek, iv, aad) => {
          let key;
          if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
            (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "encrypt");
            key = crypto_1.KeyObject.from(cek);
          } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
            key = cek;
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
          }
          (0, check_cek_length_js_1.default)(enc, key);
          (0, check_iv_length_js_1.default)(enc, iv);
          switch (enc) {
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              return cbcEncrypt(enc, plaintext, key, iv, aad);
            case "A128GCM":
            case "A192GCM":
            case "A256GCM":
              return gcmEncrypt(enc, plaintext, key, iv, aad);
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
          }
        };
        exports22.default = encrypt2;
      }
    });
    var require_aesgcmkw = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.unwrap = exports22.wrap = void 0;
        var encrypt_js_1 = require_encrypt();
        var decrypt_js_1 = require_decrypt();
        var iv_js_1 = require_iv();
        var base64url_js_1 = require_base64url();
        async function wrap(alg, key, cek, iv) {
          const jweAlgorithm = alg.slice(0, 7);
          iv || (iv = (0, iv_js_1.default)(jweAlgorithm));
          const { ciphertext: encryptedKey, tag } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
          return { encryptedKey, iv: (0, base64url_js_1.encode)(iv), tag: (0, base64url_js_1.encode)(tag) };
        }
        exports22.wrap = wrap;
        async function unwrap(alg, key, encryptedKey, iv, tag) {
          const jweAlgorithm = alg.slice(0, 7);
          return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
        }
        exports22.unwrap = unwrap;
      }
    });
    var require_decrypt_key_management = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var aeskw_js_1 = require_aeskw();
        var ECDH = require_ecdhes();
        var pbes2kw_js_1 = require_pbes2kw();
        var rsaes_js_1 = require_rsaes();
        var base64url_js_1 = require_base64url();
        var errors_js_1 = require_errors5();
        var cek_js_1 = require_cek();
        var import_js_1 = require_import();
        var check_key_type_js_1 = require_check_key_type();
        var is_object_js_1 = require_is_object();
        var aesgcmkw_js_1 = require_aesgcmkw();
        async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
          (0, check_key_type_js_1.default)(alg, key, "decrypt");
          switch (alg) {
            case "dir": {
              if (encryptedKey !== void 0)
                throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
              return key;
            }
            case "ECDH-ES":
              if (encryptedKey !== void 0)
                throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
            case "ECDH-ES+A128KW":
            case "ECDH-ES+A192KW":
            case "ECDH-ES+A256KW": {
              if (!(0, is_object_js_1.default)(joseHeader.epk))
                throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
              if (!ECDH.ecdhAllowed(key))
                throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
              const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
              let partyUInfo;
              let partyVInfo;
              if (joseHeader.apu !== void 0) {
                if (typeof joseHeader.apu !== "string")
                  throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
              }
              if (joseHeader.apv !== void 0) {
                if (typeof joseHeader.apv !== "string")
                  throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
              }
              const sharedSecret = await ECDH.deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
              if (alg === "ECDH-ES")
                return sharedSecret;
              if (encryptedKey === void 0)
                throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
              return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
            }
            case "RSA1_5":
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512": {
              if (encryptedKey === void 0)
                throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
              return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
            }
            case "PBES2-HS256+A128KW":
            case "PBES2-HS384+A192KW":
            case "PBES2-HS512+A256KW": {
              if (encryptedKey === void 0)
                throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
              if (typeof joseHeader.p2c !== "number")
                throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
              const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
              if (joseHeader.p2c > p2cLimit)
                throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
              if (typeof joseHeader.p2s !== "string")
                throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
              return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, (0, base64url_js_1.decode)(joseHeader.p2s));
            }
            case "A128KW":
            case "A192KW":
            case "A256KW": {
              if (encryptedKey === void 0)
                throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
              return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
            }
            case "A128GCMKW":
            case "A192GCMKW":
            case "A256GCMKW": {
              if (encryptedKey === void 0)
                throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
              if (typeof joseHeader.iv !== "string")
                throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
              if (typeof joseHeader.tag !== "string")
                throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
              const iv = (0, base64url_js_1.decode)(joseHeader.iv);
              const tag = (0, base64url_js_1.decode)(joseHeader.tag);
              return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag);
            }
            default: {
              throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
          }
        }
        exports22.default = decryptKeyManagement;
      }
    });
    var require_validate_crit = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_crit.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
          if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
            throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
          }
          if (!protectedHeader || protectedHeader.crit === void 0) {
            return /* @__PURE__ */ new Set();
          }
          if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
            throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
          }
          let recognized;
          if (recognizedOption !== void 0) {
            recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
          } else {
            recognized = recognizedDefault;
          }
          for (const parameter of protectedHeader.crit) {
            if (!recognized.has(parameter)) {
              throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
            }
            if (joseHeader[parameter] === void 0) {
              throw new Err(`Extension Header Parameter "${parameter}" is missing`);
            } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
              throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
            }
          }
          return new Set(protectedHeader.crit);
        }
        exports22.default = validateCrit;
      }
    });
    var require_validate_algorithms = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var validateAlgorithms = (option, algorithms) => {
          if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
            throw new TypeError(`"${option}" option must be an array of strings`);
          }
          if (!algorithms) {
            return void 0;
          }
          return new Set(algorithms);
        };
        exports22.default = validateAlgorithms;
      }
    });
    var require_decrypt2 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.flattenedDecrypt = void 0;
        var base64url_js_1 = require_base64url();
        var decrypt_js_1 = require_decrypt();
        var zlib_js_1 = require_zlib();
        var errors_js_1 = require_errors5();
        var is_disjoint_js_1 = require_is_disjoint();
        var is_object_js_1 = require_is_object();
        var decrypt_key_management_js_1 = require_decrypt_key_management();
        var buffer_utils_js_1 = require_buffer_utils();
        var cek_js_1 = require_cek();
        var validate_crit_js_1 = require_validate_crit();
        var validate_algorithms_js_1 = require_validate_algorithms();
        async function flattenedDecrypt(jwe, key, options) {
          var _a;
          if (!(0, is_object_js_1.default)(jwe)) {
            throw new errors_js_1.JWEInvalid("Flattened JWE must be an object");
          }
          if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
            throw new errors_js_1.JWEInvalid("JOSE Header missing");
          }
          if (typeof jwe.iv !== "string") {
            throw new errors_js_1.JWEInvalid("JWE Initialization Vector missing or incorrect type");
          }
          if (typeof jwe.ciphertext !== "string") {
            throw new errors_js_1.JWEInvalid("JWE Ciphertext missing or incorrect type");
          }
          if (typeof jwe.tag !== "string") {
            throw new errors_js_1.JWEInvalid("JWE Authentication Tag missing or incorrect type");
          }
          if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
            throw new errors_js_1.JWEInvalid("JWE Protected Header incorrect type");
          }
          if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key incorrect type");
          }
          if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
            throw new errors_js_1.JWEInvalid("JWE AAD incorrect type");
          }
          if (jwe.header !== void 0 && !(0, is_object_js_1.default)(jwe.header)) {
            throw new errors_js_1.JWEInvalid("JWE Shared Unprotected Header incorrect type");
          }
          if (jwe.unprotected !== void 0 && !(0, is_object_js_1.default)(jwe.unprotected)) {
            throw new errors_js_1.JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
          }
          let parsedProt;
          if (jwe.protected) {
            try {
              const protectedHeader2 = (0, base64url_js_1.decode)(jwe.protected);
              parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader2));
            } catch {
              throw new errors_js_1.JWEInvalid("JWE Protected Header is invalid");
            }
          }
          if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
            throw new errors_js_1.JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...parsedProt,
            ...jwe.header,
            ...jwe.unprotected
          };
          (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!parsedProt || !parsedProt.zip) {
              throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
            if (joseHeader.zip !== "DEF") {
              throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
            }
          }
          const { alg, enc } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new errors_js_1.JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
          }
          if (typeof enc !== "string" || !enc) {
            throw new errors_js_1.JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
          }
          const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)("keyManagementAlgorithms", options.keyManagementAlgorithms);
          const contentEncryptionAlgorithms = options && (0, validate_algorithms_js_1.default)("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
          if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
            throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
          }
          if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
            throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
          }
          let encryptedKey;
          if (jwe.encrypted_key !== void 0) {
            encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
          }
          let resolvedKey = false;
          if (typeof key === "function") {
            key = await key(parsedProt, jwe);
            resolvedKey = true;
          }
          let cek;
          try {
            cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
          } catch (err) {
            if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
              throw err;
            }
            cek = (0, cek_js_1.default)(enc);
          }
          const iv = (0, base64url_js_1.decode)(jwe.iv);
          const tag = (0, base64url_js_1.decode)(jwe.tag);
          const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
          let additionalData;
          if (jwe.aad !== void 0) {
            additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(jwe.aad));
          } else {
            additionalData = protectedHeader;
          }
          let plaintext = await (0, decrypt_js_1.default)(enc, cek, (0, base64url_js_1.decode)(jwe.ciphertext), iv, tag, additionalData);
          if (joseHeader.zip === "DEF") {
            plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
          }
          const result = { plaintext };
          if (jwe.protected !== void 0) {
            result.protectedHeader = parsedProt;
          }
          if (jwe.aad !== void 0) {
            result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
          }
          if (jwe.unprotected !== void 0) {
            result.sharedUnprotectedHeader = jwe.unprotected;
          }
          if (jwe.header !== void 0) {
            result.unprotectedHeader = jwe.header;
          }
          if (resolvedKey) {
            return { ...result, key };
          }
          return result;
        }
        exports22.flattenedDecrypt = flattenedDecrypt;
      }
    });
    var require_decrypt3 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.compactDecrypt = void 0;
        var decrypt_js_1 = require_decrypt2();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        async function compactDecrypt(jwe, key, options) {
          if (jwe instanceof Uint8Array) {
            jwe = buffer_utils_js_1.decoder.decode(jwe);
          }
          if (typeof jwe !== "string") {
            throw new errors_js_1.JWEInvalid("Compact JWE must be a string or Uint8Array");
          }
          const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
          if (length !== 5) {
            throw new errors_js_1.JWEInvalid("Invalid Compact JWE");
          }
          const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
            ciphertext,
            iv: iv || void 0,
            protected: protectedHeader || void 0,
            tag: tag || void 0,
            encrypted_key: encryptedKey || void 0
          }, key, options);
          const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
          if (typeof key === "function") {
            return { ...result, key: decrypted.key };
          }
          return result;
        }
        exports22.compactDecrypt = compactDecrypt;
      }
    });
    var require_decrypt4 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/decrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.generalDecrypt = void 0;
        var decrypt_js_1 = require_decrypt2();
        var errors_js_1 = require_errors5();
        var is_object_js_1 = require_is_object();
        async function generalDecrypt(jwe, key, options) {
          if (!(0, is_object_js_1.default)(jwe)) {
            throw new errors_js_1.JWEInvalid("General JWE must be an object");
          }
          if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
            throw new errors_js_1.JWEInvalid("JWE Recipients missing or incorrect type");
          }
          if (!jwe.recipients.length) {
            throw new errors_js_1.JWEInvalid("JWE Recipients has no members");
          }
          for (const recipient of jwe.recipients) {
            try {
              return await (0, decrypt_js_1.flattenedDecrypt)({
                aad: jwe.aad,
                ciphertext: jwe.ciphertext,
                encrypted_key: recipient.encrypted_key,
                header: recipient.header,
                iv: jwe.iv,
                protected: jwe.protected,
                tag: jwe.tag,
                unprotected: jwe.unprotected
              }, key, options);
            } catch {
            }
          }
          throw new errors_js_1.JWEDecryptionFailed();
        }
        exports22.generalDecrypt = generalDecrypt;
      }
    });
    var require_asn1_sequence_decoder = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var tagInteger = 2;
        var tagSequence = 48;
        var Asn1SequenceDecoder = class {
          constructor(buffer) {
            if (buffer[0] !== tagSequence) {
              throw new TypeError();
            }
            this.buffer = buffer;
            this.offset = 1;
            const len = this.decodeLength();
            if (len !== buffer.length - this.offset) {
              throw new TypeError();
            }
          }
          decodeLength() {
            let length = this.buffer[this.offset++];
            if (length & 128) {
              const nBytes = length & ~128;
              length = 0;
              for (let i = 0; i < nBytes; i++)
                length = length << 8 | this.buffer[this.offset + i];
              this.offset += nBytes;
            }
            return length;
          }
          unsignedInteger() {
            if (this.buffer[this.offset++] !== tagInteger) {
              throw new TypeError();
            }
            let length = this.decodeLength();
            if (this.buffer[this.offset] === 0) {
              this.offset++;
              length--;
            }
            const result = this.buffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return result;
          }
          end() {
            if (this.offset !== this.buffer.length) {
              throw new TypeError();
            }
          }
        };
        exports22.default = Asn1SequenceDecoder;
      }
    });
    var require_key_to_jwk = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var base64url_js_1 = require_base64url();
        var asn1_sequence_decoder_js_1 = require_asn1_sequence_decoder();
        var errors_js_1 = require_errors5();
        var get_named_curve_js_1 = require_get_named_curve();
        var webcrypto_js_1 = require_webcrypto();
        var is_key_object_js_1 = require_is_key_object();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        var flags_js_1 = require_flags();
        var keyToJWK = (key) => {
          let keyObject;
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            if (!key.extractable) {
              throw new TypeError("CryptoKey is not extractable");
            }
            keyObject = crypto_1.KeyObject.from(key);
          } else if ((0, is_key_object_js_1.default)(key)) {
            keyObject = key;
          } else if (key instanceof Uint8Array) {
            return {
              kty: "oct",
              k: (0, base64url_js_1.encode)(key)
            };
          } else {
            throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
          }
          if (flags_js_1.jwkExport) {
            if (keyObject.type !== "secret" && !["rsa", "ec", "ed25519", "x25519", "ed448", "x448"].includes(keyObject.asymmetricKeyType)) {
              throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
            }
            return keyObject.export({ format: "jwk" });
          }
          switch (keyObject.type) {
            case "secret":
              return {
                kty: "oct",
                k: (0, base64url_js_1.encode)(keyObject.export())
              };
            case "private":
            case "public": {
              switch (keyObject.asymmetricKeyType) {
                case "rsa": {
                  const der = keyObject.export({ format: "der", type: "pkcs1" });
                  const dec = new asn1_sequence_decoder_js_1.default(der);
                  if (keyObject.type === "private") {
                    dec.unsignedInteger();
                  }
                  const n = (0, base64url_js_1.encode)(dec.unsignedInteger());
                  const e = (0, base64url_js_1.encode)(dec.unsignedInteger());
                  let jwk;
                  if (keyObject.type === "private") {
                    jwk = {
                      d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                      p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                      q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                      dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                      dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                      qi: (0, base64url_js_1.encode)(dec.unsignedInteger())
                    };
                  }
                  dec.end();
                  return { kty: "RSA", n, e, ...jwk };
                }
                case "ec": {
                  const crv = (0, get_named_curve_js_1.default)(keyObject);
                  let len;
                  let offset;
                  let correction;
                  switch (crv) {
                    case "secp256k1":
                      len = 64;
                      offset = 31 + 2;
                      correction = -1;
                      break;
                    case "P-256":
                      len = 64;
                      offset = 34 + 2;
                      correction = -1;
                      break;
                    case "P-384":
                      len = 96;
                      offset = 33 + 2;
                      correction = -3;
                      break;
                    case "P-521":
                      len = 132;
                      offset = 33 + 2;
                      correction = -3;
                      break;
                    default:
                      throw new errors_js_1.JOSENotSupported("Unsupported curve");
                  }
                  if (keyObject.type === "public") {
                    const der2 = keyObject.export({ type: "spki", format: "der" });
                    return {
                      kty: "EC",
                      crv,
                      x: (0, base64url_js_1.encode)(der2.subarray(-len, -len / 2)),
                      y: (0, base64url_js_1.encode)(der2.subarray(-len / 2))
                    };
                  }
                  const der = keyObject.export({ type: "pkcs8", format: "der" });
                  if (der.length < 100) {
                    offset += correction;
                  }
                  return {
                    ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                    d: (0, base64url_js_1.encode)(der.subarray(offset, offset + len / 2))
                  };
                }
                case "ed25519":
                case "x25519": {
                  const crv = (0, get_named_curve_js_1.default)(keyObject);
                  if (keyObject.type === "public") {
                    const der2 = keyObject.export({ type: "spki", format: "der" });
                    return {
                      kty: "OKP",
                      crv,
                      x: (0, base64url_js_1.encode)(der2.subarray(-32))
                    };
                  }
                  const der = keyObject.export({ type: "pkcs8", format: "der" });
                  return {
                    ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                    d: (0, base64url_js_1.encode)(der.subarray(-32))
                  };
                }
                case "ed448":
                case "x448": {
                  const crv = (0, get_named_curve_js_1.default)(keyObject);
                  if (keyObject.type === "public") {
                    const der2 = keyObject.export({ type: "spki", format: "der" });
                    return {
                      kty: "OKP",
                      crv,
                      x: (0, base64url_js_1.encode)(der2.subarray(crv === "Ed448" ? -57 : -56))
                    };
                  }
                  const der = keyObject.export({ type: "pkcs8", format: "der" });
                  return {
                    ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                    d: (0, base64url_js_1.encode)(der.subarray(crv === "Ed448" ? -57 : -56))
                  };
                }
                default:
                  throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
              }
            }
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported key type");
          }
        };
        exports22.default = keyToJWK;
      }
    });
    var require_export = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/export.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.exportJWK = exports22.exportPKCS8 = exports22.exportSPKI = void 0;
        var asn1_js_1 = require_asn1();
        var asn1_js_2 = require_asn1();
        var key_to_jwk_js_1 = require_key_to_jwk();
        async function exportSPKI(key) {
          return (0, asn1_js_1.toSPKI)(key);
        }
        exports22.exportSPKI = exportSPKI;
        async function exportPKCS8(key) {
          return (0, asn1_js_2.toPKCS8)(key);
        }
        exports22.exportPKCS8 = exportPKCS8;
        async function exportJWK(key) {
          return (0, key_to_jwk_js_1.default)(key);
        }
        exports22.exportJWK = exportJWK;
      }
    });
    var require_encrypt_key_management = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var aeskw_js_1 = require_aeskw();
        var ECDH = require_ecdhes();
        var pbes2kw_js_1 = require_pbes2kw();
        var rsaes_js_1 = require_rsaes();
        var base64url_js_1 = require_base64url();
        var cek_js_1 = require_cek();
        var errors_js_1 = require_errors5();
        var export_js_1 = require_export();
        var check_key_type_js_1 = require_check_key_type();
        var aesgcmkw_js_1 = require_aesgcmkw();
        async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
          let encryptedKey;
          let parameters;
          let cek;
          (0, check_key_type_js_1.default)(alg, key, "encrypt");
          switch (alg) {
            case "dir": {
              cek = key;
              break;
            }
            case "ECDH-ES":
            case "ECDH-ES+A128KW":
            case "ECDH-ES+A192KW":
            case "ECDH-ES+A256KW": {
              if (!ECDH.ecdhAllowed(key)) {
                throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
              }
              const { apu, apv } = providedParameters;
              let { epk: ephemeralKey } = providedParameters;
              ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
              const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
              const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
              parameters = { epk: { x, crv, kty } };
              if (kty === "EC")
                parameters.epk.y = y;
              if (apu)
                parameters.apu = (0, base64url_js_1.encode)(apu);
              if (apv)
                parameters.apv = (0, base64url_js_1.encode)(apv);
              if (alg === "ECDH-ES") {
                cek = sharedSecret;
                break;
              }
              cek = providedCek || (0, cek_js_1.default)(enc);
              const kwAlg = alg.slice(-6);
              encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
              break;
            }
            case "RSA1_5":
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512": {
              cek = providedCek || (0, cek_js_1.default)(enc);
              encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
              break;
            }
            case "PBES2-HS256+A128KW":
            case "PBES2-HS384+A192KW":
            case "PBES2-HS512+A256KW": {
              cek = providedCek || (0, cek_js_1.default)(enc);
              const { p2c, p2s } = providedParameters;
              ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
              break;
            }
            case "A128KW":
            case "A192KW":
            case "A256KW": {
              cek = providedCek || (0, cek_js_1.default)(enc);
              encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
              break;
            }
            case "A128GCMKW":
            case "A192GCMKW":
            case "A256GCMKW": {
              cek = providedCek || (0, cek_js_1.default)(enc);
              const { iv } = providedParameters;
              ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
              break;
            }
            default: {
              throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
          }
          return { cek, encryptedKey, parameters };
        }
        exports22.default = encryptKeyManagement;
      }
    });
    var require_encrypt2 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FlattenedEncrypt = exports22.unprotected = void 0;
        var base64url_js_1 = require_base64url();
        var encrypt_js_1 = require_encrypt();
        var zlib_js_1 = require_zlib();
        var iv_js_1 = require_iv();
        var encrypt_key_management_js_1 = require_encrypt_key_management();
        var errors_js_1 = require_errors5();
        var is_disjoint_js_1 = require_is_disjoint();
        var buffer_utils_js_1 = require_buffer_utils();
        var validate_crit_js_1 = require_validate_crit();
        exports22.unprotected = Symbol();
        var FlattenedEncrypt = class {
          constructor(plaintext) {
            if (!(plaintext instanceof Uint8Array)) {
              throw new TypeError("plaintext must be an instance of Uint8Array");
            }
            this._plaintext = plaintext;
          }
          setKeyManagementParameters(parameters) {
            if (this._keyManagementParameters) {
              throw new TypeError("setKeyManagementParameters can only be called once");
            }
            this._keyManagementParameters = parameters;
            return this;
          }
          setProtectedHeader(protectedHeader) {
            if (this._protectedHeader) {
              throw new TypeError("setProtectedHeader can only be called once");
            }
            this._protectedHeader = protectedHeader;
            return this;
          }
          setSharedUnprotectedHeader(sharedUnprotectedHeader) {
            if (this._sharedUnprotectedHeader) {
              throw new TypeError("setSharedUnprotectedHeader can only be called once");
            }
            this._sharedUnprotectedHeader = sharedUnprotectedHeader;
            return this;
          }
          setUnprotectedHeader(unprotectedHeader) {
            if (this._unprotectedHeader) {
              throw new TypeError("setUnprotectedHeader can only be called once");
            }
            this._unprotectedHeader = unprotectedHeader;
            return this;
          }
          setAdditionalAuthenticatedData(aad) {
            this._aad = aad;
            return this;
          }
          setContentEncryptionKey(cek) {
            if (this._cek) {
              throw new TypeError("setContentEncryptionKey can only be called once");
            }
            this._cek = cek;
            return this;
          }
          setInitializationVector(iv) {
            if (this._iv) {
              throw new TypeError("setInitializationVector can only be called once");
            }
            this._iv = iv;
            return this;
          }
          async encrypt(key, options) {
            if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
              throw new errors_js_1.JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
            }
            if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
              throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
            }
            const joseHeader = {
              ...this._protectedHeader,
              ...this._unprotectedHeader,
              ...this._sharedUnprotectedHeader
            };
            (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
            if (joseHeader.zip !== void 0) {
              if (!this._protectedHeader || !this._protectedHeader.zip) {
                throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
              }
              if (joseHeader.zip !== "DEF") {
                throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
              }
            }
            const { alg, enc } = joseHeader;
            if (typeof alg !== "string" || !alg) {
              throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
            }
            if (typeof enc !== "string" || !enc) {
              throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
            }
            let encryptedKey;
            if (alg === "dir") {
              if (this._cek) {
                throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
              }
            } else if (alg === "ECDH-ES") {
              if (this._cek) {
                throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
              }
            }
            let cek;
            {
              let parameters;
              ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
              if (parameters) {
                if (options && exports22.unprotected in options) {
                  if (!this._unprotectedHeader) {
                    this.setUnprotectedHeader(parameters);
                  } else {
                    this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
                  }
                } else {
                  if (!this._protectedHeader) {
                    this.setProtectedHeader(parameters);
                  } else {
                    this._protectedHeader = { ...this._protectedHeader, ...parameters };
                  }
                }
              }
            }
            this._iv || (this._iv = (0, iv_js_1.default)(enc));
            let additionalData;
            let protectedHeader;
            let aadMember;
            if (this._protectedHeader) {
              protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
            } else {
              protectedHeader = buffer_utils_js_1.encoder.encode("");
            }
            if (this._aad) {
              aadMember = (0, base64url_js_1.encode)(this._aad);
              additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(aadMember));
            } else {
              additionalData = protectedHeader;
            }
            let ciphertext;
            let tag;
            if (joseHeader.zip === "DEF") {
              const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
              ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
            } else {
              ;
              ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
            }
            const jwe = {
              ciphertext: (0, base64url_js_1.encode)(ciphertext),
              iv: (0, base64url_js_1.encode)(this._iv),
              tag: (0, base64url_js_1.encode)(tag)
            };
            if (encryptedKey) {
              jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
            }
            if (aadMember) {
              jwe.aad = aadMember;
            }
            if (this._protectedHeader) {
              jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
            }
            if (this._sharedUnprotectedHeader) {
              jwe.unprotected = this._sharedUnprotectedHeader;
            }
            if (this._unprotectedHeader) {
              jwe.header = this._unprotectedHeader;
            }
            return jwe;
          }
        };
        exports22.FlattenedEncrypt = FlattenedEncrypt;
      }
    });
    var require_encrypt3 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/encrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GeneralEncrypt = void 0;
        var encrypt_js_1 = require_encrypt2();
        var errors_js_1 = require_errors5();
        var cek_js_1 = require_cek();
        var is_disjoint_js_1 = require_is_disjoint();
        var encrypt_key_management_js_1 = require_encrypt_key_management();
        var base64url_js_1 = require_base64url();
        var validate_crit_js_1 = require_validate_crit();
        var IndividualRecipient = class {
          constructor(enc, key, options) {
            this.parent = enc;
            this.key = key;
            this.options = options;
          }
          setUnprotectedHeader(unprotectedHeader) {
            if (this.unprotectedHeader) {
              throw new TypeError("setUnprotectedHeader can only be called once");
            }
            this.unprotectedHeader = unprotectedHeader;
            return this;
          }
          addRecipient(...args) {
            return this.parent.addRecipient(...args);
          }
          encrypt(...args) {
            return this.parent.encrypt(...args);
          }
          done() {
            return this.parent;
          }
        };
        var GeneralEncrypt = class {
          constructor(plaintext) {
            this._recipients = [];
            this._plaintext = plaintext;
          }
          addRecipient(key, options) {
            const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
            this._recipients.push(recipient);
            return recipient;
          }
          setProtectedHeader(protectedHeader) {
            if (this._protectedHeader) {
              throw new TypeError("setProtectedHeader can only be called once");
            }
            this._protectedHeader = protectedHeader;
            return this;
          }
          setSharedUnprotectedHeader(sharedUnprotectedHeader) {
            if (this._unprotectedHeader) {
              throw new TypeError("setSharedUnprotectedHeader can only be called once");
            }
            this._unprotectedHeader = sharedUnprotectedHeader;
            return this;
          }
          setAdditionalAuthenticatedData(aad) {
            this._aad = aad;
            return this;
          }
          async encrypt(options) {
            var _a, _b2, _c;
            if (!this._recipients.length) {
              throw new errors_js_1.JWEInvalid("at least one recipient must be added");
            }
            options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
            if (this._recipients.length === 1) {
              const [recipient] = this._recipients;
              const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
              let jwe2 = {
                ciphertext: flattened.ciphertext,
                iv: flattened.iv,
                recipients: [{}],
                tag: flattened.tag
              };
              if (flattened.aad)
                jwe2.aad = flattened.aad;
              if (flattened.protected)
                jwe2.protected = flattened.protected;
              if (flattened.unprotected)
                jwe2.unprotected = flattened.unprotected;
              if (flattened.encrypted_key)
                jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
              if (flattened.header)
                jwe2.recipients[0].header = flattened.header;
              return jwe2;
            }
            let enc;
            for (let i = 0; i < this._recipients.length; i++) {
              const recipient = this._recipients[i];
              if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
                throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
              }
              const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
              };
              const { alg } = joseHeader;
              if (typeof alg !== "string" || !alg) {
                throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
              }
              if (alg === "dir" || alg === "ECDH-ES") {
                throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
              }
              if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
              }
              if (!enc) {
                enc = joseHeader.enc;
              } else if (enc !== joseHeader.enc) {
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
              }
              (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
              if (joseHeader.zip !== void 0) {
                if (!this._protectedHeader || !this._protectedHeader.zip) {
                  throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
                }
              }
            }
            const cek = (0, cek_js_1.default)(enc);
            let jwe = {
              ciphertext: "",
              iv: "",
              recipients: [],
              tag: ""
            };
            for (let i = 0; i < this._recipients.length; i++) {
              const recipient = this._recipients[i];
              const target = {};
              jwe.recipients.push(target);
              const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
              };
              const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
              if (i === 0) {
                const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
                  ...recipient.options,
                  ...options,
                  [encrypt_js_1.unprotected]: true
                });
                jwe.ciphertext = flattened.ciphertext;
                jwe.iv = flattened.iv;
                jwe.tag = flattened.tag;
                if (flattened.aad)
                  jwe.aad = flattened.aad;
                if (flattened.protected)
                  jwe.protected = flattened.protected;
                if (flattened.unprotected)
                  jwe.unprotected = flattened.unprotected;
                target.encrypted_key = flattened.encrypted_key;
                if (flattened.header)
                  target.header = flattened.header;
                continue;
              }
              const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b2 = this._protectedHeader) === null || _b2 === void 0 ? void 0 : _b2.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
              target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
              if (recipient.unprotectedHeader || parameters)
                target.header = { ...recipient.unprotectedHeader, ...parameters };
            }
            return jwe;
          }
        };
        exports22.GeneralEncrypt = GeneralEncrypt;
      }
    });
    var require_dsa_digest = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        function dsaDigest(alg) {
          switch (alg) {
            case "PS256":
            case "RS256":
            case "ES256":
            case "ES256K":
              return "sha256";
            case "PS384":
            case "RS384":
            case "ES384":
              return "sha384";
            case "PS512":
            case "RS512":
            case "ES512":
              return "sha512";
            case "EdDSA":
              return void 0;
            default:
              throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
          }
        }
        exports22.default = dsaDigest;
      }
    });
    var require_node_key = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/node_key.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var get_named_curve_js_1 = require_get_named_curve();
        var errors_js_1 = require_errors5();
        var check_modulus_length_js_1 = require_check_modulus_length();
        var flags_js_1 = require_flags();
        var PSS = {
          padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST
        };
        var ecCurveAlgMap = /* @__PURE__ */ new Map([
          ["ES256", "P-256"],
          ["ES256K", "secp256k1"],
          ["ES384", "P-384"],
          ["ES512", "P-521"]
        ]);
        function keyForCrypto(alg, key) {
          switch (alg) {
            case "EdDSA":
              if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
              }
              return key;
            case "RS256":
            case "RS384":
            case "RS512":
              if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
              }
              (0, check_modulus_length_js_1.default)(key, alg);
              return key;
            case (flags_js_1.rsaPssParams && "PS256"):
            case (flags_js_1.rsaPssParams && "PS384"):
            case (flags_js_1.rsaPssParams && "PS512"):
              if (key.asymmetricKeyType === "rsa-pss") {
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                const length = parseInt(alg.slice(-3), 10);
                if (hashAlgorithm !== void 0 && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                  throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== void 0 && saltLength > length >> 3) {
                  throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
              } else if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
              }
              (0, check_modulus_length_js_1.default)(key, alg);
              return { key, ...PSS };
            case (!flags_js_1.rsaPssParams && "PS256"):
            case (!flags_js_1.rsaPssParams && "PS384"):
            case (!flags_js_1.rsaPssParams && "PS512"):
              if (key.asymmetricKeyType !== "rsa") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
              }
              (0, check_modulus_length_js_1.default)(key, alg);
              return { key, ...PSS };
            case "ES256":
            case "ES256K":
            case "ES384":
            case "ES512": {
              if (key.asymmetricKeyType !== "ec") {
                throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
              }
              const actual = (0, get_named_curve_js_1.default)(key);
              const expected = ecCurveAlgMap.get(alg);
              if (actual !== expected) {
                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
              }
              return { dsaEncoding: "ieee-p1363", key };
            }
            default:
              throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
          }
        }
        exports22.default = keyForCrypto;
      }
    });
    var require_hmac_digest = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/hmac_digest.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        function hmacDigest(alg) {
          switch (alg) {
            case "HS256":
              return "sha256";
            case "HS384":
              return "sha384";
            case "HS512":
              return "sha512";
            default:
              throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
          }
        }
        exports22.default = hmacDigest;
      }
    });
    var require_get_sign_verify_key = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto_1 = require("crypto");
        var webcrypto_js_1 = require_webcrypto();
        var crypto_key_js_1 = require_crypto_key();
        var invalid_key_input_js_1 = require_invalid_key_input();
        var is_key_like_js_1 = require_is_key_like();
        function getSignVerifyKey(alg, key, usage) {
          if (key instanceof Uint8Array) {
            if (!alg.startsWith("HS")) {
              throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
            }
            return (0, crypto_1.createSecretKey)(key);
          }
          if (key instanceof crypto_1.KeyObject) {
            return key;
          }
          if ((0, webcrypto_js_1.isCryptoKey)(key)) {
            (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
            return crypto_1.KeyObject.from(key);
          }
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
        }
        exports22.default = getSignVerifyKey;
      }
    });
    var require_sign = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/sign.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto = require("crypto");
        var util_1 = require("util");
        var dsa_digest_js_1 = require_dsa_digest();
        var hmac_digest_js_1 = require_hmac_digest();
        var node_key_js_1 = require_node_key();
        var get_sign_verify_key_js_1 = require_get_sign_verify_key();
        var oneShotSign;
        if (crypto.sign.length > 3) {
          oneShotSign = (0, util_1.promisify)(crypto.sign);
        } else {
          oneShotSign = crypto.sign;
        }
        var sign2 = async (alg, key, data) => {
          const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "sign");
          if (alg.startsWith("HS")) {
            const hmac = crypto.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
            hmac.update(data);
            return hmac.digest();
          }
          return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
        };
        exports22.default = sign2;
      }
    });
    var require_verify = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/verify.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var crypto = require("crypto");
        var util_1 = require("util");
        var dsa_digest_js_1 = require_dsa_digest();
        var node_key_js_1 = require_node_key();
        var sign_js_1 = require_sign();
        var get_sign_verify_key_js_1 = require_get_sign_verify_key();
        var flags_js_1 = require_flags();
        var oneShotVerify;
        if (crypto.verify.length > 4 && flags_js_1.oneShotCallback) {
          oneShotVerify = (0, util_1.promisify)(crypto.verify);
        } else {
          oneShotVerify = crypto.verify;
        }
        var verify = async (alg, key, signature, data) => {
          const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "verify");
          if (alg.startsWith("HS")) {
            const expected = await (0, sign_js_1.default)(alg, keyObject, data);
            const actual = signature;
            try {
              return crypto.timingSafeEqual(actual, expected);
            } catch {
              return false;
            }
          }
          const algorithm = (0, dsa_digest_js_1.default)(alg);
          const keyInput = (0, node_key_js_1.default)(alg, keyObject);
          try {
            return await oneShotVerify(algorithm, data, keyInput, signature);
          } catch {
            return false;
          }
        };
        exports22.default = verify;
      }
    });
    var require_verify2 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/verify.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.flattenedVerify = void 0;
        var base64url_js_1 = require_base64url();
        var verify_js_1 = require_verify();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var is_disjoint_js_1 = require_is_disjoint();
        var is_object_js_1 = require_is_object();
        var check_key_type_js_1 = require_check_key_type();
        var validate_crit_js_1 = require_validate_crit();
        var validate_algorithms_js_1 = require_validate_algorithms();
        async function flattenedVerify(jws, key, options) {
          var _a;
          if (!(0, is_object_js_1.default)(jws)) {
            throw new errors_js_1.JWSInvalid("Flattened JWS must be an object");
          }
          if (jws.protected === void 0 && jws.header === void 0) {
            throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
          }
          if (jws.protected !== void 0 && typeof jws.protected !== "string") {
            throw new errors_js_1.JWSInvalid("JWS Protected Header incorrect type");
          }
          if (jws.payload === void 0) {
            throw new errors_js_1.JWSInvalid("JWS Payload missing");
          }
          if (typeof jws.signature !== "string") {
            throw new errors_js_1.JWSInvalid("JWS Signature missing or incorrect type");
          }
          if (jws.header !== void 0 && !(0, is_object_js_1.default)(jws.header)) {
            throw new errors_js_1.JWSInvalid("JWS Unprotected Header incorrect type");
          }
          let parsedProt = {};
          if (jws.protected) {
            try {
              const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
              parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
            } catch {
              throw new errors_js_1.JWSInvalid("JWS Protected Header is invalid");
            }
          }
          if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
            throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...parsedProt,
            ...jws.header
          };
          const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
          let b64 = true;
          if (extensions.has("b64")) {
            b64 = parsedProt.b64;
            if (typeof b64 !== "boolean") {
              throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
          }
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
          }
          const algorithms = options && (0, validate_algorithms_js_1.default)("algorithms", options.algorithms);
          if (algorithms && !algorithms.has(alg)) {
            throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
          }
          if (b64) {
            if (typeof jws.payload !== "string") {
              throw new errors_js_1.JWSInvalid("JWS Payload must be a string");
            }
          } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
            throw new errors_js_1.JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
          }
          let resolvedKey = false;
          if (typeof key === "function") {
            key = await key(parsedProt, jws);
            resolvedKey = true;
          }
          (0, check_key_type_js_1.default)(alg, key, "verify");
          const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), buffer_utils_js_1.encoder.encode("."), typeof jws.payload === "string" ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
          const signature = (0, base64url_js_1.decode)(jws.signature);
          const verified = await (0, verify_js_1.default)(alg, key, signature, data);
          if (!verified) {
            throw new errors_js_1.JWSSignatureVerificationFailed();
          }
          let payload;
          if (b64) {
            payload = (0, base64url_js_1.decode)(jws.payload);
          } else if (typeof jws.payload === "string") {
            payload = buffer_utils_js_1.encoder.encode(jws.payload);
          } else {
            payload = jws.payload;
          }
          const result = { payload };
          if (jws.protected !== void 0) {
            result.protectedHeader = parsedProt;
          }
          if (jws.header !== void 0) {
            result.unprotectedHeader = jws.header;
          }
          if (resolvedKey) {
            return { ...result, key };
          }
          return result;
        }
        exports22.flattenedVerify = flattenedVerify;
      }
    });
    var require_verify3 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/verify.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.compactVerify = void 0;
        var verify_js_1 = require_verify2();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        async function compactVerify(jws, key, options) {
          if (jws instanceof Uint8Array) {
            jws = buffer_utils_js_1.decoder.decode(jws);
          }
          if (typeof jws !== "string") {
            throw new errors_js_1.JWSInvalid("Compact JWS must be a string or Uint8Array");
          }
          const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
          if (length !== 3) {
            throw new errors_js_1.JWSInvalid("Invalid Compact JWS");
          }
          const verified = await (0, verify_js_1.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);
          const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
          if (typeof key === "function") {
            return { ...result, key: verified.key };
          }
          return result;
        }
        exports22.compactVerify = compactVerify;
      }
    });
    var require_verify4 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/verify.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.generalVerify = void 0;
        var verify_js_1 = require_verify2();
        var errors_js_1 = require_errors5();
        var is_object_js_1 = require_is_object();
        async function generalVerify(jws, key, options) {
          if (!(0, is_object_js_1.default)(jws)) {
            throw new errors_js_1.JWSInvalid("General JWS must be an object");
          }
          if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
            throw new errors_js_1.JWSInvalid("JWS Signatures missing or incorrect type");
          }
          for (const signature of jws.signatures) {
            try {
              return await (0, verify_js_1.flattenedVerify)({
                header: signature.header,
                payload: jws.payload,
                protected: signature.protected,
                signature: signature.signature
              }, key, options);
            } catch {
            }
          }
          throw new errors_js_1.JWSSignatureVerificationFailed();
        }
        exports22.generalVerify = generalVerify;
      }
    });
    var require_epoch = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/epoch.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.default = (date) => Math.floor(date.getTime() / 1e3);
      }
    });
    var require_secs = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/secs.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var minute = 60;
        var hour = minute * 60;
        var day = hour * 24;
        var week = day * 7;
        var year = day * 365.25;
        var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
        exports22.default = (str) => {
          const matched = REGEX.exec(str);
          if (!matched) {
            throw new TypeError("Invalid time period format");
          }
          const value = parseFloat(matched[1]);
          const unit = matched[2].toLowerCase();
          switch (unit) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
            case "s":
              return Math.round(value);
            case "minute":
            case "minutes":
            case "min":
            case "mins":
            case "m":
              return Math.round(value * minute);
            case "hour":
            case "hours":
            case "hr":
            case "hrs":
            case "h":
              return Math.round(value * hour);
            case "day":
            case "days":
            case "d":
              return Math.round(value * day);
            case "week":
            case "weeks":
            case "w":
              return Math.round(value * week);
            default:
              return Math.round(value * year);
          }
        };
      }
    });
    var require_jwt_claims_set = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var epoch_js_1 = require_epoch();
        var secs_js_1 = require_secs();
        var is_object_js_1 = require_is_object();
        var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
        var checkAudiencePresence = (audPayload, audOption) => {
          if (typeof audPayload === "string") {
            return audOption.includes(audPayload);
          }
          if (Array.isArray(audPayload)) {
            return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
          }
          return false;
        };
        exports22.default = (protectedHeader, encodedPayload, options = {}) => {
          const { typ } = options;
          if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
            throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
          }
          let payload;
          try {
            payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
          } catch {
          }
          if (!(0, is_object_js_1.default)(payload)) {
            throw new errors_js_1.JWTInvalid("JWT Claims Set must be a top-level JSON object");
          }
          const { issuer } = options;
          if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
            throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
          }
          const { subject } = options;
          if (subject && payload.sub !== subject) {
            throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
          }
          const { audience } = options;
          if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
            throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
          }
          let tolerance;
          switch (typeof options.clockTolerance) {
            case "string":
              tolerance = (0, secs_js_1.default)(options.clockTolerance);
              break;
            case "number":
              tolerance = options.clockTolerance;
              break;
            case "undefined":
              tolerance = 0;
              break;
            default:
              throw new TypeError("Invalid clockTolerance option type");
          }
          const { currentDate } = options;
          const now = (0, epoch_js_1.default)(currentDate || /* @__PURE__ */ new Date());
          if ((payload.iat !== void 0 || options.maxTokenAge) && typeof payload.iat !== "number") {
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
          }
          if (payload.nbf !== void 0) {
            if (typeof payload.nbf !== "number") {
              throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
            }
            if (payload.nbf > now + tolerance) {
              throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
            }
          }
          if (payload.exp !== void 0) {
            if (typeof payload.exp !== "number") {
              throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
            }
            if (payload.exp <= now - tolerance) {
              throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
            }
          }
          if (options.maxTokenAge) {
            const age = now - payload.iat;
            const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : (0, secs_js_1.default)(options.maxTokenAge);
            if (age - tolerance > max) {
              throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
            }
            if (age < 0 - tolerance) {
              throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
            }
          }
          return payload;
        };
      }
    });
    var require_verify5 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/verify.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.jwtVerify = void 0;
        var verify_js_1 = require_verify3();
        var jwt_claims_set_js_1 = require_jwt_claims_set();
        var errors_js_1 = require_errors5();
        async function jwtVerify(jwt, key, options) {
          var _a;
          const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
          if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
            throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
          }
          const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
          const result = { payload, protectedHeader: verified.protectedHeader };
          if (typeof key === "function") {
            return { ...result, key: verified.key };
          }
          return result;
        }
        exports22.jwtVerify = jwtVerify;
      }
    });
    var require_decrypt5 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/decrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.jwtDecrypt = void 0;
        var decrypt_js_1 = require_decrypt3();
        var jwt_claims_set_js_1 = require_jwt_claims_set();
        var errors_js_1 = require_errors5();
        async function jwtDecrypt(jwt, key, options) {
          const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
          const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
          const { protectedHeader } = decrypted;
          if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
            throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
          }
          if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
            throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
          }
          if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
            throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
          }
          const result = { payload, protectedHeader };
          if (typeof key === "function") {
            return { ...result, key: decrypted.key };
          }
          return result;
        }
        exports22.jwtDecrypt = jwtDecrypt;
      }
    });
    var require_encrypt4 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.CompactEncrypt = void 0;
        var encrypt_js_1 = require_encrypt2();
        var CompactEncrypt = class {
          constructor(plaintext) {
            this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
          }
          setContentEncryptionKey(cek) {
            this._flattened.setContentEncryptionKey(cek);
            return this;
          }
          setInitializationVector(iv) {
            this._flattened.setInitializationVector(iv);
            return this;
          }
          setProtectedHeader(protectedHeader) {
            this._flattened.setProtectedHeader(protectedHeader);
            return this;
          }
          setKeyManagementParameters(parameters) {
            this._flattened.setKeyManagementParameters(parameters);
            return this;
          }
          async encrypt(key, options) {
            const jwe = await this._flattened.encrypt(key, options);
            return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
          }
        };
        exports22.CompactEncrypt = CompactEncrypt;
      }
    });
    var require_sign2 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/sign.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.FlattenedSign = void 0;
        var base64url_js_1 = require_base64url();
        var sign_js_1 = require_sign();
        var is_disjoint_js_1 = require_is_disjoint();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var check_key_type_js_1 = require_check_key_type();
        var validate_crit_js_1 = require_validate_crit();
        var FlattenedSign = class {
          constructor(payload) {
            if (!(payload instanceof Uint8Array)) {
              throw new TypeError("payload must be an instance of Uint8Array");
            }
            this._payload = payload;
          }
          setProtectedHeader(protectedHeader) {
            if (this._protectedHeader) {
              throw new TypeError("setProtectedHeader can only be called once");
            }
            this._protectedHeader = protectedHeader;
            return this;
          }
          setUnprotectedHeader(unprotectedHeader) {
            if (this._unprotectedHeader) {
              throw new TypeError("setUnprotectedHeader can only be called once");
            }
            this._unprotectedHeader = unprotectedHeader;
            return this;
          }
          async sign(key, options) {
            if (!this._protectedHeader && !this._unprotectedHeader) {
              throw new errors_js_1.JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
            }
            if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
              throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
            }
            const joseHeader = {
              ...this._protectedHeader,
              ...this._unprotectedHeader
            };
            const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
            let b64 = true;
            if (extensions.has("b64")) {
              b64 = this._protectedHeader.b64;
              if (typeof b64 !== "boolean") {
                throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
              }
            }
            const { alg } = joseHeader;
            if (typeof alg !== "string" || !alg) {
              throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
            }
            (0, check_key_type_js_1.default)(alg, key, "sign");
            let payload = this._payload;
            if (b64) {
              payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
            }
            let protectedHeader;
            if (this._protectedHeader) {
              protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
            } else {
              protectedHeader = buffer_utils_js_1.encoder.encode("");
            }
            const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), payload);
            const signature = await (0, sign_js_1.default)(alg, key, data);
            const jws = {
              signature: (0, base64url_js_1.encode)(signature),
              payload: ""
            };
            if (b64) {
              jws.payload = buffer_utils_js_1.decoder.decode(payload);
            }
            if (this._unprotectedHeader) {
              jws.header = this._unprotectedHeader;
            }
            if (this._protectedHeader) {
              jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
            }
            return jws;
          }
        };
        exports22.FlattenedSign = FlattenedSign;
      }
    });
    var require_sign3 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/sign.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.CompactSign = void 0;
        var sign_js_1 = require_sign2();
        var CompactSign = class {
          constructor(payload) {
            this._flattened = new sign_js_1.FlattenedSign(payload);
          }
          setProtectedHeader(protectedHeader) {
            this._flattened.setProtectedHeader(protectedHeader);
            return this;
          }
          async sign(key, options) {
            const jws = await this._flattened.sign(key, options);
            if (jws.payload === void 0) {
              throw new TypeError("use the flattened module for creating JWS with b64: false");
            }
            return `${jws.protected}.${jws.payload}.${jws.signature}`;
          }
        };
        exports22.CompactSign = CompactSign;
      }
    });
    var require_sign4 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/sign.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.GeneralSign = void 0;
        var sign_js_1 = require_sign2();
        var errors_js_1 = require_errors5();
        var IndividualSignature = class {
          constructor(sig, key, options) {
            this.parent = sig;
            this.key = key;
            this.options = options;
          }
          setProtectedHeader(protectedHeader) {
            if (this.protectedHeader) {
              throw new TypeError("setProtectedHeader can only be called once");
            }
            this.protectedHeader = protectedHeader;
            return this;
          }
          setUnprotectedHeader(unprotectedHeader) {
            if (this.unprotectedHeader) {
              throw new TypeError("setUnprotectedHeader can only be called once");
            }
            this.unprotectedHeader = unprotectedHeader;
            return this;
          }
          addSignature(...args) {
            return this.parent.addSignature(...args);
          }
          sign(...args) {
            return this.parent.sign(...args);
          }
          done() {
            return this.parent;
          }
        };
        var GeneralSign = class {
          constructor(payload) {
            this._signatures = [];
            this._payload = payload;
          }
          addSignature(key, options) {
            const signature = new IndividualSignature(this, key, options);
            this._signatures.push(signature);
            return signature;
          }
          async sign() {
            if (!this._signatures.length) {
              throw new errors_js_1.JWSInvalid("at least one signature must be added");
            }
            const jws = {
              signatures: [],
              payload: ""
            };
            for (let i = 0; i < this._signatures.length; i++) {
              const signature = this._signatures[i];
              const flattened = new sign_js_1.FlattenedSign(this._payload);
              flattened.setProtectedHeader(signature.protectedHeader);
              flattened.setUnprotectedHeader(signature.unprotectedHeader);
              const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
              if (i === 0) {
                jws.payload = payload;
              } else if (jws.payload !== payload) {
                throw new errors_js_1.JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");
              }
              jws.signatures.push(rest);
            }
            return jws;
          }
        };
        exports22.GeneralSign = GeneralSign;
      }
    });
    var require_produce = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/produce.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.ProduceJWT = void 0;
        var epoch_js_1 = require_epoch();
        var is_object_js_1 = require_is_object();
        var secs_js_1 = require_secs();
        var ProduceJWT = class {
          constructor(payload) {
            if (!(0, is_object_js_1.default)(payload)) {
              throw new TypeError("JWT Claims Set MUST be an object");
            }
            this._payload = payload;
          }
          setIssuer(issuer) {
            this._payload = { ...this._payload, iss: issuer };
            return this;
          }
          setSubject(subject) {
            this._payload = { ...this._payload, sub: subject };
            return this;
          }
          setAudience(audience) {
            this._payload = { ...this._payload, aud: audience };
            return this;
          }
          setJti(jwtId) {
            this._payload = { ...this._payload, jti: jwtId };
            return this;
          }
          setNotBefore(input) {
            if (typeof input === "number") {
              this._payload = { ...this._payload, nbf: input };
            } else {
              this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) + (0, secs_js_1.default)(input) };
            }
            return this;
          }
          setExpirationTime(input) {
            if (typeof input === "number") {
              this._payload = { ...this._payload, exp: input };
            } else {
              this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) + (0, secs_js_1.default)(input) };
            }
            return this;
          }
          setIssuedAt(input) {
            if (typeof input === "undefined") {
              this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) };
            } else {
              this._payload = { ...this._payload, iat: input };
            }
            return this;
          }
        };
        exports22.ProduceJWT = ProduceJWT;
      }
    });
    var require_sign5 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/sign.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.SignJWT = void 0;
        var sign_js_1 = require_sign3();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var produce_js_1 = require_produce();
        var SignJWT = class extends produce_js_1.ProduceJWT {
          setProtectedHeader(protectedHeader) {
            this._protectedHeader = protectedHeader;
            return this;
          }
          async sign(key, options) {
            var _a;
            const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
            sig.setProtectedHeader(this._protectedHeader);
            if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
              throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
            }
            return sig.sign(key, options);
          }
        };
        exports22.SignJWT = SignJWT;
      }
    });
    var require_encrypt5 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/encrypt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EncryptJWT = void 0;
        var encrypt_js_1 = require_encrypt4();
        var buffer_utils_js_1 = require_buffer_utils();
        var produce_js_1 = require_produce();
        var EncryptJWT = class extends produce_js_1.ProduceJWT {
          setProtectedHeader(protectedHeader) {
            if (this._protectedHeader) {
              throw new TypeError("setProtectedHeader can only be called once");
            }
            this._protectedHeader = protectedHeader;
            return this;
          }
          setKeyManagementParameters(parameters) {
            if (this._keyManagementParameters) {
              throw new TypeError("setKeyManagementParameters can only be called once");
            }
            this._keyManagementParameters = parameters;
            return this;
          }
          setContentEncryptionKey(cek) {
            if (this._cek) {
              throw new TypeError("setContentEncryptionKey can only be called once");
            }
            this._cek = cek;
            return this;
          }
          setInitializationVector(iv) {
            if (this._iv) {
              throw new TypeError("setInitializationVector can only be called once");
            }
            this._iv = iv;
            return this;
          }
          replicateIssuerAsHeader() {
            this._replicateIssuerAsHeader = true;
            return this;
          }
          replicateSubjectAsHeader() {
            this._replicateSubjectAsHeader = true;
            return this;
          }
          replicateAudienceAsHeader() {
            this._replicateAudienceAsHeader = true;
            return this;
          }
          async encrypt(key, options) {
            const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
            if (this._replicateIssuerAsHeader) {
              this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
            }
            if (this._replicateSubjectAsHeader) {
              this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
            }
            if (this._replicateAudienceAsHeader) {
              this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
            }
            enc.setProtectedHeader(this._protectedHeader);
            if (this._iv) {
              enc.setInitializationVector(this._iv);
            }
            if (this._cek) {
              enc.setContentEncryptionKey(this._cek);
            }
            if (this._keyManagementParameters) {
              enc.setKeyManagementParameters(this._keyManagementParameters);
            }
            return enc.encrypt(key, options);
          }
        };
        exports22.EncryptJWT = EncryptJWT;
      }
    });
    var require_thumbprint = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/thumbprint.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.calculateJwkThumbprintUri = exports22.calculateJwkThumbprint = void 0;
        var digest_js_1 = require_digest();
        var base64url_js_1 = require_base64url();
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var is_object_js_1 = require_is_object();
        var check = (value, description) => {
          if (typeof value !== "string" || !value) {
            throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
          }
        };
        async function calculateJwkThumbprint(jwk, digestAlgorithm) {
          if (!(0, is_object_js_1.default)(jwk)) {
            throw new TypeError("JWK must be an object");
          }
          digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
          if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
            throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
          }
          let components;
          switch (jwk.kty) {
            case "EC":
              check(jwk.crv, '"crv" (Curve) Parameter');
              check(jwk.x, '"x" (X Coordinate) Parameter');
              check(jwk.y, '"y" (Y Coordinate) Parameter');
              components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
              break;
            case "OKP":
              check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
              check(jwk.x, '"x" (Public Key) Parameter');
              components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
              break;
            case "RSA":
              check(jwk.e, '"e" (Exponent) Parameter');
              check(jwk.n, '"n" (Modulus) Parameter');
              components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
              break;
            case "oct":
              check(jwk.k, '"k" (Key Value) Parameter');
              components = { k: jwk.k, kty: jwk.kty };
              break;
            default:
              throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
          }
          const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
          return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
        }
        exports22.calculateJwkThumbprint = calculateJwkThumbprint;
        async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
          digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
          const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
          return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
        }
        exports22.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
      }
    });
    var require_embedded = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/embedded.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.EmbeddedJWK = void 0;
        var import_js_1 = require_import();
        var is_object_js_1 = require_is_object();
        var errors_js_1 = require_errors5();
        async function EmbeddedJWK(protectedHeader, token) {
          const joseHeader = {
            ...protectedHeader,
            ...token.header
          };
          if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
            throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
          }
          const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
          if (key instanceof Uint8Array || key.type !== "public") {
            throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
          }
          return key;
        }
        exports22.EmbeddedJWK = EmbeddedJWK;
      }
    });
    var require_local = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/local.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createLocalJWKSet = exports22.LocalJWKSet = exports22.isJWKSLike = void 0;
        var import_js_1 = require_import();
        var errors_js_1 = require_errors5();
        var is_object_js_1 = require_is_object();
        function getKtyFromAlg(alg) {
          switch (typeof alg === "string" && alg.slice(0, 2)) {
            case "RS":
            case "PS":
              return "RSA";
            case "ES":
              return "EC";
            case "Ed":
              return "OKP";
            default:
              throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
          }
        }
        function isJWKSLike(jwks) {
          return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
        }
        exports22.isJWKSLike = isJWKSLike;
        function isJWKLike(key) {
          return (0, is_object_js_1.default)(key);
        }
        function clone(obj) {
          if (typeof structuredClone === "function") {
            return structuredClone(obj);
          }
          return JSON.parse(JSON.stringify(obj));
        }
        var LocalJWKSet = class {
          constructor(jwks) {
            this._cached = /* @__PURE__ */ new WeakMap();
            if (!isJWKSLike(jwks)) {
              throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
            }
            this._jwks = clone(jwks);
          }
          async getKey(protectedHeader, token) {
            const { alg, kid } = { ...protectedHeader, ...token.header };
            const kty = getKtyFromAlg(alg);
            const candidates = this._jwks.keys.filter((jwk2) => {
              let candidate = kty === jwk2.kty;
              if (candidate && typeof kid === "string") {
                candidate = kid === jwk2.kid;
              }
              if (candidate && typeof jwk2.alg === "string") {
                candidate = alg === jwk2.alg;
              }
              if (candidate && typeof jwk2.use === "string") {
                candidate = jwk2.use === "sig";
              }
              if (candidate && Array.isArray(jwk2.key_ops)) {
                candidate = jwk2.key_ops.includes("verify");
              }
              if (candidate && alg === "EdDSA") {
                candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
              }
              if (candidate) {
                switch (alg) {
                  case "ES256":
                    candidate = jwk2.crv === "P-256";
                    break;
                  case "ES256K":
                    candidate = jwk2.crv === "secp256k1";
                    break;
                  case "ES384":
                    candidate = jwk2.crv === "P-384";
                    break;
                  case "ES512":
                    candidate = jwk2.crv === "P-521";
                    break;
                }
              }
              return candidate;
            });
            const { 0: jwk, length } = candidates;
            if (length === 0) {
              throw new errors_js_1.JWKSNoMatchingKey();
            } else if (length !== 1) {
              throw new errors_js_1.JWKSMultipleMatchingKeys();
            }
            const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
            if (cached[alg] === void 0) {
              const keyObject = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, alg);
              if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
                throw new errors_js_1.JWKSInvalid("JSON Web Key Set members must be public keys");
              }
              cached[alg] = keyObject;
            }
            return cached[alg];
          }
        };
        exports22.LocalJWKSet = LocalJWKSet;
        function createLocalJWKSet(jwks) {
          return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
        }
        exports22.createLocalJWKSet = createLocalJWKSet;
      }
    });
    var require_fetch_jwks = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        var http = require("http");
        var https = require("https");
        var events_1 = require("events");
        var errors_js_1 = require_errors5();
        var buffer_utils_js_1 = require_buffer_utils();
        var fetchJwks = async (url, timeout, options) => {
          let get;
          switch (url.protocol) {
            case "https:":
              get = https.get;
              break;
            case "http:":
              get = http.get;
              break;
            default:
              throw new TypeError("Unsupported URL protocol.");
          }
          const { agent, headers } = options;
          const req = get(url.href, {
            agent,
            timeout,
            headers
          });
          const [response] = await Promise.race([(0, events_1.once)(req, "response"), (0, events_1.once)(req, "timeout")]);
          if (!response) {
            req.destroy();
            throw new errors_js_1.JWKSTimeout();
          }
          if (response.statusCode !== 200) {
            throw new errors_js_1.JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
          }
          const parts = [];
          for await (const part of response) {
            parts.push(part);
          }
          try {
            return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
          } catch {
            throw new errors_js_1.JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
          }
        };
        exports22.default = fetchJwks;
      }
    });
    var require_remote = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/remote.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createRemoteJWKSet = void 0;
        var fetch_jwks_js_1 = require_fetch_jwks();
        var env_js_1 = require_env();
        var errors_js_1 = require_errors5();
        var local_js_1 = require_local();
        var RemoteJWKSet = class extends local_js_1.LocalJWKSet {
          constructor(url, options) {
            super({ keys: [] });
            this._jwks = void 0;
            if (!(url instanceof URL)) {
              throw new TypeError("url must be an instance of URL");
            }
            this._url = new URL(url.href);
            this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
            this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
            this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
            this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
          }
          coolingDown() {
            return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
          }
          fresh() {
            return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
          }
          async getKey(protectedHeader, token) {
            if (!this._jwks || !this.fresh()) {
              await this.reload();
            }
            try {
              return await super.getKey(protectedHeader, token);
            } catch (err) {
              if (err instanceof errors_js_1.JWKSNoMatchingKey) {
                if (this.coolingDown() === false) {
                  await this.reload();
                  return super.getKey(protectedHeader, token);
                }
              }
              throw err;
            }
          }
          async reload() {
            if (this._pendingFetch && (0, env_js_1.isCloudflareWorkers)()) {
              return new Promise((resolve) => {
                const isDone = () => {
                  if (this._pendingFetch === void 0) {
                    resolve();
                  } else {
                    setTimeout(isDone, 5);
                  }
                };
                isDone();
              });
            }
            if (!this._pendingFetch) {
              this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options).then((json) => {
                if (!(0, local_js_1.isJWKSLike)(json)) {
                  throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
                }
                this._jwks = { keys: json.keys };
                this._jwksTimestamp = Date.now();
                this._pendingFetch = void 0;
              }).catch((err) => {
                this._pendingFetch = void 0;
                throw err;
              });
            }
            await this._pendingFetch;
          }
        };
        function createRemoteJWKSet(url, options) {
          return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
        }
        exports22.createRemoteJWKSet = createRemoteJWKSet;
      }
    });
    var require_unsecured = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/unsecured.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.UnsecuredJWT = void 0;
        var base64url = require_base64url();
        var buffer_utils_js_1 = require_buffer_utils();
        var errors_js_1 = require_errors5();
        var jwt_claims_set_js_1 = require_jwt_claims_set();
        var produce_js_1 = require_produce();
        var UnsecuredJWT = class extends produce_js_1.ProduceJWT {
          encode() {
            const header = base64url.encode(JSON.stringify({ alg: "none" }));
            const payload = base64url.encode(JSON.stringify(this._payload));
            return `${header}.${payload}.`;
          }
          static decode(jwt, options) {
            if (typeof jwt !== "string") {
              throw new errors_js_1.JWTInvalid("Unsecured JWT must be a string");
            }
            const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
            if (length !== 3 || signature !== "") {
              throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
            }
            let header;
            try {
              header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
              if (header.alg !== "none")
                throw new Error();
            } catch {
              throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
            }
            const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
            return { payload, header };
          }
        };
        exports22.UnsecuredJWT = UnsecuredJWT;
      }
    });
    var require_base64url2 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/base64url.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decode = exports22.encode = void 0;
        var base64url = require_base64url();
        exports22.encode = base64url.encode;
        exports22.decode = base64url.decode;
      }
    });
    var require_decode_protected_header = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_protected_header.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decodeProtectedHeader = void 0;
        var base64url_js_1 = require_base64url2();
        var buffer_utils_js_1 = require_buffer_utils();
        var is_object_js_1 = require_is_object();
        function decodeProtectedHeader(token) {
          let protectedB64u;
          if (typeof token === "string") {
            const parts = token.split(".");
            if (parts.length === 3 || parts.length === 5) {
              ;
              [protectedB64u] = parts;
            }
          } else if (typeof token === "object" && token) {
            if ("protected" in token) {
              protectedB64u = token.protected;
            } else {
              throw new TypeError("Token does not contain a Protected Header");
            }
          }
          try {
            if (typeof protectedB64u !== "string" || !protectedB64u) {
              throw new Error();
            }
            const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
            if (!(0, is_object_js_1.default)(result)) {
              throw new Error();
            }
            return result;
          } catch {
            throw new TypeError("Invalid Token or Protected Header formatting");
          }
        }
        exports22.decodeProtectedHeader = decodeProtectedHeader;
      }
    });
    var require_decode_jwt = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_jwt.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decodeJwt = void 0;
        var base64url_js_1 = require_base64url2();
        var buffer_utils_js_1 = require_buffer_utils();
        var is_object_js_1 = require_is_object();
        var errors_js_1 = require_errors5();
        function decodeJwt(jwt) {
          if (typeof jwt !== "string")
            throw new errors_js_1.JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
          const { 1: payload, length } = jwt.split(".");
          if (length === 5)
            throw new errors_js_1.JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
          if (length !== 3)
            throw new errors_js_1.JWTInvalid("Invalid JWT");
          if (!payload)
            throw new errors_js_1.JWTInvalid("JWTs must contain a payload");
          let decoded;
          try {
            decoded = (0, base64url_js_1.decode)(payload);
          } catch {
            throw new errors_js_1.JWTInvalid("Failed to parse the base64url encoded payload");
          }
          let result;
          try {
            result = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
          } catch {
            throw new errors_js_1.JWTInvalid("Failed to parse the decoded payload as JSON");
          }
          if (!(0, is_object_js_1.default)(result))
            throw new errors_js_1.JWTInvalid("Invalid JWT Claims Set");
          return result;
        }
        exports22.decodeJwt = decodeJwt;
      }
    });
    var require_generate = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/generate.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.generateKeyPair = exports22.generateSecret = void 0;
        var crypto_1 = require("crypto");
        var util_1 = require("util");
        var random_js_1 = require_random();
        var check_modulus_length_js_1 = require_check_modulus_length();
        var errors_js_1 = require_errors5();
        var generate = (0, util_1.promisify)(crypto_1.generateKeyPair);
        async function generateSecret(alg, options) {
          let length;
          switch (alg) {
            case "HS256":
            case "HS384":
            case "HS512":
            case "A128CBC-HS256":
            case "A192CBC-HS384":
            case "A256CBC-HS512":
              length = parseInt(alg.slice(-3), 10);
              break;
            case "A128KW":
            case "A192KW":
            case "A256KW":
            case "A128GCMKW":
            case "A192GCMKW":
            case "A256GCMKW":
            case "A128GCM":
            case "A192GCM":
            case "A256GCM":
              length = parseInt(alg.slice(1, 4), 10);
              break;
            default:
              throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
          return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
        }
        exports22.generateSecret = generateSecret;
        async function generateKeyPair(alg, options) {
          var _a, _b2;
          switch (alg) {
            case "RS256":
            case "RS384":
            case "RS512":
            case "PS256":
            case "PS384":
            case "PS512":
            case "RSA-OAEP":
            case "RSA-OAEP-256":
            case "RSA-OAEP-384":
            case "RSA-OAEP-512":
            case "RSA1_5": {
              const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
              if (typeof modulusLength !== "number" || modulusLength < 2048) {
                throw new errors_js_1.JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
              }
              const keypair = await generate("rsa", {
                modulusLength,
                publicExponent: 65537
              });
              (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
              (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
              return keypair;
            }
            case "ES256":
              return generate("ec", { namedCurve: "P-256" });
            case "ES256K":
              return generate("ec", { namedCurve: "secp256k1" });
            case "ES384":
              return generate("ec", { namedCurve: "P-384" });
            case "ES512":
              return generate("ec", { namedCurve: "P-521" });
            case "EdDSA": {
              switch (options === null || options === void 0 ? void 0 : options.crv) {
                case void 0:
                case "Ed25519":
                  return generate("ed25519");
                case "Ed448":
                  return generate("ed448");
                default:
                  throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448");
              }
            }
            case "ECDH-ES":
            case "ECDH-ES+A128KW":
            case "ECDH-ES+A192KW":
            case "ECDH-ES+A256KW":
              const crv = (_b2 = options === null || options === void 0 ? void 0 : options.crv) !== null && _b2 !== void 0 ? _b2 : "P-256";
              switch (crv) {
                case void 0:
                case "P-256":
                case "P-384":
                case "P-521":
                  return generate("ec", { namedCurve: crv });
                case "X25519":
                  return generate("x25519");
                case "X448":
                  return generate("x448");
                default:
                  throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
              }
            default:
              throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
          }
        }
        exports22.generateKeyPair = generateKeyPair;
      }
    });
    var require_generate_key_pair = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_key_pair.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.generateKeyPair = void 0;
        var generate_js_1 = require_generate();
        async function generateKeyPair(alg, options) {
          return (0, generate_js_1.generateKeyPair)(alg, options);
        }
        exports22.generateKeyPair = generateKeyPair;
      }
    });
    var require_generate_secret = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_secret.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.generateSecret = void 0;
        var generate_js_1 = require_generate();
        async function generateSecret(alg, options) {
          return (0, generate_js_1.generateSecret)(alg, options);
        }
        exports22.generateSecret = generateSecret;
      }
    });
    var require_cjs4 = __commonJS2({
      "../../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/index.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.base64url = exports22.generateSecret = exports22.generateKeyPair = exports22.errors = exports22.decodeJwt = exports22.decodeProtectedHeader = exports22.importJWK = exports22.importX509 = exports22.importPKCS8 = exports22.importSPKI = exports22.exportJWK = exports22.exportSPKI = exports22.exportPKCS8 = exports22.UnsecuredJWT = exports22.createRemoteJWKSet = exports22.createLocalJWKSet = exports22.EmbeddedJWK = exports22.calculateJwkThumbprintUri = exports22.calculateJwkThumbprint = exports22.EncryptJWT = exports22.SignJWT = exports22.GeneralSign = exports22.FlattenedSign = exports22.CompactSign = exports22.FlattenedEncrypt = exports22.CompactEncrypt = exports22.jwtDecrypt = exports22.jwtVerify = exports22.generalVerify = exports22.flattenedVerify = exports22.compactVerify = exports22.GeneralEncrypt = exports22.generalDecrypt = exports22.flattenedDecrypt = exports22.compactDecrypt = void 0;
        var decrypt_js_1 = require_decrypt3();
        Object.defineProperty(exports22, "compactDecrypt", { enumerable: true, get: function() {
          return decrypt_js_1.compactDecrypt;
        } });
        var decrypt_js_2 = require_decrypt2();
        Object.defineProperty(exports22, "flattenedDecrypt", { enumerable: true, get: function() {
          return decrypt_js_2.flattenedDecrypt;
        } });
        var decrypt_js_3 = require_decrypt4();
        Object.defineProperty(exports22, "generalDecrypt", { enumerable: true, get: function() {
          return decrypt_js_3.generalDecrypt;
        } });
        var encrypt_js_1 = require_encrypt3();
        Object.defineProperty(exports22, "GeneralEncrypt", { enumerable: true, get: function() {
          return encrypt_js_1.GeneralEncrypt;
        } });
        var verify_js_1 = require_verify3();
        Object.defineProperty(exports22, "compactVerify", { enumerable: true, get: function() {
          return verify_js_1.compactVerify;
        } });
        var verify_js_2 = require_verify2();
        Object.defineProperty(exports22, "flattenedVerify", { enumerable: true, get: function() {
          return verify_js_2.flattenedVerify;
        } });
        var verify_js_3 = require_verify4();
        Object.defineProperty(exports22, "generalVerify", { enumerable: true, get: function() {
          return verify_js_3.generalVerify;
        } });
        var verify_js_4 = require_verify5();
        Object.defineProperty(exports22, "jwtVerify", { enumerable: true, get: function() {
          return verify_js_4.jwtVerify;
        } });
        var decrypt_js_4 = require_decrypt5();
        Object.defineProperty(exports22, "jwtDecrypt", { enumerable: true, get: function() {
          return decrypt_js_4.jwtDecrypt;
        } });
        var encrypt_js_2 = require_encrypt4();
        Object.defineProperty(exports22, "CompactEncrypt", { enumerable: true, get: function() {
          return encrypt_js_2.CompactEncrypt;
        } });
        var encrypt_js_3 = require_encrypt2();
        Object.defineProperty(exports22, "FlattenedEncrypt", { enumerable: true, get: function() {
          return encrypt_js_3.FlattenedEncrypt;
        } });
        var sign_js_1 = require_sign3();
        Object.defineProperty(exports22, "CompactSign", { enumerable: true, get: function() {
          return sign_js_1.CompactSign;
        } });
        var sign_js_2 = require_sign2();
        Object.defineProperty(exports22, "FlattenedSign", { enumerable: true, get: function() {
          return sign_js_2.FlattenedSign;
        } });
        var sign_js_3 = require_sign4();
        Object.defineProperty(exports22, "GeneralSign", { enumerable: true, get: function() {
          return sign_js_3.GeneralSign;
        } });
        var sign_js_4 = require_sign5();
        Object.defineProperty(exports22, "SignJWT", { enumerable: true, get: function() {
          return sign_js_4.SignJWT;
        } });
        var encrypt_js_4 = require_encrypt5();
        Object.defineProperty(exports22, "EncryptJWT", { enumerable: true, get: function() {
          return encrypt_js_4.EncryptJWT;
        } });
        var thumbprint_js_1 = require_thumbprint();
        Object.defineProperty(exports22, "calculateJwkThumbprint", { enumerable: true, get: function() {
          return thumbprint_js_1.calculateJwkThumbprint;
        } });
        Object.defineProperty(exports22, "calculateJwkThumbprintUri", { enumerable: true, get: function() {
          return thumbprint_js_1.calculateJwkThumbprintUri;
        } });
        var embedded_js_1 = require_embedded();
        Object.defineProperty(exports22, "EmbeddedJWK", { enumerable: true, get: function() {
          return embedded_js_1.EmbeddedJWK;
        } });
        var local_js_1 = require_local();
        Object.defineProperty(exports22, "createLocalJWKSet", { enumerable: true, get: function() {
          return local_js_1.createLocalJWKSet;
        } });
        var remote_js_1 = require_remote();
        Object.defineProperty(exports22, "createRemoteJWKSet", { enumerable: true, get: function() {
          return remote_js_1.createRemoteJWKSet;
        } });
        var unsecured_js_1 = require_unsecured();
        Object.defineProperty(exports22, "UnsecuredJWT", { enumerable: true, get: function() {
          return unsecured_js_1.UnsecuredJWT;
        } });
        var export_js_1 = require_export();
        Object.defineProperty(exports22, "exportPKCS8", { enumerable: true, get: function() {
          return export_js_1.exportPKCS8;
        } });
        Object.defineProperty(exports22, "exportSPKI", { enumerable: true, get: function() {
          return export_js_1.exportSPKI;
        } });
        Object.defineProperty(exports22, "exportJWK", { enumerable: true, get: function() {
          return export_js_1.exportJWK;
        } });
        var import_js_1 = require_import();
        Object.defineProperty(exports22, "importSPKI", { enumerable: true, get: function() {
          return import_js_1.importSPKI;
        } });
        Object.defineProperty(exports22, "importPKCS8", { enumerable: true, get: function() {
          return import_js_1.importPKCS8;
        } });
        Object.defineProperty(exports22, "importX509", { enumerable: true, get: function() {
          return import_js_1.importX509;
        } });
        Object.defineProperty(exports22, "importJWK", { enumerable: true, get: function() {
          return import_js_1.importJWK;
        } });
        var decode_protected_header_js_1 = require_decode_protected_header();
        Object.defineProperty(exports22, "decodeProtectedHeader", { enumerable: true, get: function() {
          return decode_protected_header_js_1.decodeProtectedHeader;
        } });
        var decode_jwt_js_1 = require_decode_jwt();
        Object.defineProperty(exports22, "decodeJwt", { enumerable: true, get: function() {
          return decode_jwt_js_1.decodeJwt;
        } });
        exports22.errors = require_errors5();
        var generate_key_pair_js_1 = require_generate_key_pair();
        Object.defineProperty(exports22, "generateKeyPair", { enumerable: true, get: function() {
          return generate_key_pair_js_1.generateKeyPair;
        } });
        var generate_secret_js_1 = require_generate_secret();
        Object.defineProperty(exports22, "generateSecret", { enumerable: true, get: function() {
          return generate_secret_js_1.generateSecret;
        } });
        exports22.base64url = require_base64url2();
      }
    });
    var require_createToken = __commonJS2({
      "../token/dist/createToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createToken = void 0;
        var jose_1 = require_cjs4();
        var textEncoder = new TextEncoder();
        var createToken = function(_a) {
          var payload = _a.payload, secret = _a.secret, expiration = _a.expiration;
          return __awaiter(void 0, void 0, void 0, function() {
            var secretKey, jwt;
            return __generator(this, function(_b2) {
              secretKey = textEncoder.encode(secret);
              jwt = new jose_1.SignJWT(payload).setProtectedHeader({ alg: "HS256" });
              if (expiration) {
                jwt.setExpirationTime(expiration);
              }
              return [2, jwt.sign(secretKey)];
            });
          });
        };
        exports22.createToken = createToken;
      }
    });
    var require_createAccessToken = __commonJS2({
      "../token/dist/createAccessToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createAccessToken = void 0;
        var createToken_1 = require_createToken();
        var createAccessToken = function(args) {
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, (0, createToken_1.createToken)(args)];
            });
          });
        };
        exports22.createAccessToken = createAccessToken;
      }
    });
    var require_createAssetsAccessToken = __commonJS2({
      "../token/dist/createAssetsAccessToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createAssetsAccessToken = void 0;
        var createToken_1 = require_createToken();
        var createAssetsAccessToken2 = function(args) {
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, (0, createToken_1.createToken)(args)];
            });
          });
        };
        exports22.createAssetsAccessToken = createAssetsAccessToken2;
      }
    });
    var require_url_alphabet = __commonJS2({
      "../../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.cjs"(exports22, module22) {
        var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
        module22.exports = { urlAlphabet };
      }
    });
    var require_nanoid = __commonJS2({
      "../../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.cjs"(exports22, module22) {
        var crypto = require("crypto");
        var { urlAlphabet } = require_url_alphabet();
        var POOL_SIZE_MULTIPLIER = 128;
        var pool;
        var poolOffset;
        var fillPool = (bytes) => {
          if (!pool || pool.length < bytes) {
            pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
            crypto.randomFillSync(pool);
            poolOffset = 0;
          } else if (poolOffset + bytes > pool.length) {
            crypto.randomFillSync(pool);
            poolOffset = 0;
          }
          poolOffset += bytes;
        };
        var random = (bytes) => {
          fillPool(bytes -= 0);
          return pool.subarray(poolOffset - bytes, poolOffset);
        };
        var customRandom = (alphabet, defaultSize, getRandom) => {
          let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
          let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
          return (size = defaultSize) => {
            let id = "";
            while (true) {
              let bytes = getRandom(step);
              let i = step;
              while (i--) {
                id += alphabet[bytes[i] & mask] || "";
                if (id.length === size) return id;
              }
            }
          };
        };
        var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
        var nanoid = (size = 21) => {
          fillPool(size -= 0);
          let id = "";
          for (let i = poolOffset - size; i < poolOffset; i++) {
            id += urlAlphabet[pool[i] & 63];
          }
          return id;
        };
        module22.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random };
      }
    });
    var require_createChallengeToken = __commonJS2({
      "../token/dist/createChallengeToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createChallengeToken = void 0;
        var nanoid_1 = require_nanoid();
        var createToken_1 = require_createToken();
        var createChallengeToken = function(_a) {
          var secret = _a.secret;
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(this, function(_b2) {
              return [2, (0, createToken_1.createToken)({ payload: { challenge: (0, nanoid_1.nanoid)(20) }, secret, expiration: "10m" })];
            });
          });
        };
        exports22.createChallengeToken = createChallengeToken;
      }
    });
    var require_createMigrationToken = __commonJS2({
      "../token/dist/createMigrationToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createMigrationToken = void 0;
        var createToken_1 = require_createToken();
        var createMigrationToken = function(args) {
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, (0, createToken_1.createToken)(args)];
            });
          });
        };
        exports22.createMigrationToken = createMigrationToken;
      }
    });
    var require_createPersonalAccessToken = __commonJS2({
      "../token/dist/createPersonalAccessToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createPersonalAccessToken = void 0;
        var nanoid_1 = require_nanoid();
        var createPersonalAccessToken = function() {
          return "pat_".concat((0, nanoid_1.nanoid)(20));
        };
        exports22.createPersonalAccessToken = createPersonalAccessToken;
      }
    });
    var require_decodeToken = __commonJS2({
      "../token/dist/decodeToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decodeToken = void 0;
        var errors_1 = require_dist9();
        var jose_1 = require_cjs4();
        var decodeToken = function(_a) {
          var token = _a.token;
          try {
            return (0, jose_1.decodeJwt)(token);
          } catch (_b2) {
            throw new errors_1.AuthorizationError();
          }
        };
        exports22.decodeToken = decodeToken;
      }
    });
    var require_decodeAccessToken = __commonJS2({
      "../token/dist/decodeAccessToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.decodeAccessToken = void 0;
        var decodeToken_1 = require_decodeToken();
        var decodeAccessToken = function(args) {
          return (0, decodeToken_1.decodeToken)(args);
        };
        exports22.decodeAccessToken = decodeAccessToken;
      }
    });
    var require_getTokenFromRequest = __commonJS2({
      "../token/dist/getTokenFromRequest.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.getTokenFromRequest = void 0;
        var errors_1 = require_dist9();
        var getTokenFromRequest = function(request) {
          var header = request.headers.authorization;
          if (!header) {
            throw new errors_1.AuthorizationError();
          }
          return header.replace("Bearer ", "");
        };
        exports22.getTokenFromRequest = getTokenFromRequest;
      }
    });
    var require_jscrypto = __commonJS2({
      "../../../node_modules/.pnpm/jscrypto@1.0.3/node_modules/jscrypto/index.js"(exports22, module22) {
        !function(n, t2) {
          if ("object" == typeof exports22 && "object" == typeof module22) module22.exports = t2();
          else if ("function" == typeof define && define.amd) define([], t2);
          else if ("object" == typeof exports22) exports22.JsCrypto = t2();
          else {
            var r = t2();
            for (var i in n.JsCrypto = n.JsCrypto || {}, r) n.JsCrypto[i] = r[i];
          }
        }(exports22, function() {
          return function() {
            "use strict";
            var n = { 9691: function(n2, t22, r2) {
              r2.d(t22, { AES: function() {
                return _;
              } });
              var i2, e = r2(9456), o = r2(787), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), s = function() {
                return (s = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, a = [], h = [], v = [], w = [], l = [], b = [], d = [], y = [], p = [], O = [];
              !function() {
                for (var n3 = [], t3 = 0; t3 < 256; t3++) n3[t3] = t3 < 128 ? t3 << 1 : t3 << 1 ^ 283;
                var r3 = 0, i3 = 0;
                for (t3 = 0; t3 < 256; t3++) {
                  var e2 = i3 ^ i3 << 1 ^ i3 << 2 ^ i3 << 3 ^ i3 << 4;
                  e2 = e2 >>> 8 ^ 255 & e2 ^ 99, a[r3] = e2, h[e2] = r3;
                  var o2 = n3[r3], u2 = n3[o2], f2 = n3[u2], c2 = 257 * n3[e2] ^ 16843008 * e2;
                  v[r3] = c2 << 24 | c2 >>> 8, w[r3] = c2 << 16 | c2 >>> 16, l[r3] = c2 << 8 | c2 >>> 24, b[r3] = c2, c2 = 16843009 * f2 ^ 65537 * u2 ^ 257 * o2 ^ 16843008 * r3, d[e2] = c2 << 24 | c2 >>> 8, y[e2] = c2 << 16 | c2 >>> 16, p[e2] = c2 << 8 | c2 >>> 24, O[e2] = c2, r3 ? (r3 = o2 ^ n3[n3[n3[f2 ^ o2]]], i3 ^= n3[n3[i3]]) : r3 = i3 = 1;
                }
              }();
              var j = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], _ = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.u = 0, r3.h = [], r3.v = [], r3.O = t4, r3.A(), r3;
                }
                return c(t3, n3), t3.prototype.A = function() {
                  var n4;
                  if (!this.u || this.k !== this.H) {
                    for (var t4 = this.k = this.H, r3 = t4.words, i3 = t4.nSigBytes / 4, e2 = 4 * ((this.u = i3 + 6) + 1), o2 = this.h = [], u2 = 0; u2 < e2; u2++) u2 < i3 ? o2[u2] = r3[u2] : (n4 = o2[u2 - 1], u2 % i3 ? i3 > 6 && u2 % i3 == 4 && (n4 = a[n4 >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4]) : (n4 = a[(n4 = n4 << 8 | n4 >>> 24) >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4], n4 ^= j[u2 / i3 | 0] << 24), o2[u2] = o2[u2 - i3] ^ n4);
                    this.v = [];
                    for (var f2 = 0; f2 < e2; f2++) {
                      u2 = e2 - f2;
                      n4 = f2 % 4 ? o2[u2] : o2[u2 - 4], this.v[f2] = f2 < 4 || u2 <= 4 ? n4 : d[a[n4 >>> 24]] ^ y[a[n4 >>> 16 & 255]] ^ p[a[n4 >>> 8 & 255]] ^ O[a[255 & n4]];
                    }
                  }
                }, t3.prototype.encryptBlock = function(n4, t4) {
                  this.B(n4, t4, this.h, v, w, l, b, a);
                }, t3.prototype.decryptBlock = function(n4, t4) {
                  var r3 = n4[t4 + 1];
                  n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3, this.B(n4, t4, this.v, d, y, p, O, h), r3 = n4[t4 + 1], n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3;
                }, t3.prototype.B = function(n4, t4, r3, i3, e2, o2, u2, f2) {
                  for (var c2 = this.u, s2 = n4[t4] ^ r3[0], a2 = n4[t4 + 1] ^ r3[1], h2 = n4[t4 + 2] ^ r3[2], v2 = n4[t4 + 3] ^ r3[3], w2 = 4, l2 = 1; l2 < c2; l2++) {
                    var b2 = i3[s2 >>> 24] ^ e2[a2 >>> 16 & 255] ^ o2[h2 >>> 8 & 255] ^ u2[255 & v2] ^ r3[w2++], d2 = i3[a2 >>> 24] ^ e2[h2 >>> 16 & 255] ^ o2[v2 >>> 8 & 255] ^ u2[255 & s2] ^ r3[w2++], y2 = i3[h2 >>> 24] ^ e2[v2 >>> 16 & 255] ^ o2[s2 >>> 8 & 255] ^ u2[255 & a2] ^ r3[w2++], p2 = i3[v2 >>> 24] ^ e2[s2 >>> 16 & 255] ^ o2[a2 >>> 8 & 255] ^ u2[255 & h2] ^ r3[w2++];
                    s2 = b2, a2 = d2, h2 = y2, v2 = p2;
                  }
                  var O2 = (f2[s2 >>> 24] << 24 | f2[a2 >>> 16 & 255] << 16 | f2[h2 >>> 8 & 255] << 8 | f2[255 & v2]) ^ r3[w2++], j2 = (f2[a2 >>> 24] << 24 | f2[h2 >>> 16 & 255] << 16 | f2[v2 >>> 8 & 255] << 8 | f2[255 & s2]) ^ r3[w2++], _2 = (f2[h2 >>> 24] << 24 | f2[v2 >>> 16 & 255] << 16 | f2[s2 >>> 8 & 255] << 8 | f2[255 & a2]) ^ r3[w2++], m = (f2[v2 >>> 24] << 24 | f2[s2 >>> 16 & 255] << 16 | f2[a2 >>> 8 & 255] << 8 | f2[255 & h2]) ^ r3[w2++];
                  n4[t4] = O2, n4[t4 + 1] = j2, n4[t4 + 2] = _2, n4[t4 + 3] = m;
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
                }, t3.encrypt = function(n4, r3, i3) {
                  if ("string" == typeof r3) return u.E.encrypt(t3, n4, r3, i3);
                  if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
                  return f.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  if ("string" == typeof r3) return u.E.decrypt(t3, n4, r3, i3);
                  if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
                  return f.D.decrypt(t3, n4, r3, i3);
                }, t3.keySize = 8, t3;
              }(o.G);
            }, 3967: function(n2, t22, r2) {
              r2.d(t22, { CBCMAC: function() {
                return f;
              } });
              var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(3664);
              function f(n3, t3, r3, f2, c, s) {
                var a = s && s.Cipher ? s.Cipher : o.AES, h = "string" == typeof r3 ? i2.d.parse(r3) : r3, v = f2 || new e.e([0, 0]), w = "string" == typeof t3 ? i2.d.parse(t3) : t3, l = "string" == typeof n3 ? i2.d.parse(n3) : n3, b = c || 16;
                return u.K.mac(a, h, v, w, l, b);
              }
            }, 9910: function(n2, t22, r2) {
              r2.d(t22, { DES: function() {
                return b;
              } });
              var i2, e = r2(787), o = r2(9456), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), s = function() {
                return (s = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], h = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], v = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], w = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], b = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 2, r3.I = [], r3.U = [], r3.L = 0, r3.F = 0, r3.O = t4, r3.A(), r3;
                }
                return c(t3, n3), t3.prototype.A = function() {
                  for (var n4 = this.H.words, t4 = [], r3 = 0; r3 < 56; r3++) {
                    var i3 = a[r3] - 1;
                    t4[r3] = n4[i3 >>> 5] >>> 31 - i3 % 32 & 1;
                  }
                  for (var e2 = this.I = [], o2 = 0; o2 < 16; o2++) {
                    var u2 = e2[o2] = [], f2 = v[o2];
                    for (r3 = 0; r3 < 24; r3++) u2[r3 / 6 | 0] |= t4[(h[r3] - 1 + f2) % 28] << 31 - r3 % 6, u2[4 + (r3 / 6 | 0)] |= t4[28 + (h[r3 + 24] - 1 + f2) % 28] << 31 - r3 % 6;
                    u2[0] = u2[0] << 1 | u2[0] >>> 31;
                    for (r3 = 1; r3 < 7; r3++) u2[r3] = u2[r3] >>> 4 * (r3 - 1) + 3;
                    u2[7] = u2[7] << 5 | u2[7] >>> 27;
                  }
                  this.U = [];
                  for (r3 = 0; r3 < 16; r3++) this.U[r3] = e2[15 - r3];
                }, t3.prototype.encryptBlock = function(n4, t4) {
                  this.R(n4, t4, this.I);
                }, t3.prototype.decryptBlock = function(n4, t4) {
                  this.R(n4, t4, this.U);
                }, t3.prototype.R = function(n4, t4, r3) {
                  this.L = n4[t4], this.F = n4[t4 + 1], this.X(4, 252645135), this.X(16, 65535), this.Z(2, 858993459), this.Z(8, 16711935), this.X(1, 1431655765);
                  for (var i3 = 0; i3 < 16; i3++) {
                    for (var e2 = r3[i3], o2 = this.L, u2 = this.F, f2 = 0, c2 = 0; c2 < 8; c2++) {
                      var s2 = (u2 ^ e2[c2]) & l[c2];
                      f2 |= w[c2][s2 >>> 0];
                    }
                    this.L = u2, this.F = o2 ^ f2;
                  }
                  var a2 = this.L;
                  this.L = this.F, this.F = a2, this.X(1, 1431655765), this.Z(8, 16711935), this.Z(2, 858993459), this.X(16, 65535), this.X(4, 252645135), n4[t4] = this.L, n4[t4 + 1] = this.F;
                }, t3.prototype.X = function(n4, t4) {
                  var r3 = (this.L >>> n4 ^ this.F) & t4;
                  this.F ^= r3, this.L ^= r3 << n4;
                }, t3.prototype.Z = function(n4, t4) {
                  var r3 = (this.F >>> n4 ^ this.L) & t4;
                  this.L ^= r3, this.F ^= r3 << n4;
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.ENC_TRANSFORM_MODE }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.DEC_TRANSFORM_MODE }));
                }, t3.encrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? u.E.encrypt(t3, n4, r3, i3) : f.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? u.E.decrypt(t3, n4, r3, i3) : f.D.decrypt(t3, n4, r3, i3);
                }, t3.keySize = 2, t3.ivSize = 2, t3;
              }(e.G);
            }, 6739: function(n2, t22, r2) {
              r2.d(t22, { DES3: function() {
                return v;
              } });
              var i2, e = r2(9109), o = r2(787), u = r2(9456), f = r2(9910), c = r2(3354), s = r2(5693), a = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), h = function() {
                return (h = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, v = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  r3.N = 2, r3.O = t4;
                  var i3 = r3.J();
                  return r3.Y = i3[0], r3.$ = i3[1], r3.nn = i3[2], r3;
                }
                return a(t3, n3), t3.prototype.J = function() {
                  var n4 = this.H.words;
                  if (2 !== n4.length && 4 !== n4.length && n4.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                  var t4 = n4.slice(0, 2), r3 = n4.length < 4 ? n4.slice(0, 2) : n4.slice(2, 4), i3 = n4.length < 6 ? n4.slice(0, 2) : n4.slice(4, 6);
                  return [f.DES.createEncryptor(new c.e(t4)), f.DES.createEncryptor(new c.e(r3)), f.DES.createEncryptor(new c.e(i3))];
                }, t3.prototype.A = function() {
                  var n4 = this.J();
                  this.Y = n4[0], this.$ = n4[1], this.nn = n4[2];
                }, t3.prototype.encryptBlock = function(n4, t4) {
                  this.Y.encryptBlock(n4, t4), this.$.decryptBlock(n4, t4), this.nn.encryptBlock(n4, t4);
                }, t3.prototype.decryptBlock = function(n4, t4) {
                  this.nn.decryptBlock(n4, t4), this.$.encryptBlock(n4, t4), this.Y.decryptBlock(n4, t4);
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.ENC_TRANSFORM_MODE }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.DEC_TRANSFORM_MODE }));
                }, t3.encrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? s.E.encrypt(t3, n4, r3, i3) : e.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? s.E.decrypt(t3, n4, r3, i3) : e.D.decrypt(t3, n4, r3, i3);
                }, t3.keySize = 6, t3.ivSize = 2, t3;
              }(o.G);
            }, 7753: function(n2, t22, r2) {
              r2.d(t22, { GMAC: function() {
                return f;
              } });
              var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(5607);
              function f(n3, t3, r3, f2, c) {
                var s = "string" == typeof n3 ? i2.d.parse(n3) : n3, a = r3 || new e.e([0, 0, 0, 0]), h = c && c.Cipher ? c.Cipher : o.AES, v = "string" == typeof t3 ? i2.d.parse(t3) : t3, w = f2 || 16;
                return u.V.mac(h, v, a, s, void 0, w);
              }
            }, 6367: function(n2, t22, r2) {
              r2.d(t22, { Hmac: function() {
                return e;
              } });
              var i2 = r2(4768), e = function() {
                function n3(n4, t3) {
                  this.tn = n4, "string" == typeof t3 && (t3 = i2.d.parse(t3));
                  var r3 = n4.blockSize, e2 = 4 * r3;
                  t3.nSigBytes > e2 && (t3 = n4.finalize(t3)), t3.clamp();
                  for (var o = this.rn = t3.clone(), u = this.en = t3.clone(), f = o.words, c = u.words, s = 0; s < r3; s++) f[s] ^= 1549556828, c[s] ^= 909522486;
                  u.nSigBytes = e2, o.nSigBytes = e2, this.reset();
                }
                return n3.prototype.reset = function() {
                  this.tn.reset(), this.tn.update(this.en);
                }, n3.prototype.update = function(n4) {
                  return this.tn.update(n4), this;
                }, n3.prototype.finalize = function(n4) {
                  var t3 = this.tn.finalize(n4);
                  return this.tn.reset(), this.tn.finalize(this.rn.clone().concat(t3));
                }, n3;
              }();
            }, 3027: function(n2, t22, r2) {
              r2.d(t22, { HmacMD5: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(670);
              function o(n3, t3) {
                return new i2.Hmac(new e.MD5(), t3).finalize(n3);
              }
            }, 149: function(n2, t22, r2) {
              r2.d(t22, { HmacSHA1: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(3173);
              function o(n3, t3) {
                return new i2.Hmac(new e.SHA1(), t3).finalize(n3);
              }
            }, 4105: function(n2, t22, r2) {
              r2.d(t22, { HmacSHA224: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(766);
              function o(n3, t3) {
                return new i2.Hmac(new e.SHA224(), t3).finalize(n3);
              }
            }, 980: function(n2, t22, r2) {
              r2.d(t22, { HmacSHA256: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(5561);
              function o(n3, t3) {
                return new i2.Hmac(new e.SHA256(), t3).finalize(n3);
              }
            }, 5838: function(n2, t22, r2) {
              r2.d(t22, { HmacSHA384: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(6324);
              function o(n3, t3) {
                return new i2.Hmac(new e.SHA384(), t3).finalize(n3);
              }
            }, 9902: function(n2, t22, r2) {
              r2.d(t22, { HmacSHA512: function() {
                return o;
              } });
              var i2 = r2(6367), e = r2(7491);
              function o(n3, t3) {
                return new i2.Hmac(new e.SHA512(), t3).finalize(n3);
              }
            }, 670: function(n2, t22, r2) {
              r2.d(t22, { MD5: function() {
                return v;
              } });
              var i2, e = r2(3354), o = r2(1868), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = [];
              function c(n3, t3, r3, i3, e2, o2, u2) {
                var f2 = n3 + (t3 & r3 | ~t3 & i3) + e2 + u2;
                return (f2 << o2 | f2 >>> 32 - o2) + t3;
              }
              function s(n3, t3, r3, i3, e2, o2, u2) {
                var f2 = n3 + (t3 & i3 | r3 & ~i3) + e2 + u2;
                return (f2 << o2 | f2 >>> 32 - o2) + t3;
              }
              function a(n3, t3, r3, i3, e2, o2, u2) {
                var f2 = n3 + (t3 ^ r3 ^ i3) + e2 + u2;
                return (f2 << o2 | f2 >>> 32 - o2) + t3;
              }
              function h(n3, t3, r3, i3, e2, o2, u2) {
                var f2 = n3 + (r3 ^ (t3 | ~i3)) + e2 + u2;
                return (f2 << o2 | f2 >>> 32 - o2) + t3;
              }
              !function() {
                for (var n3 = 0; n3 < 64; n3++) f[n3] = 4294967296 * Math.abs(Math.sin(n3 + 1)) | 0;
              }();
              var v = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]), t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]);
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = 0; r3 < 16; r3++) {
                    var i3 = t4 + r3, e2 = n4[i3];
                    n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
                  }
                  var o2 = this.on.words, u2 = n4[t4], v2 = n4[t4 + 1], w = n4[t4 + 2], l = n4[t4 + 3], b = n4[t4 + 4], d = n4[t4 + 5], y = n4[t4 + 6], p = n4[t4 + 7], O = n4[t4 + 8], j = n4[t4 + 9], _ = n4[t4 + 10], m = n4[t4 + 11], A = n4[t4 + 12], g = n4[t4 + 13], E = n4[t4 + 14], S = n4[t4 + 15], M = o2[0], k = o2[1], H = o2[2], C = o2[3];
                  M = c(M, k, H, C, u2, 7, f[0]), C = c(C, M, k, H, v2, 12, f[1]), H = c(H, C, M, k, w, 17, f[2]), k = c(k, H, C, M, l, 22, f[3]), M = c(M, k, H, C, b, 7, f[4]), C = c(C, M, k, H, d, 12, f[5]), H = c(H, C, M, k, y, 17, f[6]), k = c(k, H, C, M, p, 22, f[7]), M = c(M, k, H, C, O, 7, f[8]), C = c(C, M, k, H, j, 12, f[9]), H = c(H, C, M, k, _, 17, f[10]), k = c(k, H, C, M, m, 22, f[11]), M = c(M, k, H, C, A, 7, f[12]), C = c(C, M, k, H, g, 12, f[13]), H = c(H, C, M, k, E, 17, f[14]), M = s(M, k = c(k, H, C, M, S, 22, f[15]), H, C, v2, 5, f[16]), C = s(C, M, k, H, y, 9, f[17]), H = s(H, C, M, k, m, 14, f[18]), k = s(k, H, C, M, u2, 20, f[19]), M = s(M, k, H, C, d, 5, f[20]), C = s(C, M, k, H, _, 9, f[21]), H = s(H, C, M, k, S, 14, f[22]), k = s(k, H, C, M, b, 20, f[23]), M = s(M, k, H, C, j, 5, f[24]), C = s(C, M, k, H, E, 9, f[25]), H = s(H, C, M, k, l, 14, f[26]), k = s(k, H, C, M, O, 20, f[27]), M = s(M, k, H, C, g, 5, f[28]), C = s(C, M, k, H, w, 9, f[29]), H = s(H, C, M, k, p, 14, f[30]), M = a(M, k = s(k, H, C, M, A, 20, f[31]), H, C, d, 4, f[32]), C = a(C, M, k, H, O, 11, f[33]), H = a(H, C, M, k, m, 16, f[34]), k = a(k, H, C, M, E, 23, f[35]), M = a(M, k, H, C, v2, 4, f[36]), C = a(C, M, k, H, b, 11, f[37]), H = a(H, C, M, k, p, 16, f[38]), k = a(k, H, C, M, _, 23, f[39]), M = a(M, k, H, C, g, 4, f[40]), C = a(C, M, k, H, u2, 11, f[41]), H = a(H, C, M, k, l, 16, f[42]), k = a(k, H, C, M, y, 23, f[43]), M = a(M, k, H, C, j, 4, f[44]), C = a(C, M, k, H, A, 11, f[45]), H = a(H, C, M, k, S, 16, f[46]), M = h(M, k = a(k, H, C, M, w, 23, f[47]), H, C, u2, 6, f[48]), C = h(C, M, k, H, p, 10, f[49]), H = h(H, C, M, k, E, 15, f[50]), k = h(k, H, C, M, d, 21, f[51]), M = h(M, k, H, C, A, 6, f[52]), C = h(C, M, k, H, l, 10, f[53]), H = h(H, C, M, k, _, 15, f[54]), k = h(k, H, C, M, v2, 21, f[55]), M = h(M, k, H, C, O, 6, f[56]), C = h(C, M, k, H, S, 10, f[57]), H = h(H, C, M, k, y, 15, f[58]), k = h(k, H, C, M, g, 21, f[59]), M = h(M, k, H, C, b, 6, f[60]), C = h(C, M, k, H, m, 10, f[61]), H = h(H, C, M, k, w, 15, f[62]), k = h(k, H, C, M, j, 21, f[63]), o2[0] = o2[0] + M | 0, o2[1] = o2[1] + k | 0, o2[2] = o2[2] + H | 0, o2[3] = o2[3] + C | 0;
                }, t3.prototype.fn = function() {
                  var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                  t4[i3 >>> 5] |= 128 << 24 - i3 % 32;
                  var e2 = Math.floor(r3 / 4294967296), o2 = r3;
                  t4[15 + (i3 + 64 >>> 9 << 4)] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8), t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
                  for (var u2 = this.on, f2 = u2.words, c2 = 0; c2 < 4; c2++) {
                    var s2 = f2[c2];
                    f2[c2] = 16711935 & (s2 << 8 | s2 >>> 24) | 4278255360 & (s2 << 24 | s2 >>> 8);
                  }
                  return u2;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4) {
                  return new t3().finalize(n4);
                }, t3;
              }(o.P);
            }, 4615: function(n2, t22, r2) {
              r2.d(t22, { RC4: function() {
                return s;
              } });
              var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function() {
                return (c = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.S = [], r3.i = 0, r3.j = 0, r3.O = t4, r3.A(), r3;
                }
                return f(t3, n3), t3.prototype.A = function() {
                  var n4 = this.H, t4 = n4.words, r3 = n4.nSigBytes;
                  this.S = [];
                  for (var i3 = 0; i3 < 256; i3++) this.S[i3] = i3;
                  i3 = 0;
                  for (var e2 = 0; i3 < 256; i3++) {
                    var o2 = i3 % r3, u2 = t4[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
                    e2 = (e2 + this.S[i3] + u2) % 256;
                    var f2 = this.S[i3];
                    this.S[i3] = this.S[e2], this.S[e2] = f2;
                  }
                  this.i = this.j = 0;
                }, t3.prototype.un = function(n4, t4) {
                  n4[t4] ^= this.generateKeyStreamWord();
                }, t3.prototype.generateKeyStreamWord = function() {
                  for (var n4 = this.S, t4 = this.i, r3 = this.j, i3 = 0, e2 = 0; e2 < 4; e2++) {
                    r3 = (r3 + n4[t4 = (t4 + 1) % 256]) % 256;
                    var o2 = n4[t4];
                    n4[t4] = n4[r3], n4[r3] = o2, i3 |= n4[(n4[t4] + n4[r3]) % 256] << 24 - 8 * e2;
                  }
                  return this.i = t4, this.j = r3, i3;
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.encrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
                }, t3.ivSize = 0, t3.keySize = 8, t3;
              }(e.q);
            }, 9639: function(n2, t22, r2) {
              r2.d(t22, { RC4Drop: function() {
                return s;
              } });
              var i2, e = r2(5693), o = r2(9109), u = r2(4615), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function() {
                return (c = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.drop = 192, r3.O = t4, t4 && "number" == typeof t4.drop && (r3.drop = t4.drop), r3.A(), r3;
                }
                return f(t3, n3), t3.prototype.A = function() {
                  n3.prototype.A.call(this);
                  for (var t4 = this.drop; t4 > 0; t4--) this.generateKeyStreamWord();
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.encrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? e.E.encrypt(t3, n4, r3, i3) : o.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? e.E.decrypt(t3, n4, r3, i3) : o.D.decrypt(t3, n4, r3, i3);
                }, t3;
              }(u.RC4);
            }, 7104: function(n2, t22, r2) {
              r2.d(t22, { RIPEMD160: function() {
                return O;
              } });
              var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = new o.e([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), c = new o.e([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), s = new o.e([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), a = new o.e([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), h = new o.e([0, 1518500249, 1859775393, 2400959708, 2840853838]), v = new o.e([1352829926, 1548603684, 1836072691, 2053994217, 0]);
              function w(n3, t3, r3) {
                return n3 ^ t3 ^ r3;
              }
              function l(n3, t3, r3) {
                return n3 & t3 | ~n3 & r3;
              }
              function b(n3, t3, r3) {
                return (n3 | ~t3) ^ r3;
              }
              function d(n3, t3, r3) {
                return n3 & r3 | t3 & ~r3;
              }
              function y(n3, t3, r3) {
                return n3 ^ (t3 | ~r3);
              }
              function p(n3, t3) {
                return n3 << t3 | n3 >>> 32 - t3;
              }
              var O = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = 0; r3 < 16; r3++) {
                    var i3 = t4 + r3, e2 = n4[i3];
                    n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
                  }
                  var o2, u2, O2, j, _, m, A, g, E, S, M, k = this.on.words, H = h.words, C = v.words, B = f.words, N = c.words, I = s.words, z = a.words;
                  m = o2 = k[0], A = u2 = k[1], g = O2 = k[2], E = j = k[3], S = _ = k[4];
                  for (r3 = 0; r3 < 80; r3 += 1) M = o2 + n4[t4 + B[r3]] | 0, M += r3 < 16 ? w(u2, O2, j) + H[0] : r3 < 32 ? l(u2, O2, j) + H[1] : r3 < 48 ? b(u2, O2, j) + H[2] : r3 < 64 ? d(u2, O2, j) + H[3] : y(u2, O2, j) + H[4], M = (M = p(M |= 0, I[r3])) + _ | 0, o2 = _, _ = j, j = p(O2, 10), O2 = u2, u2 = M, M = m + n4[t4 + N[r3]] | 0, M += r3 < 16 ? y(A, g, E) + C[0] : r3 < 32 ? d(A, g, E) + C[1] : r3 < 48 ? b(A, g, E) + C[2] : r3 < 64 ? l(A, g, E) + C[3] : w(A, g, E) + C[4], M = (M = p(M |= 0, z[r3])) + S | 0, m = S, S = E, E = p(g, 10), g = A, A = M;
                  M = k[1] + O2 + E | 0, k[1] = k[2] + j + S | 0, k[2] = k[3] + _ + m | 0, k[3] = k[4] + o2 + A | 0, k[4] = k[0] + u2 + g | 0, k[0] = M;
                }, t3.prototype.fn = function() {
                  var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                  t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
                  for (var e2 = this.on, o2 = e2.words, u2 = 0; u2 < 5; u2++) {
                    var f2 = o2[u2];
                    o2[u2] = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8);
                  }
                  return e2;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(e.P);
            }, 5187: function(n2, t22, r2) {
              r2.d(t22, { Rabbit: function() {
                return s;
              } });
              var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function() {
                return (c = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 4, r3.S = [], r3.C = [], r3.G = [], r3.hn = [], r3.vn = [], r3.wn = 0, r3.O = t4, r3.A(), r3;
                }
                return f(t3, n3), t3.prototype.A = function() {
                  for (var n4 = this.H.words, t4 = this.ln, r3 = 0; r3 < 4; r3++) n4[r3] = 16711935 & (n4[r3] << 8 | n4[r3] >>> 24) | 4278255360 & (n4[r3] << 24 | n4[r3] >>> 8);
                  var i3 = this.hn = [n4[0], n4[3] << 16 | n4[2] >>> 16, n4[1], n4[0] << 16 | n4[3] >>> 16, n4[2], n4[1] << 16 | n4[0] >>> 16, n4[3], n4[2] << 16 | n4[1] >>> 16], e2 = this.vn = [n4[2] << 16 | n4[2] >>> 16, 4294901760 & n4[0] | 65535 & n4[1], n4[3] << 16 | n4[3] >>> 16, 4294901760 & n4[1] | 65535 & n4[2], n4[0] << 16 | n4[0] >>> 16, 4294901760 & n4[2] | 65535 & n4[3], n4[1] << 16 | n4[1] >>> 16, 4294901760 & n4[3] | 65535 & n4[0]];
                  this.wn = 0;
                  for (r3 = 0; r3 < 4; r3++) this.nextState();
                  for (r3 = 0; r3 < 8; r3++) e2[r3] ^= i3[r3 + 4 & 7];
                  if (t4) {
                    var o2 = t4.words, u2 = o2[0], f2 = o2[1], c2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), s2 = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8), a = c2 >>> 16 | 4294901760 & s2, h = s2 << 16 | 65535 & c2;
                    e2[0] ^= c2, e2[1] ^= a, e2[2] ^= s2, e2[3] ^= h, e2[4] ^= c2, e2[5] ^= a, e2[6] ^= s2, e2[7] ^= h;
                    for (r3 = 0; r3 < 4; r3++) this.nextState();
                  }
                }, t3.prototype.un = function(n4, t4) {
                  var r3 = this.hn;
                  this.nextState(), this.S[0] = r3[0] ^ r3[5] >>> 16 ^ r3[3] << 16, this.S[1] = r3[2] ^ r3[7] >>> 16 ^ r3[5] << 16, this.S[2] = r3[4] ^ r3[1] >>> 16 ^ r3[7] << 16, this.S[3] = r3[6] ^ r3[3] >>> 16 ^ r3[1] << 16;
                  for (var i3 = 0; i3 < 4; i3++) this.S[i3] = 16711935 & (this.S[i3] << 8 | this.S[i3] >>> 24) | 4278255360 & (this.S[i3] << 24 | this.S[i3] >>> 8), n4[t4 + i3] ^= this.S[i3];
                }, t3.prototype.nextState = function() {
                  for (var n4 = this.hn, t4 = this.vn, r3 = 0; r3 < 8; r3++) this.C[r3] = t4[r3];
                  t4[0] = t4[0] + 1295307597 + this.wn | 0, t4[1] = t4[1] + 3545052371 + (t4[0] >>> 0 < this.C[0] >>> 0 ? 1 : 0) | 0, t4[2] = t4[2] + 886263092 + (t4[1] >>> 0 < this.C[1] >>> 0 ? 1 : 0) | 0, t4[3] = t4[3] + 1295307597 + (t4[2] >>> 0 < this.C[2] >>> 0 ? 1 : 0) | 0, t4[4] = t4[4] + 3545052371 + (t4[3] >>> 0 < this.C[3] >>> 0 ? 1 : 0) | 0, t4[5] = t4[5] + 886263092 + (t4[4] >>> 0 < this.C[4] >>> 0 ? 1 : 0) | 0, t4[6] = t4[6] + 1295307597 + (t4[5] >>> 0 < this.C[5] >>> 0 ? 1 : 0) | 0, t4[7] = t4[7] + 3545052371 + (t4[6] >>> 0 < this.C[6] >>> 0 ? 1 : 0) | 0, this.wn = t4[7] >>> 0 < this.C[7] >>> 0 ? 1 : 0;
                  for (r3 = 0; r3 < 8; r3++) {
                    var i3 = n4[r3] + t4[r3], e2 = 65535 & i3, o2 = i3 >>> 16, u2 = ((e2 * e2 >>> 17) + e2 * o2 >>> 15) + o2 * o2, f2 = ((4294901760 & i3) * i3 | 0) + ((65535 & i3) * i3 | 0);
                    this.G[r3] = u2 ^ f2;
                  }
                  var c2 = this.G;
                  n4[0] = c2[0] + (c2[7] << 16 | c2[7] >>> 16) + (c2[6] << 16 | c2[6] >>> 16) | 0, n4[1] = c2[1] + (c2[0] << 8 | c2[0] >>> 24) + c2[7] | 0, n4[2] = c2[2] + (c2[1] << 16 | c2[1] >>> 16) + (c2[0] << 16 | c2[0] >>> 16) | 0, n4[3] = c2[3] + (c2[2] << 8 | c2[2] >>> 24) + c2[1] | 0, n4[4] = c2[4] + (c2[3] << 16 | c2[3] >>> 16) + (c2[2] << 16 | c2[2] >>> 16) | 0, n4[5] = c2[5] + (c2[4] << 8 | c2[4] >>> 24) + c2[3] | 0, n4[6] = c2[6] + (c2[5] << 16 | c2[5] >>> 16) + (c2[4] << 16 | c2[4] >>> 16) | 0, n4[7] = c2[7] + (c2[6] << 8 | c2[6] >>> 24) + c2[5] | 0;
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
                }, t3.encrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
                }, t3.decrypt = function(n4, r3, i3) {
                  return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
                }, t3.ivSize = 4, t3;
              }(e.q);
            }, 3173: function(n2, t22, r2) {
              r2.d(t22, { SHA1: function() {
                return c;
              } });
              var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = [], c = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], c2 = r3[4], s = 0; s < 80; s++) {
                    if (s < 16) f[s] = 0 | n4[t4 + s];
                    else {
                      var a = f[s - 3] ^ f[s - 8] ^ f[s - 14] ^ f[s - 16];
                      f[s] = a << 1 | a >>> 31;
                    }
                    var h = (i3 << 5 | i3 >>> 27) + c2 + f[s];
                    h += s < 20 ? 1518500249 + (e2 & o2 | ~e2 & u2) : s < 40 ? 1859775393 + (e2 ^ o2 ^ u2) : s < 60 ? (e2 & o2 | e2 & u2 | o2 & u2) - 1894007588 : (e2 ^ o2 ^ u2) - 899497514, c2 = u2, u2 = o2, o2 = e2 << 30 | e2 >>> 2, e2 = i3, i3 = h;
                  }
                  r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + c2 | 0;
                }, t3.prototype.fn = function() {
                  var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
                  return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(e.P);
            }, 766: function(n2, t22, r2) {
              r2.d(t22, { SHA224: function() {
                return f;
              } });
              var i2, e = r2(3354), o = r2(5561), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                }, t3.prototype.fn = function() {
                  var t4 = n3.prototype.fn.call(this);
                  return t4.nSigBytes -= 4, t4;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(o.SHA256);
            }, 5561: function(n2, t22, r2) {
              r2.d(t22, { SHA256: function() {
                return v;
              } });
              var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = [], c = [];
              function s(n3) {
                for (var t3 = Math.sqrt(n3), r3 = 2; r3 <= t3; r3++) if (!(n3 % r3)) return false;
                return true;
              }
              function a(n3) {
                return 4294967296 * (n3 - (0 | n3)) | 0;
              }
              !function() {
                for (var n3 = 2, t3 = 0; t3 < 64; ) s(n3) && (t3 < 8 && (f[t3] = a(Math.pow(n3, 0.5))), c[t3] = a(Math.pow(n3, 1 / 3)), t3++), n3++;
              }();
              var h = [], v = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new o.e(f.slice(0)), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new o.e(f.slice(0));
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], f2 = r3[4], s2 = r3[5], a2 = r3[6], v2 = r3[7], w = 0; w < 64; w++) {
                    if (w < 16) h[w] = 0 | n4[t4 + w];
                    else {
                      var l = h[w - 15], b = (l << 25 | l >>> 7) ^ (l << 14 | l >>> 18) ^ l >>> 3, d = h[w - 2], y = (d << 15 | d >>> 17) ^ (d << 13 | d >>> 19) ^ d >>> 10;
                      h[w] = b + h[w - 7] + y + h[w - 16];
                    }
                    var p = i3 & e2 ^ i3 & o2 ^ e2 & o2, O = (i3 << 30 | i3 >>> 2) ^ (i3 << 19 | i3 >>> 13) ^ (i3 << 10 | i3 >>> 22), j = v2 + ((f2 << 26 | f2 >>> 6) ^ (f2 << 21 | f2 >>> 11) ^ (f2 << 7 | f2 >>> 25)) + (f2 & s2 ^ ~f2 & a2) + c[w] + h[w];
                    v2 = a2, a2 = s2, s2 = f2, f2 = u2 + j | 0, u2 = o2, o2 = e2, e2 = i3, i3 = j + (O + p) | 0;
                  }
                  r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + f2 | 0, r3[5] = r3[5] + s2 | 0, r3[6] = r3[6] + a2 | 0, r3[7] = r3[7] + v2 | 0;
                }, t3.prototype.fn = function() {
                  var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
                  return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(e.P);
            }, 3408: function(n2, t22, r2) {
              r2.d(t22, { SHA3: function() {
                return v;
              } });
              var i2, e = r2(6957), o = r2(1868), u = r2(3354), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = [], s = [], a = [];
              !function() {
                for (var n3 = 1, t3 = 0, r3 = 0; r3 < 24; r3++) {
                  c[n3 + 5 * t3] = (r3 + 1) * (r3 + 2) / 2 % 64;
                  var i3 = (2 * n3 + 3 * t3) % 5;
                  n3 = t3 % 5, t3 = i3;
                }
                for (var o2 = 0; o2 < 5; o2++) for (var u2 = 0; u2 < 5; u2++) s[o2 + 5 * u2] = u2 + (2 * o2 + 3 * u2) % 5 * 5;
                for (var f2 = 1, h2 = 0; h2 < 24; h2++) {
                  for (var v2 = 0, w = 0, l = 0; l < 7; l++) {
                    if (1 & f2) {
                      var b = (1 << l) - 1;
                      b < 32 ? w ^= 1 << b : v2 ^= 1 << b - 32;
                    }
                    128 & f2 ? f2 = f2 << 1 ^ 113 : f2 <<= 1;
                  }
                  a[h2] = new e.r(v2, w);
                }
              }();
              var h = [];
              !function() {
                for (var n3 = 0; n3 < 25; n3++) h[n3] = new e.r(0, 0);
              }();
              var v = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  if (r3.N = 32, r3.bn = [], r3.dn = 512, r3.O = t4, t4) {
                    if (void 0 !== t4.outputLength) {
                      if (![224, 256, 384, 512].includes(t4.outputLength)) throw new Error("Unsupported output length.");
                      r3.dn = t4.outputLength;
                    }
                    void 0 !== t4.state && (r3.bn = t4.state.map(function(n4) {
                      return n4.clone();
                    }));
                  }
                  if (0 === r3.bn.length) for (var i3 = 0; i3 < 25; i3++) r3.bn[i3] = new e.r(0, 0);
                  return r3.N = (1600 - 2 * r3.dn) / 32, r3;
                }
                return f(t3, n3), t3.prototype.A = function() {
                  this.bn = [];
                  for (var n4 = 0; n4 < 25; n4++) this.bn[n4] = new e.r(0, 0);
                  this.N = (1600 - 2 * this.dn) / 32;
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = this.bn, i3 = this.N / 2, e2 = 0; e2 < i3; e2++) {
                    var o2 = n4[t4 + 2 * e2], u2 = n4[t4 + 2 * e2 + 1];
                    o2 = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), u2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), r3[e2].high ^= u2, r3[e2].low ^= o2;
                  }
                  for (var f2 = 0; f2 < 24; f2++) {
                    for (var v2 = 0; v2 < 5; v2++) {
                      for (var w = 0, l = 0, b = 0; b < 5; b++) {
                        w ^= (k = r3[v2 + 5 * b]).high, l ^= k.low;
                      }
                      var d = h[v2];
                      d.high = w, d.low = l;
                    }
                    for (v2 = 0; v2 < 5; v2++) {
                      var y = h[(v2 + 4) % 5], p = h[(v2 + 1) % 5], O = p.high, j = p.low;
                      for (w = y.high ^ (O << 1 | j >>> 31), l = y.low ^ (j << 1 | O >>> 31), b = 0; b < 5; b++) {
                        (k = r3[v2 + 5 * b]).high ^= w, k.low ^= l;
                      }
                    }
                    for (var _ = 1; _ < 25; _++) {
                      w = void 0, l = void 0;
                      var m = r3[_].high, A = r3[_].low, g = c[_];
                      g < 32 ? (w = m << g | A >>> 32 - g, l = A << g | m >>> 32 - g) : (w = A << g - 32 | m >>> 64 - g, l = m << g - 32 | A >>> 64 - g);
                      var E = h[s[_]];
                      E.high = w, E.low = l;
                    }
                    var S = h[0], M = r3[0];
                    S.high = M.high, S.low = M.low;
                    for (v2 = 0; v2 < 5; v2++) for (b = 0; b < 5; b++) {
                      var k = r3[_ = v2 + 5 * b], H = h[_], C = h[(v2 + 1) % 5 + 5 * b], B = h[(v2 + 2) % 5 + 5 * b];
                      k.high = H.high ^ ~C.high & B.high, k.low = H.low ^ ~C.low & B.low;
                    }
                    var N = r3[0], I = a[f2];
                    N.high ^= I.high, N.low ^= I.low;
                  }
                }, t3.prototype.fn = function() {
                  var n4 = this.cn, t4 = n4.words, r3 = 8 * n4.nSigBytes, i3 = 32 * this.blockSize;
                  t4[r3 >>> 5] |= 1 << 24 - r3 % 32, t4[(Math.ceil((r3 + 1) / i3) * i3 >>> 5) - 1] |= 128, n4.nSigBytes = 4 * t4.length, this.an();
                  for (var e2 = this.bn, o2 = this.dn / 8, f2 = o2 / 8, c2 = [], s2 = 0; s2 < f2; s2++) {
                    var a2 = e2[s2], h2 = a2.high, v2 = a2.low;
                    h2 = 16711935 & (h2 << 8 | h2 >>> 24) | 4278255360 & (h2 << 24 | h2 >>> 8), v2 = 16711935 & (v2 << 8 | v2 >>> 24) | 4278255360 & (v2 << 24 | v2 >>> 8), c2.push(v2), c2.push(h2);
                  }
                  return new u.e(c2, o2);
                }, t3.prototype.clone = function() {
                  return new t3({ outputLength: this.dn, state: this.bn, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(o.P);
            }, 6324: function(n2, t22, r2) {
              r2.d(t22, { SHA384: function() {
                return f;
              } });
              var i2, e = r2(6957), o = r2(7491), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]);
                }, t3.prototype.fn = function() {
                  var t4 = n3.prototype.fn.call(this);
                  return t4.nSigBytes -= 16, t4;
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(o.SHA512);
            }, 7491: function(n2, t22, r2) {
              r2.d(t22, { SHA512: function() {
                return s;
              } });
              var i2, e = r2(1868), o = r2(6957), u = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), f = [new o.r(1116352408, 3609767458), new o.r(1899447441, 602891725), new o.r(3049323471, 3964484399), new o.r(3921009573, 2173295548), new o.r(961987163, 4081628472), new o.r(1508970993, 3053834265), new o.r(2453635748, 2937671579), new o.r(2870763221, 3664609560), new o.r(3624381080, 2734883394), new o.r(310598401, 1164996542), new o.r(607225278, 1323610764), new o.r(1426881987, 3590304994), new o.r(1925078388, 4068182383), new o.r(2162078206, 991336113), new o.r(2614888103, 633803317), new o.r(3248222580, 3479774868), new o.r(3835390401, 2666613458), new o.r(4022224774, 944711139), new o.r(264347078, 2341262773), new o.r(604807628, 2007800933), new o.r(770255983, 1495990901), new o.r(1249150122, 1856431235), new o.r(1555081692, 3175218132), new o.r(1996064986, 2198950837), new o.r(2554220882, 3999719339), new o.r(2821834349, 766784016), new o.r(2952996808, 2566594879), new o.r(3210313671, 3203337956), new o.r(3336571891, 1034457026), new o.r(3584528711, 2466948901), new o.r(113926993, 3758326383), new o.r(338241895, 168717936), new o.r(666307205, 1188179964), new o.r(773529912, 1546045734), new o.r(1294757372, 1522805485), new o.r(1396182291, 2643833823), new o.r(1695183700, 2343527390), new o.r(1986661051, 1014477480), new o.r(2177026350, 1206759142), new o.r(2456956037, 344077627), new o.r(2730485921, 1290863460), new o.r(2820302411, 3158454273), new o.r(3259730800, 3505952657), new o.r(3345764771, 106217008), new o.r(3516065817, 3606008344), new o.r(3600352804, 1432725776), new o.r(4094571909, 1467031594), new o.r(275423344, 851169720), new o.r(430227734, 3100823752), new o.r(506948616, 1363258195), new o.r(659060556, 3750685593), new o.r(883997877, 3785050280), new o.r(958139571, 3318307427), new o.r(1322822218, 3812723403), new o.r(1537002063, 2003034995), new o.r(1747873779, 3602036899), new o.r(1955562222, 1575990012), new o.r(2024104815, 1125592928), new o.r(2227730452, 2716904306), new o.r(2361852424, 442776044), new o.r(2428436474, 593698344), new o.r(2756734187, 3733110249), new o.r(3204031479, 2999351573), new o.r(3329325298, 3815920427), new o.r(3391569614, 3928383900), new o.r(3515267271, 566280711), new o.r(3940187606, 3454069534), new o.r(4118630271, 4000239992), new o.r(116418474, 1914138554), new o.r(174292421, 2731055270), new o.r(289380356, 3203993006), new o.r(460393269, 320620315), new o.r(685471733, 587496836), new o.r(852142971, 1086792851), new o.r(1017036298, 365543100), new o.r(1126000580, 2618297676), new o.r(1288033470, 3409855158), new o.r(1501505948, 4234509866), new o.r(1607167915, 987167468), new o.r(1816402316, 1246189591)], c = [];
              !function() {
                for (var n3 = 0; n3 < 80; n3++) c[n3] = new o.r(0, 0);
              }();
              var s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 32, r3.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
                }
                return u(t3, n3), t3.prototype.A = function() {
                  this.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]);
                }, t3.prototype.un = function(n4, t4) {
                  for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], s2 = r3[4], a = r3[5], h = r3[6], v = r3[7], w = i3.high, l = i3.low, b = e2.high, d = e2.low, y = o2.high, p = o2.low, O = u2.high, j = u2.low, _ = s2.high, m = s2.low, A = a.high, g = a.low, E = h.high, S = h.low, M = v.high, k = v.low, H = w, C = l, B = b, N = d, I = y, z = p, D = O, U = j, L = _, F = m, x = A, P = g, R = E, T = S, K = M, W = k, G = 0; G < 80; G++) {
                    var q = void 0, Q = void 0, X = c[G];
                    if (G < 16) Q = X.high = 0 | n4[t4 + 2 * G], q = X.low = 0 | n4[t4 + 2 * G + 1];
                    else {
                      var V = c[G - 15], Z = V.high, J = V.low, Y = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7, $ = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25), nn = c[G - 2], tn = nn.high, rn = nn.low, en2 = (tn >>> 19 | rn << 13) ^ (tn << 3 | rn >>> 29) ^ tn >>> 6, on = (rn >>> 19 | tn << 13) ^ (rn << 3 | tn >>> 29) ^ (rn >>> 6 | tn << 26), un = c[G - 7], fn = un.high, cn = un.low, sn = c[G - 16], an = sn.high, hn = sn.low;
                      Q = (Q = (Q = Y + fn + ((q = $ + cn) >>> 0 < $ >>> 0 ? 1 : 0)) + en2 + ((q += on) >>> 0 < on >>> 0 ? 1 : 0)) + an + ((q += hn) >>> 0 < hn >>> 0 ? 1 : 0), X.high = Q, X.low = q;
                    }
                    var vn = L & x ^ ~L & R, wn = F & P ^ ~F & T, ln = H & B ^ H & I ^ B & I, bn = C & N ^ C & z ^ N & z, dn = (H >>> 28 | C << 4) ^ (H << 30 | C >>> 2) ^ (H << 25 | C >>> 7), yn = (C >>> 28 | H << 4) ^ (C << 30 | H >>> 2) ^ (C << 25 | H >>> 7), pn = (L >>> 14 | F << 18) ^ (L >>> 18 | F << 14) ^ (L << 23 | F >>> 9), On = (F >>> 14 | L << 18) ^ (F >>> 18 | L << 14) ^ (F << 23 | L >>> 9), jn = f[G], _n = jn.high, mn = jn.low, An = W + On, gn = K + pn + (An >>> 0 < W >>> 0 ? 1 : 0), En = yn + bn;
                    K = R, W = T, R = x, T = P, x = L, P = F, L = D + (gn = (gn = (gn = gn + vn + ((An += wn) >>> 0 < wn >>> 0 ? 1 : 0)) + _n + ((An += mn) >>> 0 < mn >>> 0 ? 1 : 0)) + Q + ((An += q) >>> 0 < q >>> 0 ? 1 : 0)) + ((F = U + An | 0) >>> 0 < U >>> 0 ? 1 : 0) | 0, D = I, U = z, I = B, z = N, B = H, N = C, H = gn + (dn + ln + (En >>> 0 < yn >>> 0 ? 1 : 0)) + ((C = An + En | 0) >>> 0 < An >>> 0 ? 1 : 0) | 0;
                  }
                  l = i3.low = l + C, i3.high = w + H + (l >>> 0 < C >>> 0 ? 1 : 0), d = e2.low = d + N, e2.high = b + B + (d >>> 0 < N >>> 0 ? 1 : 0), p = o2.low = p + z, o2.high = y + I + (p >>> 0 < z >>> 0 ? 1 : 0), j = u2.low = j + U, u2.high = O + D + (j >>> 0 < U >>> 0 ? 1 : 0), m = s2.low = m + F, s2.high = _ + L + (m >>> 0 < F >>> 0 ? 1 : 0), g = a.low = g + P, a.high = A + x + (g >>> 0 < P >>> 0 ? 1 : 0), S = h.low = S + T, h.high = E + R + (S >>> 0 < T >>> 0 ? 1 : 0), k = v.low = k + W, v.high = M + K + (k >>> 0 < W >>> 0 ? 1 : 0);
                }, t3.prototype.fn = function() {
                  var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                  return t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[30 + (i3 + 128 >>> 10 << 5)] = Math.floor(r3 / 4294967296), t4[31 + (i3 + 128 >>> 10 << 5)] = r3, n4.nSigBytes = 4 * t4.length, this.an(), this.on.to32();
                }, t3.prototype.clone = function() {
                  return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
                }, t3.hash = function(n4, r3) {
                  return new t3(r3).finalize(n4);
                }, t3;
              }(e.P);
            }, 3354: function(n2, t22, r2) {
              r2.d(t22, { e: function() {
                return o;
              } });
              var i2 = r2(5720), e = r2(9054), o = function() {
                function n3(t3, r3) {
                  if (Array.isArray(t3) || !t3) return this.yn = Array.isArray(t3) ? t3 : [], void (this.pn = "number" == typeof r3 ? r3 : 4 * this.yn.length);
                  if (t3 instanceof n3) return this.yn = t3.words.slice(), void (this.pn = t3.nSigBytes);
                  var i3;
                  try {
                    t3 instanceof ArrayBuffer ? i3 = new Uint8Array(t3) : (t3 instanceof Uint8Array || t3 instanceof Int8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array) && (i3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
                  } catch (n4) {
                    throw new Error("Invalid argument");
                  }
                  if (!i3) throw new Error("Invalid argument");
                  for (var e2 = i3.byteLength, o2 = [], u = 0; u < e2; u++) o2[u >>> 2] |= i3[u] << 24 - u % 4 * 8;
                  this.yn = o2, this.pn = e2;
                }
                return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
                  return this.pn;
                }, set: function(n4) {
                  this.pn = n4;
                }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
                  return this.yn;
                }, enumerable: false, configurable: true }), n3.prototype.toString = function(n4) {
                  return n4 ? n4.stringify(this) : i2.p.stringify(this);
                }, n3.prototype.toUint8Array = function() {
                  for (var n4 = this.yn, t3 = this.pn, r3 = new Uint8Array(t3), i3 = 0; i3 < t3; i3++) r3[i3] = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                  return r3;
                }, n3.prototype.concat = function(n4) {
                  var t3 = n4.words.slice(), r3 = n4.nSigBytes;
                  if (this.clamp(), this.pn % 4) for (var i3 = 0; i3 < r3; i3++) {
                    var e2 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                    this.yn[this.pn + i3 >>> 2] |= e2 << 24 - (this.pn + i3) % 4 * 8;
                  }
                  else for (i3 = 0; i3 < r3; i3 += 4) this.yn[this.pn + i3 >>> 2] = t3[i3 >>> 2];
                  return this.pn += r3, this;
                }, n3.prototype.clamp = function() {
                  var n4 = this.pn;
                  this.yn[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, this.yn.length = Math.ceil(n4 / 4);
                }, n3.prototype.clone = function() {
                  return new n3(this.yn.slice(), this.pn);
                }, n3.random = function(t3) {
                  for (var r3 = [], i3 = 0; i3 < t3; i3 += 4) r3.push((0, e.M)());
                  return new n3(r3, t3);
                }, n3;
              }();
            }, 6957: function(n2, t22, r2) {
              r2.d(t22, { r: function() {
                return o;
              }, m: function() {
                return u;
              } });
              var i2 = r2(5720), e = r2(3354), o = function() {
                function n3(n4, t3) {
                  this.high = n4, this.low = t3;
                }
                return n3.prototype.clone = function() {
                  return new n3(this.high, this.low);
                }, n3;
              }(), u = function() {
                function n3(n4, t3) {
                  this.yn = n4 || [], this.pn = "number" == typeof t3 ? t3 : 8 * this.yn.length;
                }
                return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
                  return this.pn;
                }, set: function(n4) {
                  this.pn = n4;
                }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
                  return this.yn;
                }, enumerable: false, configurable: true }), n3.prototype.to32 = function() {
                  for (var n4 = [], t3 = 0; t3 < this.yn.length; t3++) {
                    var r3 = this.yn[t3];
                    n4.push(r3.high), n4.push(r3.low);
                  }
                  return new e.e(n4, this.pn);
                }, n3.prototype.toString = function(n4) {
                  return n4 ? n4.stringify(this.to32()) : i2.p.stringify(this.to32());
                }, n3.prototype.clone = function() {
                  for (var t3 = this.yn.slice(), r3 = 0; r3 < t3.length; r3++) t3[r3] = t3[r3].clone();
                  return new n3(t3, this.pn);
                }, n3;
              }();
            }, 7211: function(n2, t22, r2) {
              r2.d(t22, { C: function() {
                return o;
              } });
              var i2 = r2(3354), e = r2(4768), o = function() {
                function n3(n4) {
                  this.On = 0, this.N = 0, this.O = n4, this.cn = n4 && void 0 !== n4.data ? n4.data.clone() : new i2.e(), this.sn = n4 && "number" == typeof n4.nBytes ? n4.nBytes : 0;
                }
                return Object.defineProperty(n3.prototype, "blockSize", { get: function() {
                  return this.N;
                }, enumerable: false, configurable: true }), n3.prototype.reset = function(n4, t3) {
                  this.cn = void 0 !== n4 ? n4.clone() : new i2.e(), this.sn = "number" == typeof t3 ? t3 : 0;
                }, n3.prototype.jn = function(n4) {
                  var t3 = "string" == typeof n4 ? e.d.parse(n4) : n4;
                  this.cn.concat(t3), this.sn += t3.nSigBytes;
                }, n3.prototype.an = function(n4) {
                  var t3, r3 = this.cn.words, e2 = this.cn.nSigBytes, o2 = this.N, u = e2 / (4 * this.N), f = (u = n4 ? Math.ceil(u) : Math.max((0 | u) - this.On, 0)) * o2, c = Math.min(4 * f, e2);
                  if (f) {
                    for (var s = 0; s < f; s += o2) this.un(r3, s);
                    t3 = r3.splice(0, f), this.cn.nSigBytes -= c;
                  }
                  return new i2.e(t3, c);
                }, n3.prototype.un = function(n4, t3) {
                  throw new Error("Not implemented");
                }, n3;
              }();
            }, 1868: function(n2, t22, r2) {
              r2.d(t22, { P: function() {
                return u;
              } });
              var i2, e = r2(7211), o = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), u = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 16, r3.O = t4, t4 && "number" == typeof t4.blockSize && (r3.N = t4.blockSize), r3.reset(t4 ? t4.data : void 0, t4 ? t4.nBytes : void 0), r3;
                }
                return o(t3, n3), Object.defineProperty(t3.prototype, "blockSize", { get: function() {
                  return this.N;
                }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                  n3.prototype.reset.call(this, t4, r3), this.A();
                }, t3.prototype.update = function(n4) {
                  return this.jn(n4), this.an(), this;
                }, t3.prototype.finalize = function(n4) {
                  return n4 && this.jn(n4), this.fn();
                }, t3.prototype.A = function() {
                  throw new Error("Not implemented");
                }, t3.prototype.fn = function() {
                  throw new Error("Not implemented");
                }, t3;
              }(e.C);
            }, 787: function(n2, t22, r2) {
              r2.d(t22, { G: function() {
                return s;
              } });
              var i2, e = r2(9456), o = r2(4344), u = r2(7919), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function() {
                return (c = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 4, r3._n = o.n, r3.mn = u.l, r3.O = t4, r3._n = void 0 !== t4.mode ? t4.mode : r3._n, r3.mn = void 0 !== t4.padding ? t4.padding : r3.mn, r3.reset(null == t4 ? void 0 : t4.data, null == t4 ? void 0 : t4.nBytes), r3;
                }
                return f(t3, n3), Object.defineProperty(t3.prototype, "mode", { get: function() {
                  return this.An;
                }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "padding", { get: function() {
                  return this.mn;
                }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                  var i3;
                  n3.prototype.reset.call(this, t4, r3), this.gn === e.t.ENC_TRANSFORM_MODE ? i3 = this._n.createEncryptor : (i3 = this._n.createDecryptor, this.On = 1), this._n && this.En === i3 ? this.An = new this._n({ cipher: this, iv: this.ln }) : (this.An = i3.call(this._n, { cipher: this, iv: this.ln }), this.En = i3);
                }, t3.prototype.un = function(n4, t4) {
                  var r3;
                  null === (r3 = this.An) || void 0 === r3 || r3.processBlock(n4, t4);
                }, t3.prototype.fn = function() {
                  var n4, t4 = this.mn;
                  return this.gn === e.t.ENC_TRANSFORM_MODE ? (t4.pad(this.cn, this.blockSize), n4 = this.an(true)) : (n4 = this.an(true), t4.unpad(n4)), n4;
                }, t3.prototype.encryptBlock = function(n4, t4) {
                  throw new Error("Not implemented");
                }, t3.prototype.decryptBlock = function(n4, t4) {
                  throw new Error("Not implemented");
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
                }, t3;
              }(e.t);
            }, 9456: function(n2, t22, r2) {
              r2.d(t22, { t: function() {
                return f;
              } });
              var i2, e = r2(7211), o = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), u = function() {
                return (u = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, f = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.gn = 1, r3.O = t4, r3.H = t4.key, r3.ln = void 0 !== t4.iv ? t4.iv : r3.ln, r3.gn = void 0 !== t4.transformMode ? t4.transformMode : r3.gn, r3;
                }
                return o(t3, n3), Object.defineProperty(t3.prototype, "iv", { get: function() {
                  return this.ln;
                }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                  n3.prototype.reset.call(this, t4, r3), this.A();
                }, t3.prototype.process = function(n4) {
                  return this.jn(n4), this.an();
                }, t3.prototype.finalize = function(n4) {
                  return n4 && this.jn(n4), this.fn();
                }, t3.prototype.A = function() {
                  throw new Error("Not implemented");
                }, t3.prototype.un = function(n4, t4) {
                  throw new Error("Not implemented");
                }, t3.prototype.fn = function() {
                  throw new Error("Not implemented");
                }, t3.createEncryptor = function(n4, r3) {
                  return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.ENC_TRANSFORM_MODE }));
                }, t3.createDecryptor = function(n4, r3) {
                  return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.DEC_TRANSFORM_MODE }));
                }, t3.ENC_TRANSFORM_MODE = 1, t3.DEC_TRANSFORM_MODE = 2, t3.keySize = 4, t3.ivSize = 4, t3;
              }(e.C);
            }, 2505: function(n2, t22, r2) {
              r2.d(t22, { Q: function() {
                return e;
              } });
              var i2 = r2(1232), e = function() {
                function n3(n4) {
                  this.formatter = i2.w, n4 && (this.cipherText = n4.cipherText, this.key = n4.key, this.iv = n4.iv, this.salt = n4.salt, this.Algorithm = n4.Algorithm, this.mode = n4.mode, this.padding = n4.padding, this.blockSize = n4.blockSize, this.formatter = n4.formatter || i2.w);
                }
                return n3.prototype.toString = function(n4) {
                  return (n4 || this.formatter).stringify(this);
                }, n3;
              }();
            }, 5693: function(n2, t22, r2) {
              r2.d(t22, { E: function() {
                return c;
              } });
              var i2 = r2(9109), e = r2(2214), o = r2(2505), u = r2(1232), f = function() {
                return (f = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, c = { encrypt: function(n3, t3, r3, u2) {
                var c2 = u2 ? f({}, u2) : {}, s = u2 && u2.KDF ? u2.KDF : e.s, a = {};
                u2 && u2.kdfHasher && (a.kdfHasher = u2.kdfHasher), u2 && u2.kdfIterations && (a.kdfIterations = u2.kdfIterations), u2 && u2.kdfModule && (a.kdfModule = u2.kdfModule);
                var h = s.execute(r3, n3.keySize, n3.ivSize, c2.kdfSalt, a);
                c2.iv = h.iv;
                var v = i2.D.encrypt(n3, t3, h.key, c2);
                return new o.Q(f(f({}, v), { key: h.key, iv: h.iv, salt: h.salt }));
              }, decrypt: function(n3, t3, r3, o2) {
                var c2 = o2 ? f({}, o2) : {}, s = c2.KDF ? c2.KDF : e.s, a = c2.formatter ? c2.formatter : u.w, h = (0, i2.W)(t3, a), v = {};
                o2 && o2.kdfHasher && (v.kdfHasher = o2.kdfHasher), o2 && o2.kdfIterations && (v.kdfIterations = o2.kdfIterations), o2 && o2.kdfModule && (v.kdfModule = o2.kdfModule);
                var w = s.execute(r3, n3.keySize, n3.ivSize, h.salt, v);
                return c2.iv = w.iv, i2.D.decrypt(n3, h, w.key, c2);
              } };
            }, 9109: function(n2, t22, r2) {
              r2.d(t22, { W: function() {
                return o;
              }, D: function() {
                return u;
              } });
              var i2 = r2(1232), e = r2(2505);
              function o(n3, t3) {
                return "string" == typeof n3 ? t3.parse(n3) : n3;
              }
              var u = { encrypt: function(n3, t3, r3, o2) {
                var u2 = n3.createEncryptor(r3, o2), f = u2.finalize(t3);
                return new e.Q({ cipherText: f, key: r3, iv: u2.iv, Algorithm: n3, mode: u2.mode, padding: u2.padding, blockSize: u2.blockSize, formatter: (null == o2 ? void 0 : o2.formatter) || i2.w });
              }, decrypt: function(n3, t3, r3, e2) {
                var u2 = n3.createDecryptor(r3, e2), f = o(t3, (null == e2 ? void 0 : e2.formatter) || i2.w);
                return u2.finalize(f.cipherText || "");
              } };
            }, 30: function(n2, t22, r2) {
              r2.d(t22, { q: function() {
                return u;
              } });
              var i2, e = r2(9456), o = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), u = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.N = 1, r3;
                }
                return o(t3, n3), t3.prototype.fn = function() {
                  return this.an(true);
                }, t3;
              }(e.t);
            }, 1232: function(n2, t22, r2) {
              r2.d(t22, { w: function() {
                return u;
              } });
              var i2 = r2(2505), e = r2(3354), o = r2(1773), u = { stringify: function(n3) {
                var t3 = n3.cipherText, r3 = n3.salt;
                return t3 ? r3 ? new e.e([1398893684, 1701076831]).concat(r3).concat(t3).toString(o.D) : t3.toString(o.D) : "";
              }, parse: function(n3) {
                var t3, r3 = o.D.parse(n3), u2 = r3.words;
                return 1398893684 === u2[0] && 1701076831 === u2[1] && (t3 = new e.e(u2.slice(2, 4)), u2.splice(0, 4), r3.nSigBytes -= 16), new i2.Q({ cipherText: r3, salt: t3 });
              } };
            }, 2214: function(n2, t22, r2) {
              r2.d(t22, { s: function() {
                return f;
              } });
              var i2 = r2(3354), e = r2(2505), o = r2(7008), u = function() {
                return (u = Object.assign || function(n3) {
                  for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                  return n3;
                }).apply(this, arguments);
              }, f = { execute: function(n3, t3, r3, f2, c) {
                f2 || (f2 = i2.e.random(8));
                var s = c && c.kdfModule || o.E, a = c ? { Hasher: c.kdfHasher, iterations: c.kdfIterations } : {}, h = s.getKey(n3, f2, u(u({}, a), { keySize: t3 + r3 })), v = new i2.e(h.words.slice(t3), 4 * r3);
                return h.nSigBytes = 4 * t3, new e.Q({ key: h, iv: v, salt: f2 });
              } };
            }, 7008: function(n2, t22, r2) {
              r2.d(t22, { E: function() {
                return s;
              } });
              var i2, e = r2(5561), o = r2(6367), u = r2(3354), f = r2(9541), c = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), s = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.Sn = 4, r3.Mn = e.SHA256, r3.kn = 1e4, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
                }
                return c(t3, n3), t3.prototype.compute = function(n4, t4) {
                  for (var r3 = new o.Hmac(new this.Mn(), n4), i3 = new u.e(), e2 = new u.e([1]), f2 = i3.words, c2 = e2.words, s2 = this.Sn, a = this.kn; f2.length < s2; ) {
                    var h = r3.update(t4).finalize(e2);
                    r3.reset();
                    for (var v = h.words, w = v.length, l = h, b = 1; b < a; b++) {
                      l = r3.finalize(l), r3.reset();
                      for (var d = l.words, y = 0; y < w; y++) v[y] ^= d[y];
                    }
                    i3.concat(h), c2[0]++;
                  }
                  return i3.nSigBytes = 4 * s2, i3;
                }, t3.getKey = function(n4, r3, i3) {
                  return new t3(i3).compute(n4, r3);
                }, t3;
              }(f._);
            }, 9541: function(n2, t22, r2) {
              r2.d(t22, { _: function() {
                return i2;
              } });
              var i2 = function() {
                function n3(n4) {
                  this.O = n4;
                }
                return n3.prototype.compute = function(n4, t3) {
                  throw new Error("Not implemented");
                }, n3.getKey = function(n4, t3, r3) {
                  throw new Error("Not implemented");
                }, n3;
              }();
            }, 1863: function(n2, t22, r2) {
              r2.d(t22, { T: function() {
                return i2;
              } });
              var i2 = function() {
                function n3(n4) {
                  this.O = n4, this.Hn = n4.cipher, this.ln = n4.iv;
                }
                return n3.prototype.processBlock = function(n4, t3) {
                }, n3.createEncryptor = function(n4) {
                  throw new Error("Not implemented yet");
                }, n3.createDecryptor = function(n4) {
                  throw new Error("Not implemented yet");
                }, n3;
              }();
            }, 4344: function(n2, t22, r2) {
              r2.d(t22, { n: function() {
                return u;
              } });
              var i2, e = r2(1863), o = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), u = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.Cn = [], r3;
                }
                return o(t3, n3), t3.prototype.xorBlock = function(n4, t4, r3) {
                  var i3, e2 = this.ln;
                  e2 ? (i3 = e2.words, this.ln = void 0) : i3 = this.Cn;
                  for (var o2 = 0; o2 < r3; o2++) n4[t4 + o2] ^= i3[o2];
                }, t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    var r3 = this.Hn, i3 = r3.blockSize;
                    this.xorBlock(n5, t5, i3), r3.encryptBlock(n5, t5), this.Cn = n5.slice(t5, t5 + i3);
                  }, t4;
                }(t3), t3.Decryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    var r3 = this.Hn, i3 = r3.blockSize, e2 = n5.slice(t5, t5 + i3);
                    r3.decryptBlock(n5, t5), this.xorBlock(n5, t5, i3), this.Cn = e2;
                  }, t4;
                }(t3), t3;
              }(e.T);
            }, 4055: function(n2, t22, r2) {
              r2.d(t22, { I4: function() {
                return e;
              }, z6: function() {
                return o;
              }, ur: function() {
                return u;
              } });
              var i2 = r2(3354);
              function e(n3) {
                var t3 = n3.nSigBytes % 16;
                if (0 !== t3) {
                  for (var r3 = 16 - t3, e2 = [], o2 = Math.floor(r3 / 4), u2 = 0; u2 < o2; u2++) e2.push(0);
                  r3 % 4 > 0 && e2.push(0), n3.concat(new i2.e(e2, r3));
                }
              }
              function o(n3, t3) {
                return new i2.e(n3.words.slice(), t3);
              }
              function u(n3, t3) {
                for (var r3 = n3.nSigBytes - t3, e2 = [], o2 = 0; o2 < t3; o2++) {
                  var u2 = o2 >>> 2, f = r3 + o2, c = f >>> 2, s = n3.words[c] >>> 24 - f % 4 * 8 & 255;
                  e2[u2] = 0 | e2[u2] | s << 24 - o2 % 4 * 8;
                }
                var a = new i2.e(e2, t3);
                return a.clamp(), a;
              }
            }, 7919: function(n2, t22, r2) {
              r2.d(t22, { l: function() {
                return e;
              } });
              var i2 = r2(3354);
              var e = { pad: function(n3, t3) {
                for (var r3 = 4 * t3, e2 = r3 - n3.nSigBytes % r3, o = e2 << 24 | e2 << 16 | e2 << 8 | e2, u = [], f = 0; f < e2; f += 4) u.push(o);
                var c = new i2.e(u, e2);
                n3.concat(c);
              }, unpad: function(n3) {
                var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
                n3.nSigBytes -= t3;
              } };
            }, 1756: function(n2, t22, r2) {
              r2.d(t22, { w: function() {
                return u;
              } });
              var i2, e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", o = (i2 = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(i2) ? (i2 = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(i2) && i2) : i2);
              function u(n3, t3) {
                return false !== o && (!t3 || ("<" === n3 ? o < t3 : "<=" === n3 ? o <= t3 : ">" === n3 ? o > t3 : ">=" === n3 ? o >= t3 : o === t3));
              }
            }, 1773: function(n2, t22, r2) {
              r2.d(t22, { D: function() {
                return f;
              } });
              for (var i2 = r2(3354), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = [], u = 0; u < e.length; u++) o[e.charCodeAt(u)] = u;
              var f = { stringify: function(n3) {
                var t3 = n3.words, r3 = n3.nSigBytes;
                n3.clamp();
                for (var i3 = [], o2 = 0; o2 < r3; o2 += 3) for (var u2 = (t3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (t3[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | t3[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, f2 = 0; f2 < 4 && o2 + 0.75 * f2 < r3; f2++) i3.push(e.charAt(u2 >>> 6 * (3 - f2) & 63));
                var c = e.charAt(64);
                if (c) for (; i3.length % 4; ) i3.push(c);
                return i3.join("");
              }, parse: function(n3) {
                var t3 = n3.length, r3 = e.charAt(64);
                if (r3) {
                  var u2 = n3.indexOf(r3);
                  -1 !== u2 && (t3 = u2);
                }
                for (var f2 = [], c = 0, s = 0; s < t3; s++) if (s % 4) {
                  var a = o[n3.charCodeAt(s - 1)] << s % 4 * 2 | o[n3.charCodeAt(s)] >>> 6 - s % 4 * 2;
                  f2[c >>> 2] |= a << 24 - c % 4 * 8, c++;
                }
                return new i2.e(f2, c);
              } };
            }, 5720: function(n2, t22, r2) {
              r2.d(t22, { p: function() {
                return e;
              } });
              var i2 = r2(3354), e = { stringify: function(n3) {
                for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
                  var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
                  i3.push((o >>> 4).toString(16)), i3.push((15 & o).toString(16));
                }
                return i3.join("");
              }, parse: function(n3) {
                var t3 = n3.length;
                if (t3 % 2 != 0) throw new Error("Hex string count must be even");
                if (!/^[a-fA-F0-9]+$/.test(n3)) throw new Error("Invalid Hex string: " + n3);
                for (var r3 = [], e2 = 0; e2 < t3; e2 += 2) r3[e2 >>> 3] |= parseInt(n3.substr(e2, 2), 16) << 24 - e2 % 8 * 4;
                return new i2.e(r3, t3 / 2);
              } };
            }, 8702: function(n2, t22, r2) {
              r2.d(t22, { m: function() {
                return e;
              } });
              var i2 = r2(3354), e = { stringify: function(n3) {
                for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
                  var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
                  i3.push(String.fromCharCode(o));
                }
                return i3.join("");
              }, parse: function(n3) {
                for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 2] |= (255 & n3.charCodeAt(e2)) << 24 - e2 % 4 * 8;
                return new i2.e(r3, t3);
              } };
            }, 4768: function(n2, t22, r2) {
              r2.d(t22, { d: function() {
                return e;
              } });
              var i2 = r2(8702), e = { stringify: function(n3) {
                try {
                  return decodeURIComponent(escape(i2.m.stringify(n3)));
                } catch (n4) {
                  throw new Error("Malformed UTF-8 data");
                }
              }, parse: function(n3) {
                return i2.m.parse(unescape(encodeURIComponent(n3)));
              } };
            }, 2688: function(n2, t22, r2) {
              r2.d(t22, { Base64: function() {
                return o.D;
              }, EvpKDF: function() {
                return O;
              }, Hex: function() {
                return c.p;
              }, Latin1: function() {
                return f.m;
              }, OpenSSLKDF: function() {
                return l.s;
              }, PBKDF2: function() {
                return b.E;
              }, Utf16: function() {
                return w;
              }, Utf16BE: function() {
                return s;
              }, Utf16LE: function() {
                return v;
              }, Utf8: function() {
                return u.d;
              }, Word32Array: function() {
                return i2.e;
              }, Word64: function() {
                return e.r;
              }, Word64Array: function() {
                return e.m;
              } });
              r2(9054);
              var i2 = r2(3354), e = r2(6957), o = (r2(1756), r2(1773)), u = r2(4768), f = r2(8702), c = r2(5720), s = { stringify: function(n3) {
                for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
                  var o2 = t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535;
                  i3.push(String.fromCharCode(o2));
                }
                return i3.join("");
              }, parse: function(n3) {
                for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= n3.charCodeAt(e2) << 16 - e2 % 2 * 16;
                return new i2.e(r3, 2 * t3);
              } };
              function a(n3) {
                return n3 << 8 & 4278255360 | n3 >>> 8 & 16711935;
              }
              var h, v = { stringify: function(n3) {
                for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
                  var o2 = a(t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535);
                  i3.push(String.fromCharCode(o2));
                }
                return i3.join("");
              }, parse: function(n3) {
                for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= a(n3.charCodeAt(e2) << 16 - e2 % 2 * 16);
                return new i2.e(r3, 2 * t3);
              } }, w = s, l = r2(2214), b = r2(7008), d = r2(670), y = r2(9541), p = (h = function(n3, t3) {
                return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                h(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), O = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  return r3.Sn = 4, r3.Mn = d.MD5, r3.kn = 1, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
                }
                return p(t3, n3), t3.prototype.compute = function(n4, t4) {
                  for (var r3, e2 = new this.Mn(), o2 = new i2.e(), u2 = o2.words, f2 = this.Sn, c2 = this.kn; u2.length < f2; ) {
                    r3 && e2.update(r3), r3 = e2.update(n4).finalize(t4), e2.reset();
                    for (var s2 = 1; s2 < c2; s2++) r3 = e2.finalize(r3), e2.reset();
                    o2.concat(r3);
                  }
                  return o2.nSigBytes = 4 * f2, o2;
                }, t3.getKey = function(n4, r3, i3) {
                  return new t3(i3).compute(n4, r3);
                }, t3;
              }(y._);
            }, 9054: function(n2, t22, r2) {
              r2.d(t22, { M: function() {
                return e;
              } });
              var i2 = r2(1756);
              var e = function() {
                if ("undefined" != typeof window) {
                  var n3 = window.crypto || window.msCrypto;
                  if (!n3) {
                    if ((0, i2.w)("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function() {
                      return Math.floor(512 * Math.random()) % 256;
                    };
                    throw new Error("Crypto module not found");
                  }
                  return function() {
                    return n3.getRandomValues(new Uint32Array(1))[0];
                  };
                }
                return void 0 !== r2.g && r2.g.crypto ? function() {
                  return r2.g.crypto.randomBytes(4).readInt32LE();
                } : function() {
                  return require("crypto").randomBytes(4).readInt32LE();
                };
              }();
            }, 3664: function(n2, t22, r2) {
              r2.d(t22, { K: function() {
                return c;
              } });
              var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function(n3) {
                function t3(t4) {
                  var r3 = n3.call(this, t4) || this;
                  r3.Bn = 1;
                  var i3 = t4.cipher, e2 = t4.iv;
                  if (4 !== i3.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
                  if (e2 && (e2.nSigBytes > 13 || e2.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
                  return r3.Nn = e2 || new o.e([0, 0], 8), r3.In = 15 - r3.Nn.nSigBytes, r3;
                }
                return f(t3, n3), t3.getB0 = function(n4, t4, r3, i3) {
                  if (r3.nSigBytes + i3.nSigBytes !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
                  var e2 = 255 & (0 | (n4 ? 1 : 0) << 6 | (t4 - 2) / 2 << 3 | r3.nSigBytes - 1), u2 = i3.clone().concat(r3);
                  return new o.e([e2 << 24], 1).concat(u2);
                }, t3.formatAssociatedDataAndPayload = function(n4, t4) {
                  var r3, i3 = n4.nSigBytes;
                  if (0 === i3) r3 = new o.e([0], 0);
                  else if (i3 < Math.pow(2, 16) - Math.pow(2, 8)) r3 = new o.e([i3 << 16], 2);
                  else {
                    if (!(i3 < Math.pow(2, 32))) throw new Error("LEN(A) larger than 2**32-1 is not supported");
                    r3 = new o.e([4294836224], 2).concat(new o.e([i3], 4));
                  }
                  for (var e2 = Math.floor(n4.nSigBytes / 4), u2 = 0; u2 < e2; u2++) r3.concat(new o.e([n4.words[u2]], 4));
                  n4.nSigBytes % 4 && (r3.concat(new o.e([n4.words[e2]], n4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - n4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16));
                  var f2 = Math.floor(t4.nSigBytes / 4);
                  for (u2 = 0; u2 < f2; u2++) r3.concat(new o.e([t4.words[u2]], 4));
                  return t4.nSigBytes % 4 && (r3.concat(new o.e([t4.words[f2]], t4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - t4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16)), r3;
                }, t3.genCtr = function(n4, t4, r3) {
                  if (t4.nSigBytes + n4 !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
                  for (var i3 = new o.e([(n4 - 1 & 7) << 24], 1), e2 = new o.e([], 0), u2 = Math.floor(n4 / 4), f2 = 0; f2 < u2 - 1; f2++) e2.concat(new o.e([0], 4));
                  return n4 % 4 ? n4 > 4 ? (e2.concat(new o.e([0], n4 % 4)), e2.concat(new o.e([r3], 4))) : e2.concat(new o.e([r3 << 32 - 8 * n4], n4)) : e2.concat(new o.e([r3], 4)), i3.concat(t4).concat(e2);
                }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
                  var s = new n4({ key: r3, iv: i3 });
                  if (4 !== s.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
                  if (i3 && (i3.nSigBytes > 13 || i3.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
                  var a = i3 || new o.e([0, 0], 8), h = (null == e2 ? void 0 : e2.clone()) || new o.e(), v = h.nSigBytes, w = (null == f2 ? void 0 : f2.clone()) || new o.e(), l = w.nSigBytes;
                  if (l >>> 0 > 4294967295) throw new Error("Byte length of Payload(plainText) larger than 2^32-1 (4,294,967,295byte) is not supported at this time.");
                  var b = 15 - a.nSigBytes, d = (0, u.ur)(new o.e([0, l], 8), b), y = c2 || 16, p = t3.getB0(Boolean(v), y, d, a), O = t3.formatAssociatedDataAndPayload(h, w), j = p.words.slice();
                  s.encryptBlock(j, 0);
                  for (var _ = O.nSigBytes / 16, m = O.words, A = j, g = 0; g < _; g++) {
                    var E = [m[4 * g] ^ A[0], m[4 * g + 1] ^ A[1], m[4 * g + 2] ^ A[2], m[4 * g + 3] ^ A[3]];
                    s.encryptBlock(E, 0), A = E;
                  }
                  var S = new o.e(A, y), M = t3.genCtr(b, a, 0);
                  s.encryptBlock(M.words, 0);
                  for (g = 0; g < 4; g++) S.words[g] ^= M.words[g];
                  return S.clamp(), S;
                }, t3.combineCipherTextAndAuthTag = function(n4, t4) {
                  return n4.clone().concat(t4);
                }, t3.splitCipherTextAndAuthTag = function(n4, t4) {
                  var r3 = t4 || 16;
                  return { cipherText: (0, u.z6)(n4, n4.nSigBytes - r3), authTag: (0, u.ur)(n4, r3) };
                }, t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function r3() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                    var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                    i3.encryptBlock(o2.words, 0);
                    for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                    this.Bn++;
                  }, r3;
                }(t3), t3.Decryptor = function(n4) {
                  function r3() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                    var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                    i3.encryptBlock(o2.words, 0);
                    for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                    this.Bn++;
                  }, r3;
                }(t3), t3;
              }(e.T);
            }, 5607: function(n2, t22, r2) {
              r2.d(t22, { V: function() {
                return c;
              } });
              var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
                return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(n3, t3);
              }, function(n3, t3) {
                function r3() {
                  this.constructor = n3;
                }
                i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
              }), c = function(n3) {
                function t3(r3) {
                  var i3 = n3.call(this, r3) || this;
                  if (i3.zn = [], i3.Dn = [], i3.Un = [], 4 !== r3.cipher.blockSize) throw new Error("In GCM block cipher mode, cipher block size must be 128bit");
                  var e2 = r3.cipher, o2 = r3.iv, u2 = [0, 0, 0, 0];
                  return e2.encryptBlock(u2, 0), i3.zn = u2, i3.Dn = t3.getJ0(u2, null == o2 ? void 0 : o2.words), i3.Un = i3.Dn.slice(), i3;
                }
                return f(t3, n3), t3.getJ0 = function(n4, r3) {
                  var i3;
                  if (r3 && 0 !== r3.length) if (3 === r3.length) i3 = [r3[0], r3[1], r3[2], 1];
                  else {
                    for (var e2 = r3.length % 4 > 0 ? 4 - r3.length % 4 : 0, o2 = r3.slice(), u2 = 0; u2 < e2 + 2; u2++) o2.push(0);
                    o2.push(0), o2.push(32 * r3.length), i3 = t3.GHASH(n4, o2);
                  }
                  else i3 = [0, 0, 0, 1];
                  return i3;
                }, t3.inc32 = function(n4) {
                  var t4 = n4.slice(), r3 = t4[3] >>> 0, i3 = r3 + 1 >>> 0 < r3;
                  if (t4[3] = t4[3] + 1 | 0, i3) {
                    var e2 = t4[2] >>> 0, o2 = e2 + 1 >>> 0 < e2;
                    t4[2] = t4[2] + 1 | 0, o2 && (t4[1] = t4[1] + 1 | 0);
                  }
                  return t4;
                }, t3.mul = function(n4, t4) {
                  for (var r3 = [3774873600, 0, 0, 0], i3 = [0, 0, 0, 0], e2 = t4.slice(), o2 = 0; o2 < 128; o2++) {
                    (n4[o2 >>> 5] >>> 31 - o2 % 32 & 1) > 0 && (i3[0] = i3[0] ^ e2[0], i3[1] = i3[1] ^ e2[1], i3[2] = i3[2] ^ e2[2], i3[3] = i3[3] ^ e2[3]);
                    var u2 = (1 & e2[3]) >>> 0, f2 = (1 & e2[0]) >>> 0, c2 = (1 & e2[1]) >>> 0, s = (1 & e2[2]) >>> 0;
                    e2[0] = e2[0] >>> 1, e2[1] = e2[1] >>> 1 | (f2 ? 2147483648 : 0), e2[2] = e2[2] >>> 1 | (c2 ? 2147483648 : 0), e2[3] = e2[3] >>> 1 | (s ? 2147483648 : 0), u2 > 0 && (e2[0] ^= r3[0], e2[1] ^= r3[1], e2[2] ^= r3[2], e2[3] ^= r3[3]);
                  }
                  return i3;
                }, t3.GHASH = function(n4, r3) {
                  if (n4.length % 4 != 0) throw new Error("Length of 32bit word array 'H' must be multiple of 4(128bit)");
                  if (r3.length % 4 != 0) throw new Error("Length of 32bit word array 'X' must be multiple of 4(128bit)");
                  for (var i3 = r3.length, e2 = [0, 0, 0, 0], o2 = 0; o2 < i3; o2 += 4) e2[0] = e2[0] ^ r3[o2], e2[1] = e2[1] ^ r3[o2 + 1], e2[2] = e2[2] ^ r3[o2 + 2], e2[3] = e2[3] ^ r3[o2 + 3], e2 = t3.mul(e2, n4);
                  return e2;
                }, t3.GCTR = function(n4, r3, i3) {
                  if (0 === i3.nSigBytes) return i3.clone();
                  if (4 !== r3.length) throw new Error("Initial Counter Block size must be 128bit");
                  for (var e2 = i3.words, u2 = Math.ceil(i3.nSigBytes / 16), f2 = [r3.slice()], c2 = 1; c2 < u2; c2++) {
                    var s = t3.inc32(f2[c2 - 1]);
                    f2.push(s);
                  }
                  var a = new o.e();
                  for (c2 = 0; c2 < u2; c2++) {
                    n4.encryptBlock(f2[c2], 0);
                    var h = i3.nSigBytes % 16;
                    if (c2 < u2 - 1 || 0 === h) {
                      var v = e2[4 * c2] ^ f2[c2][0], w = e2[4 * c2 + 1] ^ f2[c2][1], l = e2[4 * c2 + 2] ^ f2[c2][2], b = e2[4 * c2 + 3] ^ f2[c2][3], d = new o.e([v, w, l, b]);
                      a.concat(d);
                    } else {
                      for (var y = [], p = 0, O = Math.floor(h / 4), j = 0; j < O; j++) {
                        var _ = e2[4 * c2 + j] ^ f2[c2][j];
                        y.push(_), p += 4;
                      }
                      var m = h % 4;
                      if (m > 0) {
                        var A = e2[4 * c2 + O] << 32 - 8 * m ^ f2[c2][O];
                        y.push(A), p += m;
                      }
                      var g = new o.e(y, p);
                      a.concat(g);
                    }
                  }
                  return a.nSigBytes = i3.nSigBytes, a.clamp(), a;
                }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
                  var s = new n4({ key: r3, iv: i3 }), a = [0, 0, 0, 0];
                  s.encryptBlock(a, 0);
                  var h = t3.getJ0(a, i3.words), v = (null == e2 ? void 0 : e2.clone()) || new o.e(), w = [0, 8 * v.nSigBytes], l = (null == f2 ? void 0 : f2.clone()) || new o.e(), b = [0, 8 * l.nSigBytes], d = c2 || 16;
                  (0, u.I4)(v), (0, u.I4)(l);
                  var y = v.words.concat(l.words).concat(w).concat(b), p = t3.GHASH(a, y), O = t3.GCTR(s, h, new o.e(p));
                  return (0, u.z6)(O, d);
                }, t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function r3() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                    var i3 = this.Hn.blockSize;
                    this.Un = t3.inc32(this.Un);
                    for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
                  }, r3;
                }(t3), t3.Decryptor = function(n4) {
                  function r3() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                    var i3 = this.Hn.blockSize;
                    this.Un = t3.inc32(this.Un);
                    for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
                  }, r3;
                }(t3), t3;
              }(e.T);
            } }, t2 = {};
            function r(i2) {
              var e = t2[i2];
              if (void 0 !== e) return e.exports;
              var o = t2[i2] = { exports: {} };
              return n[i2](o, o.exports, r), o.exports;
            }
            r.d = function(n2, t22) {
              for (var i2 in t22) r.o(t22, i2) && !r.o(n2, i2) && Object.defineProperty(n2, i2, { enumerable: true, get: t22[i2] });
            }, r.g = function() {
              if ("object" == typeof globalThis) return globalThis;
              try {
                return this || new Function("return this")();
              } catch (n2) {
                if ("object" == typeof window) return window;
              }
            }(), r.o = function(n2, t22) {
              return Object.prototype.hasOwnProperty.call(n2, t22);
            }, r.r = function(n2) {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "Ln", { value: true });
            };
            var i = {};
            return function() {
              r.r(i), r.d(i, { AES: function() {
                return A.AES;
              }, Base64: function() {
                return t22.Base64;
              }, CBCMAC: function() {
                return b.CBCMAC;
              }, CipherParams: function() {
                return u.Q;
              }, DES: function() {
                return g.DES;
              }, DES3: function() {
                return E.DES3;
              }, EvpKDF: function() {
                return t22.EvpKDF;
              }, GMAC: function() {
                return l.GMAC;
              }, Hex: function() {
                return t22.Hex;
              }, Hmac: function() {
                return f.Hmac;
              }, HmacMD5: function() {
                return c.HmacMD5;
              }, HmacSHA1: function() {
                return s.HmacSHA1;
              }, HmacSHA224: function() {
                return a.HmacSHA224;
              }, HmacSHA256: function() {
                return h.HmacSHA256;
              }, HmacSHA384: function() {
                return v.HmacSHA384;
              }, HmacSHA512: function() {
                return w.HmacSHA512;
              }, Latin1: function() {
                return t22.Latin1;
              }, MD5: function() {
                return d.MD5;
              }, OpenSSLKDF: function() {
                return t22.OpenSSLKDF;
              }, PBKDF2: function() {
                return t22.PBKDF2;
              }, PasswordBasedCipher: function() {
                return o.E;
              }, RC4: function() {
                return k.RC4;
              }, RC4Drop: function() {
                return H.RC4Drop;
              }, RIPEMD160: function() {
                return S.RIPEMD160;
              }, Rabbit: function() {
                return M.Rabbit;
              }, SHA1: function() {
                return y.SHA1;
              }, SHA224: function() {
                return p.SHA224;
              }, SHA256: function() {
                return O.SHA256;
              }, SHA3: function() {
                return m.SHA3;
              }, SHA384: function() {
                return j.SHA384;
              }, SHA512: function() {
                return _.SHA512;
              }, SerializableCipher: function() {
                return e.D;
              }, Utf16: function() {
                return t22.Utf16;
              }, Utf16BE: function() {
                return t22.Utf16BE;
              }, Utf16LE: function() {
                return t22.Utf16LE;
              }, Utf8: function() {
                return t22.Utf8;
              }, Word32Array: function() {
                return t22.Word32Array;
              }, Word64: function() {
                return t22.Word64;
              }, Word64Array: function() {
                return t22.Word64Array;
              }, formatter: function() {
                return Y;
              }, mode: function() {
                return Z;
              }, pad: function() {
                return J;
              } });
              var n2, t22 = r(2688), e = r(9109), o = r(5693), u = r(2505), f = r(6367), c = r(3027), s = r(149), a = r(4105), h = r(980), v = r(5838), w = r(9902), l = r(7753), b = r(3967), d = r(670), y = r(3173), p = r(766), O = r(5561), j = r(6324), _ = r(7491), m = r(3408), A = r(9691), g = r(9910), E = r(6739), S = r(7104), M = r(5187), k = r(4615), H = r(9639), C = r(4344), B = r(1863), N = (n2 = function(t3, r2) {
                return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, t4) {
                  n3.__proto__ = t4;
                } || function(n3, t4) {
                  for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
                })(t3, r2);
              }, function(t3, r2) {
                function i2() {
                  this.constructor = t3;
                }
                n2(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
              }), I = function(n3) {
                function t3(t4) {
                  var r2 = n3.call(this, t4) || this;
                  return r2.Cn = [], r2;
                }
                return N(t3, n3), t3.prototype.generateKeyStreamAndEncrypt = function(n4, t4, r2, i2) {
                  var e2, o2 = this.ln;
                  o2 ? (e2 = o2.words.slice(0), this.ln = void 0) : e2 = this.Cn, i2.encryptBlock(e2, 0);
                  for (var u2 = 0; u2 < r2; u2++) n4[t4 + u2] ^= e2[u2];
                }, t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = n5.slice(t5, t5 + this.Hn.blockSize);
                  }, t4;
                }(t3), t3.Decryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    var r2 = n5.slice(t5, t5 + this.Hn.blockSize);
                    this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = r2;
                  }, t4;
                }(t3), t3;
              }(B.T), z = /* @__PURE__ */ function() {
                var n3 = function(t3, r2) {
                  return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                    n4.__proto__ = t4;
                  } || function(n4, t4) {
                    for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                  })(t3, r2);
                };
                return function(t3, r2) {
                  function i2() {
                    this.constructor = t3;
                  }
                  n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
                };
              }(), D = function(n3) {
                function t3(t4) {
                  var r2 = n3.call(this, t4) || this;
                  return r2.Fn = [], r2;
                }
                return z(t3, n3), t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return z(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.Fn;
                    e2 && (o2 = this.Fn = e2.words.slice(0), this.ln = void 0);
                    var u2 = o2.slice(0);
                    r2.encryptBlock(u2, 0), o2[i2 - 1] = o2[i2 - 1] + 1 | 0;
                    for (var f2 = 0; f2 < i2; f2++) n5[t5 + f2] ^= u2[f2];
                  }, t4;
                }(t3), t3.Decryptor = t3.Encryptor, t3;
              }(B.T), U = /* @__PURE__ */ function() {
                var n3 = function(t3, r2) {
                  return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                    n4.__proto__ = t4;
                  } || function(n4, t4) {
                    for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                  })(t3, r2);
                };
                return function(t3, r2) {
                  function i2() {
                    this.constructor = t3;
                  }
                  n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
                };
              }(), L = function(n3) {
                function t3(t4) {
                  return n3.call(this, t4) || this;
                }
                return U(t3, n3), t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    this.Hn.encryptBlock(n5, t5);
                  }, t4;
                }(t3), t3.Decryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    this.Hn.decryptBlock(n5, t5);
                  }, t4;
                }(t3), t3;
              }(B.T), F = /* @__PURE__ */ function() {
                var n3 = function(t3, r2) {
                  return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                    n4.__proto__ = t4;
                  } || function(n4, t4) {
                    for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                  })(t3, r2);
                };
                return function(t3, r2) {
                  function i2() {
                    this.constructor = t3;
                  }
                  n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
                };
              }(), x = function(n3) {
                function t3(t4) {
                  var r2 = n3.call(this, t4) || this;
                  return r2.xn = [], r2;
                }
                return F(t3, n3), t3.createEncryptor = function(n4) {
                  return new t3.Encryptor(n4);
                }, t3.createDecryptor = function(n4) {
                  return new t3.Decryptor(n4);
                }, t3.Encryptor = function(n4) {
                  function t4() {
                    return null !== n4 && n4.apply(this, arguments) || this;
                  }
                  return F(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                    var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.xn;
                    e2 && (o2 = this.xn = e2.words.slice(0), this.ln = void 0), r2.encryptBlock(o2, 0);
                    for (var u2 = 0; u2 < i2; u2++) n5[t5 + u2] ^= o2[u2];
                  }, t4;
                }(t3), t3.Decryptor = t3.Encryptor, t3;
              }(B.T), P = r(5607), R = r(3664);
              var T = { pad: function(n3, t3) {
                var r2 = n3.nSigBytes, i2 = 4 * t3, e2 = i2 - r2 % i2, o2 = r2 + e2 - 1;
                n3.clamp(), n3.words[o2 >>> 2] |= e2 << 24 - o2 % 4 * 8, n3.nSigBytes += e2;
              }, unpad: function(n3) {
                var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
                n3.nSigBytes -= t3;
              } }, K = r(3354);
              var W = { pad: function(n3, t3) {
                var r2 = 4 * t3, i2 = r2 - n3.nSigBytes % r2;
                n3.concat(K.e.random(i2 - 1)).concat(new K.e([i2 << 24], 1));
              }, unpad: function(n3) {
                var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
                n3.nSigBytes -= t3;
              } };
              var G = { pad: function(n3, t3) {
                var r2 = 4 * t3;
                n3.clamp(), n3.nSigBytes += r2 - (n3.nSigBytes % r2 || r2);
              }, unpad: function(n3) {
                for (var t3 = n3.words, r2 = n3.nSigBytes - 1; r2 >= 0; r2--) if (t3[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255) {
                  n3.nSigBytes = r2 + 1;
                  break;
                }
              } };
              var q = { pad: function(n3, t3) {
                n3.concat(new K.e([2147483648], 1)), G.pad(n3, t3);
              }, unpad: function(n3) {
                G.unpad(n3), n3.nSigBytes -= 1;
              } }, Q = r(7919);
              var X = { pad: function(n3, t3) {
              }, unpad: function(n3) {
              } }, V = r(1232), Z = { CBC: C.n, CFB: I, CTR: D, ECB: L, OFB: x, GCM: P.V, CCM: R.K }, J = { AnsiX923: T, ISO10126: W, ISO97971: q, Pkcs7: Q.l, NoPadding: X, Zero: G }, Y = { OpenSSLFormatter: V.w };
            }(), i;
          }();
        });
      }
    });
    var require_tokenToHash = __commonJS2({
      "../token/dist/tokenToHash.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.tokenToHash = void 0;
        var JsCrypto = require_jscrypto();
        var tokenToHash = function(_a) {
          var secretToken = _a.secretToken;
          return JsCrypto.SHA256.hash(secretToken).toString(JsCrypto.Base64);
        };
        exports22.tokenToHash = tokenToHash;
      }
    });
    var require_verifyToken = __commonJS2({
      "../token/dist/verifyToken.js"(exports22) {
        "use strict";
        var __awaiter = exports22 && exports22.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = exports22 && exports22.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1) throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
              if (y = 0, t2) op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.verifyToken = void 0;
        var errors_1 = require_dist9();
        var jose_1 = require_cjs4();
        var textEncoder = new TextEncoder();
        var verifyToken = function(_a) {
          var secret = _a.secret, token = _a.token;
          return __awaiter(void 0, void 0, void 0, function() {
            var secretKey, verifiedToken;
            return __generator(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  secretKey = textEncoder.encode(secret);
                  return [4, (0, jose_1.jwtVerify)(token, secretKey).catch(function() {
                    throw new errors_1.AuthorizationError();
                  })];
                case 1:
                  verifiedToken = _b2.sent();
                  return [2, verifiedToken.payload];
              }
            });
          });
        };
        exports22.verifyToken = verifyToken;
      }
    });
    var require_verifyAccessToken = __commonJS2({
      "../token/dist/verifyAccessToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.verifyAccessToken = void 0;
        var verifyToken_1 = require_verifyToken();
        var verifyAccessToken = function(args) {
          return (0, verifyToken_1.verifyToken)(args);
        };
        exports22.verifyAccessToken = verifyAccessToken;
      }
    });
    var require_verifyAssetsAccessToken = __commonJS2({
      "../token/dist/verifyAssetsAccessToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.verifyAssetsAccessToken = void 0;
        var verifyToken_1 = require_verifyToken();
        var verifyAssetsAccessToken = function(args) {
          return (0, verifyToken_1.verifyToken)(args);
        };
        exports22.verifyAssetsAccessToken = verifyAssetsAccessToken;
      }
    });
    var require_verifyChallengeToken = __commonJS2({
      "../token/dist/verifyChallengeToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.verifyChallengeToken = void 0;
        var verifyToken_1 = require_verifyToken();
        var verifyChallengeToken = function(args) {
          return (0, verifyToken_1.verifyToken)(args);
        };
        exports22.verifyChallengeToken = verifyChallengeToken;
      }
    });
    var require_verifyMigrationToken = __commonJS2({
      "../token/dist/verifyMigrationToken.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.verifyMigrationToken = void 0;
        var verifyToken_1 = require_verifyToken();
        var verifyMigrationToken = function(args) {
          return (0, verifyToken_1.verifyToken)(args);
        };
        exports22.verifyMigrationToken = verifyMigrationToken;
      }
    });
    var require_createApplicationClientId = __commonJS2({
      "../token/dist/createApplicationClientId.js"(exports22) {
        "use strict";
        Object.defineProperty(exports22, "__esModule", { value: true });
        exports22.createApplicationClientId = void 0;
        var nanoid_1 = require_nanoid();
        var createApplicationClientId = function() {
          return "client_".concat((0, nanoid_1.nanoid)(20));
        };
        exports22.createApplicationClientId = createApplicationClientId;
      }
    });
    var require_dist22 = __commonJS2({
      "../token/dist/index.js"(exports22) {
        "use strict";
        var __createBinding = exports22 && exports22.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          o[k2] = m[k];
        });
        var __exportStar = exports22 && exports22.__exportStar || function(m, exports3) {
          for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
        };
        Object.defineProperty(exports22, "__esModule", { value: true });
        __exportStar(require_createAccessToken(), exports22);
        __exportStar(require_createAssetsAccessToken(), exports22);
        __exportStar(require_createChallengeToken(), exports22);
        __exportStar(require_createMigrationToken(), exports22);
        __exportStar(require_createPersonalAccessToken(), exports22);
        __exportStar(require_decodeAccessToken(), exports22);
        __exportStar(require_getTokenFromRequest(), exports22);
        __exportStar(require_tokenToHash(), exports22);
        __exportStar(require_verifyAccessToken(), exports22);
        __exportStar(require_verifyAssetsAccessToken(), exports22);
        __exportStar(require_verifyChallengeToken(), exports22);
        __exportStar(require_verifyMigrationToken(), exports22);
        __exportStar(require_createApplicationClientId(), exports22);
      }
    });
    var src_exports = {};
    __export2(src_exports, {
      createSignedRequest: () => createSignedRequest,
      getCfIpfsGatewayUrl: () => getCfIpfsGatewayUrl,
      getFleekXyzIpfsGatewayUrl: () => getFleekXyzIpfsGatewayUrl4,
      getInternalGatewayUrlByStorageType: () => getInternalGatewayUrlByStorageType,
      getIpfsGatewayAssetsUrl: () => getIpfsGatewayAssetsUrl,
      getIpfsGatewayUrl: () => getIpfsGatewayUrl,
      getIpfsInternalGatewayUrl: () => getIpfsInternalGatewayUrl,
      getPrivateIpfsGatewayUrl: () => getPrivateIpfsGatewayUrl5,
      getStoragePinIdByCidAndProjectIdKey: () => getStoragePinIdByCidAndProjectIdKey,
      getWeb3IpfsGatewayUrl: () => getWeb3IpfsGatewayUrl
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_aws4 = require("aws4");
    var import_errors30 = __toESM2(require_dist9());
    var import_cids = __toESM2(require_src5());
    var defined2 = {
      IPFS_GATEWAY_HOSTNAME: "gateway-ipfs.fleek.xyz"
    };
    var override_env_var_prefix2 = "";
    var getDefined2 = (key) => process.env[`${override_env_var_prefix2}${key}`] || defined2[key];
    var IPFS_GATEWAY_HOSTNAME = getDefined2("IPFS_GATEWAY_HOSTNAME");
    var getIpfsInternalGatewayUrl = (hash) => {
      const cid = new import_cids.default(hash);
      const cidV1 = cid.toV1().toString("base32");
      if (!IPFS_GATEWAY_HOSTNAME) {
        throw new import_errors30.MissingExpectedDataError();
      }
      return `https://${cidV1}.ipfs.${IPFS_GATEWAY_HOSTNAME}`;
    };
    var getInternalGatewayUrlByStorageType = ({ cid, storageType }) => {
      switch (storageType) {
        case "IPFS":
          return getIpfsInternalGatewayUrl(cid);
        default:
          throw new Error(`Cannot generate internal gateway URL for unknown storageType: ${storageType}`);
      }
    };
    var import_utils_token = __toESM2(require_dist22());
    var getIpfsGatewayAssetsUrl = async (cid) => {
      const token = await (0, import_utils_token.createAssetsAccessToken)({
        payload: {
          cid
        },
        secret: process.env.SECRET_JWT_IDENTITY,
        expiration: "1m"
      });
      return `https://${process.env.ASSETS_URL}/cid?token=${token}`;
    };
    var createSignedRequest = (args) => {
      const { credentials, url, method, data, headers } = args;
      const request = {
        host: url.hostname,
        url: url.toString(),
        method,
        // path needs to include query params when present
        path: `${url.pathname}${url.search}`,
        timeout: 2e4,
        headers: headers || {},
        data,
        // signed request options
        service: "s3",
        region: "us-west-2"
      };
      (0, import_aws4.sign)(request, credentials);
      request.headers = {
        "Accept-Encoding": "*",
        ...data ? data.getHeaders() : {},
        ...request.headers
      };
      return request;
    };
    var getIpfsGatewayUrl = (hash) => `https://ipfs.io/ipfs/${hash}`;
    var getCfIpfsGatewayUrl = (hash) => `https://${hash}.ipfs.cf-ipfs.com`;
    var getWeb3IpfsGatewayUrl = (hash) => `https://${hash}.ipfs.w3s.link`;
    var getFleekXyzIpfsGatewayUrl4 = (hash) => `https://${hash}.ipfs.flk-ipfs.xyz`;
    var getPrivateIpfsGatewayUrl5 = ({ hostname, hash }) => `https://${hostname}/ipfs/${hash}`;
    var getStoragePinIdByCidAndProjectIdKey = ({ cid, projectId }) => `StoragePinIdByCidAndProjectId.${cid}.${projectId}`;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-ipns@0.1.13/node_modules/@fleek-platform/utils-ipns/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-ipns@0.1.13/node_modules/@fleek-platform/utils-ipns/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIpnsGatewayUrl = void 0;
    var errors_1 = require_dist4();
    var getIpnsGatewayUrl3 = (name) => {
      if (!name) {
        throw new errors_1.MissingExpectedDataError();
      }
      return `https://ipfs.io/ipns/${name}`;
    };
    exports2.getIpnsGatewayUrl = getIpnsGatewayUrl3;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path3) {
      const ctrl = callVisitor(key, node, visitor, path3);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path3, ctrl);
        return visit_(key, ctrl, visitor, path3);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path3 = Object.freeze(path3.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path3);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path3 = Object.freeze(path3.concat(node));
          const ck = visit_("key", node.key, visitor, path3);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path3);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path3) {
      const ctrl = await callVisitor(key, node, visitor, path3);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path3, ctrl);
        return visitAsync_(key, ctrl, visitor, path3);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path3 = Object.freeze(path3.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path3);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path3 = Object.freeze(path3.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path3);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path3);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path3) {
      if (typeof visitor === "function")
        return visitor(key, node, path3);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path3);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path3);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path3);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path3);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path3);
      return void 0;
    }
    function replaceNode(key, path3, node) {
      const parent = path3[path3.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t2) => t2.tag === tagName);
        const tagObj = match.find((t2) => !t2.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t2) => t2.identify?.(value) && !t2.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema2.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema2[identity.MAP] : Symbol.iterator in Object(value) ? schema2[identity.SEQ] : schema2[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema2, path3, value) {
      let v = value;
      for (let i = path3.length - 1; i >= 0; --i) {
        const k = path3[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema: schema2,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path3) => path3 == null || typeof path3 === "object" && !!path3[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema2) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema2,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema2) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema2)
          copy.schema = schema2;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema2) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path3, value) {
        if (isEmptyPath(path3))
          this.add(value);
        else {
          const [key, ...rest] = path3;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path3) {
        const [key, ...rest] = path3;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path3, keepScalar) {
        const [key, ...rest] = path3;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path3) {
        const [key, ...rest] = path3;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path3, value) {
        const [key, ...rest] = path3;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t2 = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t2);
        if (res === null)
          throw new Error(`Unsupported default string type ${t2}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t2) => t2.tag === item.tag);
        if (match.length > 0)
          return match.find((t2) => t2.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t2) => t2.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t2) => t2.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t2) => t2.format === item.format) ?? match.find((t2) => !t2.format);
      } else {
        obj = item;
        tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/log.js
var require_log3 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map, it);
      else
        mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log = require_log3();
    var merge = require_merge();
    var stringify = require_stringify2();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
      else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema2) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema2);
        if (identity.isNode(value))
          value = value.clone(schema2);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema2) {
        super(identity.MAP, schema2);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema2, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema2);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema2.sortMapEntries === "function") {
          map.items.sort(schema2.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!identity.isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema2, obj, ctx) => YAMLMap.YAMLMap.from(schema2, obj, ctx)
    };
    exports2.map = map;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema2) {
        super(identity.SEQ, schema2);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema2, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema2);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema2, obj, ctx) => YAMLSeq.YAMLSeq.from(schema2, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema2 = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema2;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema2 = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema2;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema2, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema2);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema2, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema2, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema2) {
        super(schema2);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema2, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema2);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema2 = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema2;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema2 = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema2.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema2 === "string" && schema2 || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path3, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path3, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path3) {
        if (Collection.isEmptyPath(path3)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path3) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path3, keepScalar) {
        if (Collection.isEmptyPath(path3))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path3, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path3) {
        if (Collection.isEmptyPath(path3))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path3) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path3, value) {
        if (Collection.isEmptyPath(path3)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path3), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path3, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/errors.js
var require_errors4 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t2) => t2.tag === tagName && t2.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema2[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema2.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema2.knownTags[tagName];
      if (kt && !kt.collection) {
        schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema2[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema: schema2 }, value, token, onError) {
      const tag = schema2.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema2[identity.SCALAR];
      if (schema2.compat) {
        const compat = schema2.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema2[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors4();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors4();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path3) => {
      let item = cst;
      for (const [field, index] of path3) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path3) => {
      const parent = visit.itemAtPath(cst, path3.slice(0, -1));
      const field = path3[path3.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path3, item, visitor) {
      let ctrl = visitor(item, path3);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path3.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path3);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path3) : ctrl;
    }
    exports2.visit = visit;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs18 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs18, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs18);
              } else {
                Object.assign(it, { key: fs18, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs18 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs18, sep: [] });
              else if (it.sep)
                this.stack.push(fs18);
              else
                Object.assign(it, { key: fs18, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors4();
    var log = require_log3();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/.pnpm/yaml@2.6.1/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors4();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-github@0.1.0/node_modules/@fleek-platform/utils-github/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-github@0.1.0/node_modules/@fleek-platform/utils-github/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateDeploymentWorkflowYaml = exports2.generateWorkflowSteps = void 0;
    var yaml_1 = require_dist6();
    var generateWorkflowSteps = (args) => {
      const steps = [
        { name: "Checkout", uses: "actions/checkout@v3" },
        { name: "Install Node.js", uses: "actions/setup-node@v3", with: { "node-version": args.nodeVersion } },
        { name: "Install Fleek CLI", run: "npm i -g @fleek-platform/cli" }
      ];
      const deployStep = { name: "Build & deploy sites", run: "fleek sites deploy" };
      if (args.installCommand) {
        steps.push({ name: "Install Packages", run: args.installCommand });
      }
      if (args.fleekConfigPath) {
        deployStep.run = `fleek sites deploy --config ${args.fleekConfigPath}`;
      }
      steps.push(deployStep);
      return steps;
    };
    exports2.generateWorkflowSteps = generateWorkflowSteps;
    var generateDeploymentWorkflowYaml2 = (args) => {
      const yamlLikeObject = {
        name: "Deploy site via Fleek",
        on: "push",
        jobs: {
          "deploy-to-fleek": {
            "runs-on": "ubuntu-latest",
            env: {
              FLEEK_TOKEN: "${{ secrets.FLEEK_TOKEN }}",
              FLEEK_PROJECT_ID: "${{ secrets.FLEEK_PROJECT_ID }}"
            },
            steps: (0, exports2.generateWorkflowSteps)(args)
          }
        }
      };
      return (0, yaml_1.stringify)(yamlLikeObject);
    };
    exports2.generateDeploymentWorkflowYaml = generateDeploymentWorkflowYaml2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/defined.js
var require_defined = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/defined.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefined = exports2.defined = void 0;
    exports2.defined = {
      SITE_SLUG_DOMAIN: "on-fleek.app"
    };
    var override_env_var_prefix2 = "";
    var getDefined2 = (key) => process.env[`${override_env_var_prefix2}${key}`] || exports2.defined[key];
    exports2.getDefined = getDefined2;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/cache.js
var require_cache2 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStoragePinCidByProjectIdAndPathKey = void 0;
    var getStoragePinCidByProjectIdAndPathKey = ({ projectId, path: path3 }) => `StoragePinCidByProjectIdAndPath.${projectId}.${path3}`;
    exports2.getStoragePinCidByProjectIdAndPathKey = getStoragePinCidByProjectIdAndPathKey;
  }
});

// node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/.pnpm/@fleek-platform+utils-gateways@0.1.12/node_modules/@fleek-platform/utils-gateways/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFleekDefaultGatewayBySlug = exports2.SITE_SLUG_DOMAIN = void 0;
    var errors_1 = require_dist4();
    var defined_1 = require_defined();
    exports2.SITE_SLUG_DOMAIN = (0, defined_1.getDefined)("SITE_SLUG_DOMAIN");
    var getFleekDefaultGatewayBySlug2 = ({ slug }) => {
      if (!slug) {
        throw new errors_1.MissingExpectedDataError();
      }
      return `https://${slug}.${exports2.SITE_SLUG_DOMAIN}`;
    };
    exports2.getFleekDefaultGatewayBySlug = getFleekDefaultGatewayBySlug2;
    __exportStar(require_cache2(), exports2);
  }
});

// src/cli.ts
var cli_exports = {};
__export(cli_exports, {
  asyncParser: () => asyncParser,
  init: () => init,
  output: () => output
});
module.exports = __toCommonJS(cli_exports);
var import_commander = require("commander");

// src/utils/json.ts
var import_node_fs = require("node:fs");
var import_node_path = __toESM(require("node:path"));
var BUILD_DIST_PATHNAME = "/dist";
var TEST_SRC_PATHNAME = "/src";
var leadingSlash = (str) => str.startsWith("/") ? str : `/${str}`;
var resolvePath = (filename) => {
  return import_node_path.default.join(
    __dirname.split(
      process.env.VITEST ? TEST_SRC_PATHNAME : BUILD_DIST_PATHNAME
    )[0],
    leadingSlash(filename)
  );
};
var loadJSONFromPackageRoot = (filename) => {
  const resolved = resolvePath(filename);
  return JSON.parse((0, import_node_fs.readFileSync)(resolved, "utf-8"));
};

// src/utils/translation.ts
var import_chalk = __toESM(require("chalk"));
var en = loadJSONFromPackageRoot("locales/en.json");
var _b = (text) => import_chalk.default.bold(text);
var _t = (key, values) => {
  const txt = en[key];
  if (!txt) {
    console.error(`Missing ${key}`);
    return `[ERROR: Missing ${key}]`;
  }
  const matches = [...txt.matchAll(/{(.*?)}/g)];
  let transl = txt;
  if (matches.length && values) {
    transl = matches.reduce((acc, curr) => {
      const txt2 = values[curr[1]];
      if (typeof txt2 !== "string") {
        return acc;
      }
      const val = values?.options?.bold ? _b(txt2) : txt2;
      return acc.replace(curr[0], val);
    }, txt);
  }
  return transl;
};
var t = (key, values) => _t(key, values);

// src/commands/applications/create.ts
var import_utils_validation5 = __toESM(require_dist3());

// src/guards/loginGuard.ts
var import_errors = __toESM(require_dist4());

// src/commands/auth/login.ts
var import_node = require("@fleek-platform/sdk/node");

// src/config.ts
var import_conf = __toESM(require("conf"));

// src/secrets.ts
var secrets = {
  FLEEK_TOKEN: process.env.FLEEK_TOKEN,
  FLEEK_PROJECT_ID: process.env.FLEEK_PROJECT_ID
};

// src/config.ts
var schema = {
  personalAccessToken: { type: "string" },
  projectId: { type: "string" }
};
var conf = new import_conf.default({
  schema,
  projectName: "fleek",
  configName: "global"
});
var config = {
  personalAccessToken: {
    get: () => secrets.FLEEK_TOKEN ?? conf.get("personalAccessToken"),
    set: (value) => conf.set("personalAccessToken", value),
    clear: () => conf.delete("personalAccessToken")
  },
  projectId: {
    get: () => secrets.FLEEK_PROJECT_ID ?? conf.get("projectId"),
    set: (value) => conf.set("projectId", value),
    clear: () => conf.delete("projectId")
  },
  clear: () => conf.clear()
};

// src/utils/token/generateVerificationSessionId.ts
var import_node_crypto = require("node:crypto");
var generateVerificationSessionId = () => (0, import_node_crypto.randomBytes)(16).toString("hex");

// src/utils/token/showVerificationSessionLink.ts
var getVerificationSessionLink = ({
  verificationSessionId,
  uiAppUrl
}) => `${uiAppUrl}/login/${verificationSessionId}`;
var showVerificationSessionLink = ({
  output: output2,
  uiAppUrl,
  verificationSessionId
}) => {
  const url = getVerificationSessionLink({
    uiAppUrl,
    verificationSessionId
  });
  output2.spinner(url);
  output2.chore(t("followLinkToLogin"));
  output2.link(url);
  output2.printNewLine();
};

// src/utils/checkPeriodicallyUntil.ts
var checkPeriodicallyUntil = async ({
  conditionFn,
  period,
  tries
}) => {
  const result = await conditionFn();
  if (result || tries < 1) {
    return result;
  }
  return new Promise((resolve) => setTimeout(resolve, period)).then(
    () => checkPeriodicallyUntil({ conditionFn, period, tries: tries - 1 })
  );
};

// src/utils/token/waitForPersonalAccessTokenFromVerificationSession.ts
var waitForPersonalAccessTokenFromVerificationSession = async ({
  verificationSessionId,
  client,
  name
}) => checkPeriodicallyUntil({
  conditionFn: async () => {
    const response = await client.mutation({
      createPersonalAccessTokenFromVerificationSession: {
        __args: {
          where: {
            id: verificationSessionId
          },
          data: {
            name
          }
        }
      }
    }).catch(() => null);
    return response?.createPersonalAccessTokenFromVerificationSession ?? null;
  },
  period: 2e3,
  tries: 500
});

// src/commands/auth/login.ts
var loginActionHandler = async ({
  uiAppUrl,
  authApiUrl
}) => {
  const verificationSessionId = generateVerificationSessionId();
  showVerificationSessionLink({ output, uiAppUrl, verificationSessionId });
  const client = (0, import_node.createClient)({ url: authApiUrl });
  const personalAccessToken = await waitForPersonalAccessTokenFromVerificationSession({
    verificationSessionId,
    client
  });
  if (!personalAccessToken) {
    output.error(t("timeoutPATfetch"));
    output.printNewLine();
    return;
  }
  config.personalAccessToken.set(personalAccessToken);
  config.projectId.clear();
  output.success(t("logged", { status: t("loggedInTo") }));
  output.printNewLine();
};

// src/defined.ts
var defined = {
  UI__APP_URL: "https://app.fleek.xyz",
  SDK__GRAPHQL_API_URL: "https://graphql.service.fleek.xyz/graphql",
  SDK__AUTH_APPS_URL: "https://auth-apps.service.fleek.xyz",
  SDK__IPFS__STORAGE_API_URL: "https://storage-ipfs.service.fleek.xyz",
  SDK__UPLOAD_PROXY_API_URL: "https://uploads.service.fleek.xyz"
};
var override_env_var_prefix = "";
var getDefined = (key) => process.env[`${override_env_var_prefix}${key}`] || defined[key];

// src/guards/loginGuard.ts
var loginGuard = async () => {
  const uiAppUrl = getDefined("UI__APP_URL");
  const authApiUrl = getDefined("SDK__GRAPHQL_API_URL");
  if (!uiAppUrl || !authApiUrl) {
    throw new import_errors.MissingExpectedDataError();
  }
  const accessToken = config.personalAccessToken.get();
  if (accessToken) {
    return;
  }
  output.warn(t("authReqStartLogginFlow"));
  output.printNewLine();
  await loginActionHandler({
    uiAppUrl,
    authApiUrl
  });
};

// src/guards/sdkGuard.ts
var import_node2 = require("@fleek-platform/sdk/node");
var getSdkClient = () => {
  const personalAccessToken = config.personalAccessToken.get();
  const projectId = config.projectId.get();
  if (!personalAccessToken) {
    output.error(t("missingPersonalAccessToken"));
    process.exit(1);
  }
  const accessTokenService = new import_node2.PersonalAccessTokenService({
    projectId,
    personalAccessToken
  });
  const sdk = new import_node2.FleekSdk({
    accessTokenService,
    graphqlServiceApiUrl: getDefined("SDK__GRAPHQL_API_URL"),
    ipfsStorageApiUrl: getDefined("SDK__IPFS__STORAGE_API_URL"),
    uploadProxyApiUrl: getDefined("SDK__UPLOAD_PROXY_API_URL")
  });
  return sdk;
};
var sdkGuard = (func) => {
  return async (args = {}) => {
    await loginGuard();
    const sdk = getSdkClient();
    if (!sdk) {
      output.error(t("failedAuthentication"));
      process.exit(1);
    }
    try {
      await func({ sdk, args });
    } catch (error) {
      if (error instanceof Error) {
        output.error(error?.toString());
        process.exit(1);
      }
      output.error(`Unknown Error: ${JSON.stringify(error)}`);
      process.exit(1);
    }
  };
};

// src/commands/projects/prompts/getProjectNameOrPrompt.ts
var import_errors2 = __toESM(require_dist4());
var import_utils_validation = __toESM(require_dist3());

// src/prompts/prompt.ts
var import_prompts = __toESM(require("prompts"));
var prompt = async ({
  onCancel,
  ...args
}) => {
  const { value } = await (0, import_prompts.default)(
    {
      ...args,
      name: "value"
    },
    {
      onCancel: () => {
        onCancel?.();
        process.exit(0);
      }
    }
  );
  return value;
};

// src/prompts/textPrompt.ts
var textPrompt = async ({
  message,
  initial,
  validate,
  onCancel
}) => {
  return prompt({ type: "text", message, initial, validate, onCancel });
};

// src/commands/projects/prompts/getProjectNameOrPrompt.ts
var getProjectNameOrPrompt = async ({
  name
}) => {
  if (name && (0, import_utils_validation.isProjectNameValid)({ name })) {
    return name;
  }
  if (name && !(0, import_utils_validation.isProjectNameValid)({ name })) {
    throw new import_errors2.ProjectInvalidNameError({ name });
  }
  return textPrompt({
    message: `${t("enterProjectName")}:`,
    validate: (partialName) => (0, import_utils_validation.isProjectNameValid)({ name: partialName }) || t("mustHaveXandYValidChars", { min: "3", max: "30" })
  });
};

// src/commands/projects/create.ts
var createProjectAction = async ({ sdk, args }) => {
  const name = await getProjectNameOrPrompt({ name: args.name });
  output.spinner(`${t("projectCreating")}...`);
  const response = await sdk.projects().create({ name });
  config.projectId.set(response.id);
  output.printNewLine();
  output.success(
    t("projectCreatedAndSwitched", { name, projectId: response.id })
  );
  output.printNewLine();
};
var createProjectActionHandler = sdkGuard(createProjectAction);

// src/commands/projects/prompts/getProjectOrPrompt.ts
var import_errors3 = __toESM(require_dist4());

// src/output/utils/eraseLines.ts
var import_ansi_escapes = __toESM(require("ansi-escapes"));
var eraseLines = (numberOfLines) => {
  return import_ansi_escapes.default.eraseLines(numberOfLines);
};

// src/prompts/selectPrompt.ts
var selectPrompt = async ({
  message,
  choices: choices2 = [],
  initial,
  onCancel
}) => {
  while (true) {
    const selectedValue = await prompt({
      type: "autocomplete",
      message,
      choices: choices2,
      initial,
      onCancel
    });
    if (choices2.some((choice) => choice.value === selectedValue)) {
      return selectedValue;
    }
    process.stdout.write(eraseLines(2));
  }
};

// src/commands/projects/prompts/getProjectOrPrompt.ts
var getProjectOrPrompt = async ({
  sdk,
  id
}) => {
  if (id) {
    return await sdk.projects().get({ id });
  }
  const projects = await sdk.projects().list();
  if (projects.length === 0) {
    throw new import_errors3.ProjectsNotFoundError();
  }
  const projectId = await selectPrompt({
    message: `${t("commonSelectXFromList", { subject: t("aProject") })}:`,
    choices: projects.map((project) => ({
      title: project.name,
      value: project.id
    }))
  });
  const matchProject = projects.find((project) => project.id === projectId);
  if (!matchProject) return;
  return matchProject;
};

// src/commands/projects/switch.ts
var switchProjectAction = async ({ sdk, args }) => {
  const project = await getProjectOrPrompt({ sdk, id: args.id }).catch(
    () => null
  );
  if (project === null) {
    output.log(t("projectsSwitchNeedCreateFirst"));
    await createProjectActionHandler();
    return;
  }
  if (!project) {
    output.log(t("noProjectIdFoundUnexpectedly"));
    return;
  }
  config.projectId.set(project.id);
  output.printNewLine();
  output.success(t("projectsSwitchSuccess", { name: project.name }));
  output.printNewLine();
};
var switchProjectActionHandler = sdkGuard(switchProjectAction);

// src/guards/projectGuard.ts
var projectGuard = async () => {
  const projectId = config.projectId.get();
  if (projectId) {
    return;
  }
  output.warn(t("projectSelectRequiredStarPrjFlow"));
  output.printNewLine();
  await sdkGuard(switchProjectAction)();
};

// src/prompts/confirmPrompt.ts
var confirmPrompt = async ({
  message,
  initial,
  onCancel
}) => {
  return prompt({
    type: "confirm",
    message,
    initial,
    onCancel
  });
};

// src/commands/sites/prompts/confirmUseExistingSitePrompt.ts
var confirmUseExistingSitePrompt = async () => confirmPrompt({
  message: t("foundSiteLinkToExisting"),
  initial: true
});

// src/commands/sites/prompts/getSiteOrPrompt.ts
var import_errors4 = __toESM(require_dist4());
var getSiteOrPrompt = async ({
  id,
  slug,
  sdk
}) => {
  if (id) {
    return sdk.sites().get({ id });
  }
  if (slug) {
    return sdk.sites().getBySlug({ slug });
  }
  const sites = await sdk.sites().list();
  if (!sites.length) {
    throw new import_errors4.SitesNotFoundError();
  }
  const selectedSiteId = await selectPrompt({
    message: t("commonSelectXFromList", { subject: t("site") }),
    choices: sites.map((site) => ({ title: site.name, value: site.id }))
  });
  const matchSite = sites.find((site) => site.id === selectedSiteId);
  if (!matchSite) return;
  return matchSite;
};

// src/commands/sites/prompts/enterSiteNamePrompt.ts
var import_utils_validation2 = __toESM(require_dist3());
var enterSiteNamePrompt = async () => textPrompt({
  message: `${t("typeNewSiteName")}:`,
  validate: (partialName) => (0, import_utils_validation2.isSiteNameValid)({ name: partialName }) || t("invalidNameUseAlphDashes")
});

// src/commands/sites/utils/createSite.ts
var createSite = async ({ sdk }) => {
  const name = await enterSiteNamePrompt();
  output.spinner(`${t("creatingSite")}...`);
  const site = await sdk.sites().create({ name });
  output.printNewLine();
  output.success(
    t("commonNameCreateSuccess", { name: `${t("site")} "${name}"` })
  );
  output.printNewLine();
  return site;
};

// src/commands/sites/utils/chooseOrCreateSite.ts
var chooseOrCreateSite = async ({
  sdk
}) => {
  const sites = await sdk.sites().list();
  if (!sites.length) {
    output.warn(t("noSitesFound"));
    return createSite({ sdk });
  }
  const useExistingSite = await confirmUseExistingSitePrompt();
  if (useExistingSite) {
    const site = getSiteOrPrompt({ sdk });
    if (!site) {
      output.error(t("expectedNotFoundGeneric", { name: "site" }));
      return;
    }
    return site;
  }
  return createSite({ sdk });
};

// src/utils/configuration/saveConfiguration.ts
var import_node_fs4 = require("node:fs");
var import_node_path4 = __toESM(require("node:path"));

// src/utils/configuration/getConfiguration.ts
var import_node_fs2 = require("node:fs");
var import_node_path2 = require("node:path");
var import_errors5 = __toESM(require_dist4());

// src/utils/configuration/types.ts
var FleekSiteConfigFormats = /* @__PURE__ */ ((FleekSiteConfigFormats2) => {
  FleekSiteConfigFormats2["JSON"] = "json";
  FleekSiteConfigFormats2["Typescript"] = "ts";
  FleekSiteConfigFormats2["Javascript"] = "js";
  return FleekSiteConfigFormats2;
})(FleekSiteConfigFormats || {});

// src/utils/configuration/getConfiguration.ts
var getConfigurationPath = async ({
  predefinedConfigPath
}) => {
  if (predefinedConfigPath) {
    const absolutePath = (0, import_node_path2.join)(process.cwd(), predefinedConfigPath);
    return import_node_fs2.promises.access(absolutePath, import_node_fs2.constants.R_OK).then(() => absolutePath).catch(
      () => Promise.reject(
        new import_errors5.FleekConfigMissingFileError({ configPath: predefinedConfigPath })
      )
    );
  }
  const supposedFilenames = [
    "fleek.config.ts",
    "fleek.config.js",
    "fleek.config.json"
  ];
  for (const supposedFilename of supposedFilenames) {
    const absolutePath = (0, import_node_path2.join)(process.cwd(), supposedFilename);
    const isSupposedFileAccessible = await import_node_fs2.promises.access(absolutePath, import_node_fs2.constants.R_OK).then(() => true).catch(() => false);
    if (isSupposedFileAccessible) {
      return absolutePath;
    }
  }
  throw new import_errors5.FleekConfigMissingFileError({});
};
var FLEEK_CONFIG_BASENAME = "fleek.config";
var FLEEK_CONFIG_TMPL_JSON_PLACEHOLDER = "$jsonContent";
var getConfigFileByTypeName = (name) => `${FLEEK_CONFIG_BASENAME}.${FleekSiteConfigFormats[name]}`;
var getConfigFileByTypeValue = (val) => `${FLEEK_CONFIG_BASENAME}.${val}`;
var getConfigTemplateByTypeName = (name) => `${getConfigFileByTypeName(name)}.tmpl`;

// src/utils/configuration/loadConfiguration.ts
var import_errors7 = __toESM(require_dist4());
var import_utils_validation3 = __toESM(require_dist3());

// src/utils/configuration/readConfigurationFile.ts
var import_node_module = require("node:module");
var import_node_fs3 = require("node:fs");
var import_node_path3 = require("node:path");
var import_errors6 = __toESM(require_dist4());
var import_ts_node = require("ts-node");
var readConfigurationFile = async ({
  predefinedConfigPath
}) => {
  const configPath = await getConfigurationPath({ predefinedConfigPath });
  const fileExtension = (0, import_node_path3.extname)(configPath);
  if (fileExtension === ".json") {
    const content = await import_node_fs3.promises.readFile(configPath, "utf8").catch(() => Promise.reject(new import_errors6.FleekConfigMissingFileError({})));
    try {
      return { configuration: JSON.parse(content), configPath };
    } catch (e) {
      throw new import_errors6.FleekConfigInvalidContentError({
        configPath,
        validationResult: t("jsonNotValid")
      });
    }
  }
  if (fileExtension === ".ts") {
    (0, import_ts_node.register)({ skipProject: true });
  }
  if ([".js", ".ts"].includes(fileExtension)) {
    try {
      (0, import_node_module.createRequire)(configPath);
    } catch (e) {
      throw new import_errors6.FleekConfigMissingFileError({ configPath });
    }
    try {
      const loadedConfigModule = await (async () => {
        if (fileExtension.toLowerCase() === ".ts") {
          const x = await import("importx");
          const { default: loadedConfigModule2 } = await x.import(
            configPath,
            __filename
          );
          return loadedConfigModule2;
        }
        return import(configPath);
      })();
      if (typeof loadedConfigModule.default === "function") {
        return {
          configuration: await loadedConfigModule.default(),
          configPath
        };
      }
      if (typeof loadedConfigModule.default !== "undefined") {
        return { configuration: await loadedConfigModule.default, configPath };
      }
      if (typeof loadedConfigModule === "function") {
        return { configuration: await loadedConfigModule(), configPath };
      }
      if (typeof loadedConfigModule !== "undefined") {
        return { configuration: await loadedConfigModule, configPath };
      }
    } catch (e) {
      throw new import_errors6.FleekConfigInvalidContentError({
        configPath,
        validationResult: e instanceof Error ? e.message : ""
      });
    }
  }
  throw new import_errors6.FleekConfigInvalidContentError({
    configPath,
    validationResult: t("unknownFileExt")
  });
};

// src/utils/configuration/loadConfiguration.ts
var loadConfiguration = async ({
  predefinedConfigPath
}) => {
  const { configuration, configPath } = await readConfigurationFile({
    predefinedConfigPath
  });
  return (0, import_utils_validation3.validateConfigurationWithResult)({ configuration }).catch(
    (error) => Promise.reject(
      new import_errors7.FleekConfigInvalidContentError({
        configPath,
        validationResult: error.message
      })
    )
  );
};

// src/utils/configuration/saveConfiguration.ts
var import_errors8 = __toESM(require_dist4());

// src/utils/formats.ts
var isValidFleekConfigFormat = (format) => Object.values(FleekSiteConfigFormats).includes(format);

// src/utils/configuration/saveConfiguration.ts
var DEV_SRC_UTILS_PATH = "/src/utils";
var basePath = import_node_path4.default.dirname(__filename).includes(DEV_SRC_UTILS_PATH) ? "../.." : "";
var filePathForTypescriptConfig = import_node_path4.default.resolve(
  import_node_path4.default.dirname(__filename),
  basePath,
  "templates/sites/config",
  getConfigTemplateByTypeName("Typescript")
);
var filePathForJavascriptConfig = import_node_path4.default.resolve(
  import_node_path4.default.dirname(__filename),
  basePath,
  "templates/sites/config",
  getConfigTemplateByTypeName("Javascript")
);
var saveConfiguration = async ({
  config: config2,
  format
}) => {
  const formattedOutput = (() => {
    try {
      if (!Array.isArray(config2.sites) || !config2.sites[0].slug) throw Error();
      return JSON.stringify(config2, void 0, 2);
    } catch (err) {
      throw new import_errors8.InvalidJSONFormat();
    }
  })();
  if (!isValidFleekConfigFormat(format)) {
    throw new import_errors8.ExpectedOneOfValuesError({
      expectedValues: Object.values(FleekSiteConfigFormats),
      receivedValue: format
    });
  }
  let content;
  let configFile;
  switch (format) {
    case "ts" /* Typescript */: {
      const contentForTypescriptConfig = (await import_node_fs4.promises.readFile(filePathForTypescriptConfig)).toString();
      content = contentForTypescriptConfig.replace(
        FLEEK_CONFIG_TMPL_JSON_PLACEHOLDER,
        formattedOutput
      );
      configFile = getConfigFileByTypeName("Typescript");
      break;
    }
    case "js" /* Javascript */: {
      const contentForJavascriptConfig = (await import_node_fs4.promises.readFile(filePathForJavascriptConfig)).toString();
      content = contentForJavascriptConfig.replace(
        FLEEK_CONFIG_TMPL_JSON_PLACEHOLDER,
        formattedOutput
      );
      configFile = getConfigFileByTypeName("Javascript");
      break;
    }
    case "json" /* JSON */: {
      content = formattedOutput;
      configFile = getConfigFileByTypeName("JSON");
      break;
    }
  }
  try {
    await import_node_fs4.promises.writeFile(configFile, content);
    return configFile;
  } catch (_err) {
  }
};

// src/utils/fs.ts
var import_node_fs5 = require("node:fs");
var fileExists = async (path3) => {
  try {
    const stat = await import_node_fs5.promises.stat(path3);
    return stat.isFile();
  } catch (e) {
    const err = e;
    if (err.code === "ENOENT") {
      return false;
    }
    throw e;
  }
};

// src/commands/sites/prompts/enterDirectoryPathPrompt.ts
var import_node_path5 = require("node:path");

// src/commands/sites/utils/directoryExists.ts
var import_node_fs6 = require("node:fs");
var directoryExists = async (path3) => {
  try {
    const stat = await import_node_fs6.promises.stat(path3);
    return stat.isDirectory();
  } catch (e) {
    const err = e;
    if (err.code === "ENOENT") {
      return false;
    }
    throw e;
  }
};

// src/commands/sites/prompts/enterDirectoryPathPrompt.ts
var enterDirectoryPathPrompt = async ({
  message
}) => {
  const path3 = await textPrompt({
    message,
    validate: async (path4) => {
      if (!path4) {
        return t("specifyValidDir");
      }
      const isDirectory = await directoryExists((0, import_node_path5.join)(process.cwd(), path4));
      return isDirectory ? true : t("specifyValidDir");
    },
    onCancel: () => {
      output.warn(t("specifyValidDir"));
      output.error(t("exiting"));
    }
  });
  return path3;
};

// src/commands/sites/prompts/selectConfigurationFormatPrompt.ts
var choices = Object.keys(FleekSiteConfigFormats).map((name) => {
  const value = FleekSiteConfigFormats[name];
  const configFile = getConfigFileByTypeValue(value);
  return {
    title: `${name} (${configFile})`,
    value
  };
});
var selectConfigurationFormatPrompt = async () => selectPrompt({
  message: `${t("selectFormatForSiteConf")}:`,
  choices
});

// src/commands/sites/prompts/confirmIncludeBuildCommandPrompt.ts
var confirmIncludeBuildCommandPrompt = async () => confirmPrompt({
  message: t("includeOptBuildCmd", { build: "build" }),
  initial: true
});

// src/commands/sites/prompts/enterBuildCommandPrompt.ts
var import_node_fs7 = require("node:fs");
var enterBuildCommandPrompt = async () => textPrompt({
  message: "Specify `build` command:",
  initial: await tryToGetBuildCommand()
});
var tryToGetBuildCommand = async () => {
  const filesInRootDir = await import_node_fs7.promises.readdir(process.cwd());
  if (filesInRootDir.includes("package-lock.json")) {
    return "npm run build";
  }
  if (filesInRootDir.includes("pnpm-lock.yaml") || filesInRootDir.includes("pnpm-workspace.yaml")) {
    return "pnpm run build";
  }
  if (filesInRootDir.includes("yarn.lock")) {
    return "yarn run build";
  }
  return;
};

// src/commands/sites/utils/selectBuildCommandOrSkip.ts
var selectBuildCommandOrSkip = async () => {
  const includeBuildCommand = await confirmIncludeBuildCommandPrompt();
  if (!includeBuildCommand) {
    return;
  }
  const buildCommand = await enterBuildCommandPrompt();
  return buildCommand;
};

// src/commands/sites/utils/initConfiguration.ts
var initConfiguration = async ({
  site,
  onUnexpectedFormatError,
  onSaveConfigurationError
}) => {
  const distDir = await enterDirectoryPathPrompt({
    message: t("specifyDistDirToSiteUpl")
  });
  const buildCommand = await selectBuildCommandOrSkip();
  const config2 = {
    sites: [{ slug: site.slug, distDir, buildCommand }]
  };
  const format = await selectConfigurationFormatPrompt();
  if (!isValidFleekConfigFormat(format)) {
    onUnexpectedFormatError(format);
  }
  const configFile = await saveConfiguration({ config: config2, format });
  if (!configFile) {
    onSaveConfigurationError();
    return;
  }
  const isFile = await fileExists(configFile);
  if (!isFile) {
    onSaveConfigurationError();
    return;
  }
  return config2;
};

// src/guards/sitesGuard.ts
var sitesGuard = async ({
  predefinedConfigPath
}) => {
  const isConfigValid = await (async () => {
    try {
      return !!await loadConfiguration({ predefinedConfigPath });
    } catch (_err) {
      return false;
    }
  })();
  if (!isConfigValid) {
    output.hint(t("createValidConfAsInstruct"));
    output.printNewLine();
    const sdk = getSdkClient();
    if (!sdk) {
      output.error(t("unexpectedError"));
      return false;
    }
    const site = await chooseOrCreateSite({ sdk });
    if (!site) {
      output.error(t("unexpectedError"));
      return false;
    }
    await initConfiguration({
      site,
      onUnexpectedFormatError: (format) => {
        output.warn(t("unexpectedFileFormat", { format }));
        process.exit(1);
      },
      onSaveConfigurationError: () => {
        output.warn(t("fsFailedToWriteConfig"));
        process.exit(1);
      }
    });
  }
};

// src/guards/withGuards.ts
var withGuards = (handler, { scopes }) => {
  return async (args = {}) => {
    if (scopes.authenticated) {
      await loginGuard();
    }
    if (scopes.project) {
      await projectGuard();
    }
    if (scopes.site) {
      await sitesGuard(args);
    }
    try {
      const action = sdkGuard(handler);
      await action(args);
    } catch (error) {
      if (error instanceof Error) {
        output.error(error?.message);
        return;
      }
      output.error(`${t("unexpectedError")} ${JSON.stringify(error)}`);
    }
  };
};

// src/utils/prompts/promptUntil.ts
var promptUntil = async ({
  handler,
  validator
}) => {
  const data = await handler();
  if (!await validator(data)) {
    return promptUntil({ handler, validator });
  }
  return data;
};

// src/commands/applications/prompts/enterApplicationNameOrPrompt.ts
var import_errors9 = __toESM(require_dist4());

// src/commands/applications/utils/isNameValid.ts
var import_utils_validation4 = __toESM(require_dist3());
var isNameValid = ({ name }) => import_utils_validation4.name.safeParse(name).success;

// src/commands/applications/prompts/enterApplicationNameOrPrompt.ts
var enterApplicationNameOrPrompt = async (args) => {
  if (args.name && isNameValid({ name: args.name })) {
    return args.name;
  }
  if (args.name && !isNameValid({ name: args.name })) {
    throw new import_errors9.ApplicationNameInvalidError({ name: args.name });
  }
  return textPrompt({
    message: `${t("typeAppName")}:`,
    validate: (name) => isNameValid({ name }) ? true : t("invalidNameUseXofYAndRegex", {
      min: "3",
      max: "30"
    }),
    initial: args.application?.name
  });
};

// src/prompts/listPrompt.ts
var listPrompt = async ({
  message,
  initial,
  onCancel
}) => {
  return prompt({
    type: "list",
    message,
    initial: initial?.join(", "),
    onCancel
  });
};

// src/commands/applications/prompts/getWhitelistDomainsOrPrompt.ts
var getWhitelistDomainsOrPrompt = async ({
  whitelistDomains,
  whitelistDomainsToUpdate
}) => {
  if (whitelistDomains) {
    return whitelistDomains;
  }
  const list = await listPrompt({
    message: t("typeWhitelistDomainsSepByComma"),
    initial: whitelistDomainsToUpdate
  });
  const domains = list.filter((hostname) => hostname.length > 0);
  if (!domains.length) {
    output.warn(t("warnProvideValidDomainName"));
    output.printNewLine();
    return getWhitelistDomainsOrPrompt({
      whitelistDomains,
      whitelistDomainsToUpdate
    });
  }
  return domains;
};

// src/commands/applications/create.ts
var whitelistArgParser = (listArg) => {
  try {
    if (!Array.isArray(listArg)) {
      throw new Error(t("unexpectedArg"));
    }
    return listArg[0].split(",").reduce((acc, curr) => {
      acc.push(curr.trim());
      return acc;
    }, []);
  } catch (err) {
    if (err instanceof Error) {
      output.error(err.message);
      return;
    }
    throw Error(t("unexpectedError"));
  }
};
var createApplicationAction = async ({ sdk, args }) => {
  const isNonInteractive = !!Object.keys(args).length;
  const name = isNonInteractive ? args.name : await enterApplicationNameOrPrompt({ name: args.name });
  let whitelistDomains;
  if (isNonInteractive) {
    whitelistDomains = whitelistArgParser(args.whitelistDomains);
  } else {
    const handler = async () => getWhitelistDomainsOrPrompt({
      whitelistDomains: args.whitelistDomains
    });
    const validator = async (data) => {
      let hasInvalidHostname = false;
      for (const hostname of data) {
        if (!(0, import_utils_validation5.isHostnameValid)({ hostname })) {
          hasInvalidHostname = true;
          output.warn(t("invalidHostname", { hostname }));
        }
      }
      if (hasInvalidHostname) {
        output.printNewLine();
      }
      return !hasInvalidHostname;
    };
    whitelistDomains = await promptUntil({
      handler,
      validator
    });
  }
  if (!name || !whitelistDomains) {
    output.error(t("unexpectedError"));
    return;
  }
  const { clientId } = await sdk.applications().create({ name, whitelistDomains });
  output.printNewLine();
  output.success(t("appCreateSuccessClientId", { clientId }));
  output.printNewLine();
};
var createApplicationActionHandler = withGuards(
  createApplicationAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/applications/prompts/getApplicationOrPrompt.ts
var import_errors10 = __toESM(require_dist4());
var getApplicationOrPrompt = async ({
  id,
  sdk
}) => {
  if (id) {
    return sdk.applications().get({ id });
  }
  const applications = await sdk.applications().list();
  if (applications.length === 0) {
    throw new import_errors10.ApplicationsNotFoundError({});
  }
  const selectedApplicationId = await selectPrompt({
    message: `${t("selectApp")}:`,
    choices: applications.map((application) => ({
      title: application.name,
      value: application.id
    }))
  });
  const appMatch = applications.find(
    (application) => application.id === selectedApplicationId
  );
  if (!appMatch) return;
  return appMatch;
};

// src/commands/applications/delete.ts
var deleteApplicationAction = async ({ sdk, args }) => {
  const application = await getApplicationOrPrompt({ id: args.id, sdk });
  if (!application) {
    output.error(t("expectedNotFoundGeneric", { name: "application" }));
    return;
  }
  await sdk.applications().delete({ id: application.id });
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: t("clientId"),
      action: t("deleted")
    })
  );
};
var deleteApplicationActionHandler = withGuards(
  deleteApplicationAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/applications/utils/parser.ts
var parseWhitelistDomains = ({
  whitelistDomains,
  whiteLabelDomains
}) => {
  const combinedWhitelistDomains = [
    ...whitelistDomains.map((whitelistDomain) => whitelistDomain.hostname),
    ...whiteLabelDomains.map((whiteLabelDomain) => whiteLabelDomain.hostname)
  ];
  const uniqueWhitelistDomains = Array.from(
    new Set(combinedWhitelistDomains)
  ).map((uniqueWhitelistDomain) => ({
    hostname: uniqueWhitelistDomain
  }));
  return uniqueWhitelistDomains;
};

// src/commands/applications/utils/truncateAndJoinStrings.ts
var truncateAndJoinStrings = (args) => {
  const truncatedArray = args.truncateOnPosition ? args.input.slice(0, args.truncateOnPosition) : args.input;
  const stringifiedArray = truncatedArray.join(",");
  return args.input.length > truncatedArray.length ? `${stringifiedArray},...` : stringifiedArray;
};

// src/commands/applications/list.ts
var listApplicationsAction = async ({ sdk }) => {
  const applications = await sdk.applications().list();
  if (applications.length === 0) {
    output.log(t("noYYet", { name: `${t("sdkPoweredApp")} ${t("clientId")}` }));
    return;
  }
  output.table(
    applications.map(
      ({
        id,
        name,
        clientId,
        whitelistDomains,
        whiteLabelDomains,
        createdAt
      }) => {
        const uniqueWhitelistDomains = parseWhitelistDomains({
          whiteLabelDomains,
          whitelistDomains
        });
        return {
          ID: id,
          Name: name,
          "Client ID": clientId,
          "White list domains": truncateAndJoinStrings({
            input: uniqueWhitelistDomains.map(
              (whitelistDomain) => whitelistDomain.hostname
            ),
            truncateOnPosition: 3
          }),
          "Created At": createdAt
        };
      }
    )
  );
};
var listApplicationsActionHandler = withGuards(
  listApplicationsAction,
  {
    scopes: {
      authenticated: true,
      project: true,
      site: false
    }
  }
);

// src/commands/applications/update.ts
var import_utils_validation6 = __toESM(require_dist3());
var updateApplicationAction = async ({ sdk, args }) => {
  const application = await getApplicationOrPrompt({ id: args.id, sdk });
  if (!application) {
    output.error(t("noAppFoundUnexpectedly"));
    return;
  }
  const name = await enterApplicationNameOrPrompt({
    name: args.name,
    application
  });
  const handler = async () => getWhitelistDomainsOrPrompt({
    whitelistDomains: args.whitelistDomains,
    whitelistDomainsToUpdate: application.whitelistDomains.map(
      (whitelistDomain) => whitelistDomain.hostname
    )
  });
  const validator = async (data) => {
    let hasInvalidHostname = false;
    for (const hostname of data) {
      if (!(0, import_utils_validation6.isHostnameValid)({ hostname })) {
        hasInvalidHostname = true;
        output.warn(t("invalidHostname", { hostname }));
      }
    }
    if (hasInvalidHostname) {
      output.printNewLine();
    }
    return !hasInvalidHostname;
  };
  const whitelistDomains = await promptUntil({
    handler,
    validator
  });
  await sdk.applications().update({ id: application.id, name, whitelistDomains });
  output.printNewLine();
  output.success(t("appClientSuccessUpdated"));
};
var updateApplicationActionHandler = withGuards(
  updateApplicationAction,
  {
    scopes: {
      authenticated: true,
      project: true,
      site: false
    }
  }
);

// src/commands/applications/index.ts
var applications_default = (program) => {
  const cmd = program.command("applications").description(t("appCmdDescription"));
  cmd.command("list").description(t("listAllAppForProject")).action(listApplicationsActionHandler);
  cmd.command("create").option("--name <string>").option("--whitelistDomains <string...>", t("whitelistDomainsSepBySp")).description(t("createNewAppClient")).action(
    (options) => createApplicationActionHandler(options)
  );
  cmd.command("update").option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("clientId"),
      subject: t("sdkPoweredApp"),
      action: t("update")
    })
  ).option("--name <string>", t("newNameOfAppClient")).option("--whitelistDomains <string...>", t("whitelistDomainsSepBySp")).description(t("updateAppClient")).action(
    (options) => updateApplicationActionHandler(options)
  );
  cmd.command("delete").description(t("deleteAppClient")).option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("clientId"),
      subject: t("sdkPoweredApp"),
      action: t("delete")
    })
  ).action(
    (options) => deleteApplicationActionHandler(options)
  );
  return cmd;
};

// src/commands/auth/index.ts
var import_errors11 = __toESM(require_dist4());

// src/commands/auth/logout.ts
var logoutActionHandler = async () => {
  const secretToken = config.personalAccessToken.get();
  if (!secretToken) {
    return;
  }
  config.clear();
  output.success(t("logged", { status: t("loggedOutOf") }));
};

// src/commands/auth/index.ts
var auth_default = (cmd) => {
  cmd.command("login").description(t("cmdAuthLoginDescription")).action(() => {
    const uiAppUrl = getDefined("UI__APP_URL");
    const authApiUrl = getDefined("SDK__GRAPHQL_API_URL");
    if (!uiAppUrl || !authApiUrl) {
      throw new import_errors11.MissingExpectedDataError();
    }
    return loginActionHandler({
      uiAppUrl,
      authApiUrl
    });
  });
  cmd.command("logout").description(t("cmdAuthLogoutDescription")).action(logoutActionHandler);
  return cmd;
};

// src/utils/pressAnyKey.ts
var usePressAnyKey = () => {
  const cancel = { current: () => {
  } };
  const waitForAnyKey = async () => new Promise((resolve, reject) => {
    const stopWaiting = () => {
      process.stdin.removeListener("data", handler);
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.pause();
    };
    const handler = (buffer) => {
      stopWaiting();
      const bytes = Array.from(buffer);
      if (bytes.length && bytes[0] === 3) {
        process.exit(1);
      }
      process.nextTick(resolve);
    };
    cancel.current = () => {
      stopWaiting();
      reject("Canceled");
    };
    process.stdin.resume();
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
    process.stdin.once("data", handler);
  });
  return { waitForAnyKey, cancel: () => cancel.current() };
};

// src/commands/domains/prompts/getHostnameOrPrompt.ts
var import_errors12 = __toESM(require_dist4());
var import_utils_validation7 = __toESM(require_dist3());
var getHostnameOrPrompt = async ({
  hostname
}) => {
  if (hostname && (0, import_utils_validation7.isHostnameValid)({ hostname })) {
    return hostname;
  }
  if (hostname && !(0, import_utils_validation7.isHostnameValid)({ hostname })) {
    throw new import_errors12.DomainHostnameInvalidError({ hostname });
  }
  return textPrompt({
    message: `${t("enterDomainName")}:`,
    validate: (partialHostname) => (0, import_utils_validation7.isHostnameValid)({ hostname: partialHostname }) || t("hostnameIncorrectForm")
  });
};

// src/commands/gateways/prompts/getPrivateGatewayOrPrompt.ts
var import_errors13 = __toESM(require_dist4());
var getPrivateGatewayOrPrompt = async ({
  id,
  slug,
  sdk
}) => {
  if (id) {
    return sdk.privateGateways().get({ id });
  }
  if (slug) {
    return sdk.privateGateways().getBySlug({ slug });
  }
  const privateGateways = await sdk.privateGateways().list();
  if (privateGateways.length === 0) {
    throw new import_errors13.PrivateGatewaysNotFoundError({});
  }
  const selectedPrivateGatewayId = await selectPrompt({
    message: `${t("commonSelectXFromList", { subject: t("privateGateway") })}:`,
    choices: privateGateways.map((privateGateway) => ({
      title: `${privateGateway.name} (${privateGateway.slug})`,
      value: privateGateway.id
    }))
  });
  const matchPrivateGw = privateGateways.find(
    (privateGateway) => privateGateway.id === selectedPrivateGatewayId
  );
  if (!matchPrivateGw) return;
  return matchPrivateGw;
};

// src/commands/domains/prompts/getSiteOrPrivateGateway.ts
var getSiteOrPrivateGateway = async ({
  sdk,
  privateGatewayId,
  privateGatewaySlug,
  siteId,
  siteSlug
}) => {
  const { upperFirst } = await import("lodash-es");
  const zoneType = !privateGatewayId && !privateGatewaySlug && !siteId && !siteSlug ? await selectPrompt({
    message: `${t("selectDomainPurpose")}:`,
    choices: [
      { title: upperFirst(t("site")), value: "SITE" },
      { title: t("privateGateway"), value: "PRIVATE_GATEWAY" }
    ]
  }) : null;
  if (privateGatewayId || privateGatewaySlug || zoneType === "PRIVATE_GATEWAY") {
    const privateGateway = await getPrivateGatewayOrPrompt({
      id: privateGatewayId,
      slug: privateGatewaySlug,
      sdk
    });
    return { privateGateway };
  }
  const site = await getSiteOrPrompt({ id: siteId, slug: siteSlug, sdk });
  return { site };
};

// src/commands/domains/wait/waitForZoneCreationResult.ts
var waitForZoneCreationResult = async ({
  zone,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const checkedZone = await sdk.domains().getZone({ id: zone.id });
      return checkedZone.status === "CREATED" || checkedZone.status === "CREATING_FAILED" ? checkedZone.status : null;
    },
    period: 6e3,
    tries: 10
  });
};

// src/commands/domains/utils/getZoneForSiteOrPrivateGateway.ts
var getZoneForSiteOrPrivateGateway = async (args) => {
  if ("privateGateway" in args) {
    const {
      privateGateway: { zone: zone2 }
    } = args;
    if (!zone2) return null;
    return zone2;
  }
  const existingZones = args.site.zones?.filter(
    (zone2) => zone2.status === "CREATED"
  );
  if (existingZones?.[0]?.id) {
    return existingZones[0];
  }
  const zone = await args.sdk.domains().createZoneForSite({ siteId: args.site.id });
  const zoneCreationResult = await waitForZoneCreationResult({
    sdk: args.sdk,
    zone
  });
  if (zoneCreationResult !== "CREATED") {
    return null;
  }
  return zone;
};

// src/commands/domains/wait/waitForDomainCreationResult.ts
var waitForDomainCreationResult = async ({
  hostname,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const domain = await sdk.domains().getByHostname({ hostname });
      return domain.status === "CREATED" || domain.status === "CREATING_FAILED" ? domain.status : null;
    },
    period: 6e3,
    tries: 10
  });
};

// src/commands/domains/wait/waitForDomainVerificationResult.ts
var waitForDomainVerificationResult = async ({
  domain,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const checkedDomain = await sdk.domains().get({ domainId: domain.id });
      return checkedDomain.status === "ACTIVE" || checkedDomain.status === "VERIFYING_FAILED" ? checkedDomain.status : null;
    },
    period: 6e3,
    tries: 10
  });
};

// src/commands/domains/create.ts
var createDomainAction = async ({ sdk, args }) => {
  const { site, privateGateway } = await getSiteOrPrivateGateway({
    sdk,
    privateGatewayId: args.privateGatewayId,
    privateGatewaySlug: args.privateGatewaySlug,
    siteId: args.siteId,
    siteSlug: args.siteSlug
  });
  const hostname = await getHostnameOrPrompt({ hostname: args.hostname });
  if (site) {
    output.spinner(t("creatingNewDomainSite"));
  } else {
    output.spinner(t("creatingNewDomainGw"));
  }
  const zone = await getZoneForSiteOrPrivateGateway(
    site ? { site, sdk } : {
      privateGateway,
      sdk
    }
  );
  if (zone === null) {
    output.error(t("createDomainFailure"));
    output.printNewLine();
    return;
  }
  await sdk.domains().createDomain({ zoneId: zone.id, hostname });
  const domainCreationStatus = await waitForDomainCreationResult({
    sdk,
    hostname
  });
  if (domainCreationStatus === null) {
    output.warn(
      t("warnSubjectProcessIsLong", { subject: t("dnsConfiguration") })
    );
    output.printNewLine();
    output.log(
      `${t("commonWaitAndCheckStatusViaCmd", { subject: t("dnsConfiguration") })}:`
    );
    output.log(output.textColor(`fleek domains detail ${hostname}`, "cyan"));
    return;
  }
  if (domainCreationStatus === "CREATING_FAILED") {
    output.error(t("createDomainFailure"));
    output.printNewLine();
    return;
  }
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: `${t("domain")} ${output.quoted(hostname)}`,
      action: t("created")
    })
  );
  output.printNewLine();
  const domain = await sdk.domains().getByHostname({ hostname });
  output.log(`${t("updateDNSRecords", { hostname })}:`);
  for (const { type, value } of domain.dnsConfigs) {
    if (type === "CNAME") {
      output.log(`CNAME @ ${value.toLowerCase().replace("https://", "")}`);
    }
  }
  output.printNewLine();
  const { waitForAnyKey } = usePressAnyKey();
  while (true) {
    output.hint(
      t("commonPressAnyKeyOnceConfig", { subject: t("dnsSettings") })
    );
    await waitForAnyKey();
    output.spinner(t("commonVerifyingSubject", { subject: t("dnsSettings") }));
    await sdk.domains().verifyDomain({ domainId: domain.id });
    const verificationResultStatus = await waitForDomainVerificationResult({
      domain,
      sdk
    });
    if (!verificationResultStatus) {
      output.warn(
        t("warnSubjectProcessIsLong", { subject: t("dnsConfiguration") })
      );
      output.printNewLine();
      output.log(
        `${t("commonWaitAndCheckStatusViaCmd", { subject: t("dnsConfiguration") })}:`
      );
      output.log(output.textColor(`fleek domains detail ${hostname}`, "cyan"));
      return;
    }
    if (verificationResultStatus === "ACTIVE") {
      output.printNewLine();
      output.success(`Domain ${output.quoted(hostname)} was verified.`);
      output.printNewLine();
      return;
    }
    output.error(t("domainVerificationFailureCheckDns", { hostname }));
    output.printNewLine();
  }
};
var createDomainActionHandler = withGuards(createDomainAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/domains/prompts/getDomainOrPrompt.ts
var import_errors14 = __toESM(require_dist4());
var getDomainOrPrompt = async ({
  id,
  hostname,
  sdk,
  choicesFilter
}) => {
  if (id) {
    return sdk.domains().get({ domainId: id });
  }
  if (hostname) {
    return sdk.domains().getByHostname({ hostname });
  }
  const allDomains = await sdk.domains().list();
  const domains = choicesFilter ? allDomains.filter(choicesFilter) : allDomains;
  if (!domains.length) {
    throw new import_errors14.DomainsNotFoundError();
  }
  const selectedDomainId = await selectPrompt({
    message: `${t("selectDomain")}:`,
    choices: domains.map((domain2) => ({
      title: domain2.hostname,
      value: domain2.id
    }))
  });
  const domain = domains.find((domain2) => domain2.id === selectedDomainId);
  if (!domain) return;
  return domain;
};

// src/commands/domains/wait/waitUntilDomainDeleted.ts
var waitUntilDomainDeleted = async ({
  domain,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => sdk.domains().get({ domainId: domain.id }).then(() => false).catch(() => true),
    period: 6e3,
    tries: 10
  });
};

// src/commands/domains/delete.ts
var deleteDomainAction = async ({ sdk, args }) => {
  const domain = await getDomainOrPrompt({
    id: args.id,
    hostname: args.hostname,
    sdk
  });
  if (!domain) {
    output.error(t("expectedNotFoundGeneric", { name: "domain" }));
    return;
  }
  output.spinner(t("deletingDomain"));
  await sdk.domains().deleteDomain({ domainId: domain.id });
  const isDeleted = await waitUntilDomainDeleted({ sdk, domain });
  if (!isDeleted) {
    output.error(t("cannotDeleteDomain", { hostname: domain.hostname }));
    output.printNewLine();
    return;
  }
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: `${t("domain")} "${domain.hostname}"`,
      action: "deleted"
    })
  );
  output.printNewLine();
};
var deleteDomainActionHandler = withGuards(deleteDomainAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/domains/detail.ts
var domainCreationPending = ["CREATING", "VERIFYING"];
var domainCreationFailed = [
  "CREATING_FAILED",
  "VERIFYING_FAILED"
];
var detailDomainAction = async ({ sdk, args }) => {
  const domain = await getDomainOrPrompt({
    id: args.id,
    hostname: args.hostname,
    sdk
  });
  if (!domain) {
    output.error(t("expectedNotFoundGeneric", { name: "domain" }));
    return;
  }
  if (domainCreationPending.includes(domain.status)) {
    output.printNewLine();
    output.warn(t("domainCreationPending"));
    return;
  }
  if (domainCreationFailed.includes(domain.status)) {
    output.printNewLine();
    output.error(t("domainCreationFailed"));
    return;
  }
  output.table([
    {
      Hostname: domain.hostname,
      "Created At": domain.createdAt,
      Status: domain.status
    }
  ]);
  output.log(`${t("configDomainAsTable")}:`);
  output.table(
    domain.dnsConfigs.map(
      (domain2) => ({
        Type: domain2.type,
        Name: domain2.name,
        Value: domain2.value
      })
    )
  );
};
var detailDomainActionHandler = withGuards(detailDomainAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/domains/utils/getSiteDomains.ts
var getSiteDomains = async ({
  sdk,
  siteId
}) => {
  const site = await sdk.sites().get({ id: siteId });
  const domainsGroupedByZones = await Promise.all(
    site.zones.map((zone) => sdk.domains().listByZoneId({ zoneId: zone.id }))
  );
  return domainsGroupedByZones.flat();
};

// src/commands/domains/list.ts
var listDomainsAction = async ({ sdk, args }) => {
  const domains = args.siteId ? await getSiteDomains({ siteId: args.siteId, sdk }) : await sdk.domains().list();
  if (domains.length === 0) {
    output.mistake(t("noDomainsAssocFound"));
    return;
  }
  output.table(
    domains.map(({ hostname, createdAt, status }) => ({
      Hostname: hostname,
      "Created At": createdAt,
      Status: status
    }))
  );
};
var listDomainsActionHandler = withGuards(listDomainsAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/domains/verify.ts
var verifyDomainAction = async ({ sdk, args }) => {
  const domain = await getDomainOrPrompt({
    id: args.id,
    hostname: args.hostname,
    sdk,
    choicesFilter: (domain2) => domain2.isVerified
  });
  if (!domain) {
    output.error(t("noEnsRecordFoundUnexpectedly"));
    return;
  }
  if (domain.status === "ACTIVE") {
    output.success(t("domainAlreadyVerified", { hostname: domain.hostname }));
    output.printNewLine();
    return;
  }
  output.spinner(t("verifyingDomain"));
  await sdk.domains().verifyDomain({ domainId: domain.id });
  const verificationResultStatus = await waitForDomainVerificationResult({
    domain,
    sdk
  });
  if (!verificationResultStatus) {
    output.warn(
      t("warnSubjectProcessIsLong", {
        subject: t("processOfDomainVerification")
      })
    );
    output.printNewLine();
    output.log(
      `${t("commonWaitAndCheckStatusViaCmd", { subject: t("deploymentStatus") })}`
    );
    output.log(
      output.textColor(`fleek domains detail ${domain.hostname}`, "cyan")
    );
    return;
  }
  if (verificationResultStatus === "VERIFYING_FAILED") {
    output.printNewLine();
    output.error(
      t("domainVerificationFailureCheckDns", { hostname: domain.hostname })
    );
    output.printNewLine();
    return;
  }
  output.success(t("domainVerified", { hostname: domain.hostname }));
  output.printNewLine();
};
var verifyDomainActionHandler = withGuards(verifyDomainAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/domains/index.ts
var domains_default = (program) => {
  const cmd = program.command("domains").description(t("domainsDesc"));
  cmd.command("list").option("--siteId <string>", t("siteIDDomainAssignTo")).description(t("listAllDomainsSelectProject")).action(
    (options) => listDomainsActionHandler(options)
  );
  cmd.command("detail").option("--id <string>", t("idOfDomainForDetails")).option("--hostname <string>", t("hostnameOfDomainForDetails")).description(t("showDomainDetails")).action(
    (options) => detailDomainActionHandler(options)
  );
  cmd.command("create").option("--privateGatewayId <string>", t("idOfPvtGwToCreateDomainFor")).option("--privateGatewaySlug <string>", t("slugOfPvtGwToCreateDomainFor")).option("--siteId <string>", t("siteIdToCreateDomainFor")).option("--siteSlug <string>", t("slugCreateDomainFor")).option("--hostname <string>", t("hostnameCreateDomainFor")).description(t("createDomainForSiteOrGw")).action(
    (options) => createDomainActionHandler(options)
  );
  cmd.command("delete").option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("id"),
      subject: t("domain"),
      action: t("delete")
    })
  ).option(
    "--hostname <string>",
    t("commonNameOfSubjectToAction", {
      name: t("hostname"),
      subject: t("ens"),
      action: t("delete")
    })
  ).description(t("deleteDomain")).action(
    (options) => deleteDomainActionHandler(options)
  );
  cmd.command("verify").option("--id <string>", t("verifyDomainById")).option("--hostname <string>", t("verifyDomainByHostname")).description(t("verifyDomainConfig")).action(
    (options) => verifyDomainActionHandler(options)
  );
  return cmd;
};

// src/commands/ens/prompts/getEnsNameOrPrompt.ts
var import_errors15 = __toESM(require_dist4());
var import_utils_validation8 = __toESM(require_dist3());
var getEnsNameOrPrompt = async ({ name }) => {
  if (name) {
    if ((0, import_utils_validation8.isEnsValid)({ name })) {
      return name;
    }
    throw new import_errors15.EnsNameInvalidError({ ensRecord: { name } });
  }
  return textPrompt({
    message: `${t("ensEnterName")}:`,
    validate: (partialEns) => (0, import_utils_validation8.isEnsValid)({ name: partialEns }) || t("ensIncorrectForm")
  });
};

// src/commands/ens/prompts/getIpnsRecordOrPrompt.ts
var getIpnsRecordOrPrompt = async ({
  name,
  sdk,
  siteId
}) => {
  if (name) {
    return await sdk.ipns().getRecord({ name });
  }
  const ipnsRecords = await sdk.ipns().listRecords();
  if (!ipnsRecords.length) {
    output.spinner(t("ipnsNotLinkCreating"));
    const record2 = await sdk.ipns().createRecordForSite({ siteId });
    output.stopSpinner();
    return record2;
  }
  const selectedIpnsRecordId = await selectPrompt({
    message: `${t("ipnsSelect")}:`,
    choices: ipnsRecords.map((record2) => ({
      title: record2.name,
      value: record2.id
    }))
  });
  const record = ipnsRecords.find(
    (record2) => record2.id === selectedIpnsRecordId
  );
  if (!record) return;
  return record;
};

// src/commands/ens/wait/waitForEnsRecordCreationResult.ts
var waitForEnsRecordCreationResult = async ({
  id,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const ens = await sdk.ens().get({ id });
      return ens.status === "CREATED" || null;
    },
    period: 6e3,
    tries: 10
  });
};

// src/commands/ens/wait/waitForEnsRecordVerificationResult.ts
var waitForEnsRecordVerificationResult = async ({
  id,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const checkedEns = await sdk.ens().get({ id });
      return checkedEns.status === "ACTIVE" || checkedEns.status === "VERIFYING_FAILED" ? checkedEns.status : null;
    },
    period: 6e3,
    tries: 10
  });
};

// src/commands/ens/create.ts
var createEnsAction = async ({
  sdk,
  args
}) => {
  const site = await getSiteOrPrompt({
    id: args.siteId,
    slug: args.siteSlug,
    sdk
  });
  if (!site) {
    output.error(t("expectedNotFoundGeneric", { name: "site" }));
    return;
  }
  const ipnsRecord = await getIpnsRecordOrPrompt({
    name: args.ipns,
    sdk,
    siteId: site.id
  });
  if (!ipnsRecord) {
    output.error(t("noDomainsFoundUnexpectedly"));
    return;
  }
  const ensName = await getEnsNameOrPrompt({ name: args.name });
  output.spinner(t("ensCreatingForSelectSite"));
  const ensRecord = await sdk.ens().create({ name: ensName, siteId: site.id, ipnsRecordId: ipnsRecord.id });
  const ensCreationStatus = await waitForEnsRecordCreationResult({
    sdk,
    id: ensRecord.id
  });
  if (ensCreationStatus === null) {
    output.warn(
      t("warnSubjectProcessIsLong", {
        subject: t("processOfObtainHashForENS")
      })
    );
    output.printNewLine();
    output.log(
      `${t("commonWaitAndCheckStatusViaCmd", { subject: t("ensConf") })}`
    );
    output.log(output.textColor(`fleek ens detail ${ensName}`, "cyan"));
    return;
  }
  output.printNewLine();
  output.success(t("commonNameCreateSuccess", { name: `ENS "${ensName}"` }));
  output.printNewLine();
  output.hint(t("ensFollowLinkUpdateRec", { ipnsRecordName: ipnsRecord.name }));
  output.link(`https://app.ens.domains/${ensName}?tab=records`);
  output.printNewLine();
  const { waitForAnyKey } = usePressAnyKey();
  while (true) {
    output.log(t("ensPressAnyKeyOnceENSConfig"));
    await waitForAnyKey();
    output.spinner(t("ensVerifying"));
    await sdk.ens().verify({ id: ensRecord.id });
    const verificationResultStatus = await waitForEnsRecordVerificationResult({
      id: ensRecord.id,
      sdk
    });
    if (!verificationResultStatus) {
      output.warn(
        t("warnSubjectProcessIsLong", {
          subject: t("processOfENSVerification")
        })
      );
      output.printNewLine();
      output.log(
        `${t("commonWaitAndCheckStatusViaCmd", { subject: t("ensConf") })}`
      );
      output.log(output.textColor(`fleek ens detail ${ensName}`, "cyan"));
      return;
    }
    if (verificationResultStatus === "ACTIVE") {
      output.success(t("ensVerified", { ensName }));
      output.printNewLine();
      return;
    }
    output.error(t("ensCouldNotVerifyCheckURL", { ensRecordName: ensName }));
    output.printNewLine();
  }
};
var createEnsActionHandler = withGuards(createEnsAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ens/prompts/getEnsRecordOrPrompt.ts
var import_errors16 = __toESM(require_dist4());
var getEnsRecordOrPrompt = async ({
  id,
  name,
  sdk,
  choicesFilter
}) => {
  if (id) {
    return await sdk.ens().get({ id });
  }
  if (name) {
    return await sdk.ens().getByName({ name });
  }
  const allEnsRecords = await sdk.ens().list();
  const ensRecords = choicesFilter ? allEnsRecords.filter(choicesFilter) : allEnsRecords;
  if (ensRecords.length === 0) {
    throw new import_errors16.EnsRecordNotFoundError({ ensRecord: {} });
  }
  const selectedEnsRecordId = await selectPrompt({
    message: `${t("commonSelectXFromList", { subject: t("ensRecord") })}`,
    choices: ensRecords.map((ens) => ({ title: ens.name, value: ens.id }))
  });
  const record = ensRecords.find((ens) => ens.id === selectedEnsRecordId);
  return record;
};

// src/commands/ens/wait/waitUntilEnsRecordDeleted.ts
var waitUntilEnsRecordDeleted = async ({
  ensRecord,
  sdk
}) => {
  return checkPeriodicallyUntil({
    conditionFn: async () => sdk.ens().get({ id: ensRecord.id }).then(() => false).catch(() => true),
    period: 6e3,
    tries: 10
  });
};

// src/commands/ens/delete.ts
var deleteEnsAction = async ({ sdk, args }) => {
  const ensRecord = await getEnsRecordOrPrompt({
    id: args.id,
    name: args.name,
    sdk
  });
  if (!ensRecord) {
    output.error(t("expectedNotFoundGeneric", { name: "ENS record" }));
    return;
  }
  output.spinner(t("ensDeleting"));
  await sdk.ens().delete({ id: ensRecord.id });
  const isDeleted = await waitUntilEnsRecordDeleted({ sdk, ensRecord });
  if (!isDeleted) {
    output.error(t("ensCannotDelete", { ensRecordName: ensRecord.name }));
    return;
  }
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: `${t("ens")} "${ensRecord.name}"`,
      action: t("deleted")
    })
  );
};
var deleteEnsActionHandler = withGuards(deleteEnsAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ens/detail.ts
var detailEnsRecordsAction = async ({ sdk, args }) => {
  const ensRecord = await getEnsRecordOrPrompt({
    id: args.id,
    name: args.name,
    sdk
  });
  if (!ensRecord) {
    output.error(t("expectedNotFoundGeneric", { name: "ENS Record" }));
    return;
  }
  output.table([
    {
      ENS: ensRecord.name,
      Status: ensRecord.status,
      "Created At": ensRecord.createdAt
    }
  ]);
  output.log(`${t("ensConfigAsTable")}:`);
  output.table([
    {
      Name: "Content Hash",
      Value: `ipns://${ensRecord.ipnsRecord.name}`
    }
  ]);
};
var detailEnsRecordsActionHandler = withGuards(
  detailEnsRecordsAction,
  {
    scopes: {
      authenticated: true,
      project: true,
      site: false
    }
  }
);

// src/commands/ens/utils/getSiteEnsRecords.ts
var getSiteEnsRecords = async ({
  sdk,
  ...args
}) => {
  const site = await sdk.sites().get({ id: args.site.id });
  const ensRecordsGroupedByIpns = await Promise.all(
    site.ipnsRecords.map(
      (ipnsRecord) => sdk.ens().listByIpnsRecordId({ ipnsRecordId: ipnsRecord.id })
    )
  );
  return ensRecordsGroupedByIpns.flat();
};

// src/commands/ens/list.ts
var listEnsRecordsAction = async ({ sdk, args }) => {
  const ensRecords = args.siteId ? await getSiteEnsRecords({ site: { id: args.siteId }, sdk }) : await sdk.ens().list();
  if (ensRecords.length === 0) {
    output.log(t("noENSNames"));
    return;
  }
  output.table(
    ensRecords.map(({ name, createdAt, status }) => ({
      ENS: name,
      Status: status,
      "Created At": createdAt
    }))
  );
};
var listEnsRecordsActionHandler = withGuards(listEnsRecordsAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ens/verify.ts
var verifyEnsRecordAction = async ({ sdk, args }) => {
  const ensRecord = await getEnsRecordOrPrompt({
    id: args.id,
    name: args.name,
    sdk,
    choicesFilter: (ens) => ens.status !== "ACTIVE"
  });
  if (!ensRecord) {
    output.error(t("noEnsRecordFoundUnexpectedly"));
    return;
  }
  if (ensRecord.status === "ACTIVE") {
    output.success(
      t("ensRecordNameAlreadyVerif", { ensRecordName: ensRecord.name })
    );
    output.printNewLine();
    return;
  }
  output.spinner(t("ensVerifying"));
  await sdk.ens().verify({ id: ensRecord.id });
  const verificationResultStatus = await waitForEnsRecordVerificationResult({
    id: ensRecord.id,
    sdk
  });
  if (!verificationResultStatus) {
    output.warn(
      t("warnSubjectProcessIsLong", { subject: t("processOfENSVerification") })
    );
    output.printNewLine();
    output.log(
      `${t("commonWaitAndCheckStatusViaCmd", { subject: t("ensConf") })}:`
    );
    output.log(output.textColor(`fleek ens detail ${ensRecord.name}`, "cyan"));
    return;
  }
  if (verificationResultStatus === "VERIFYING_FAILED") {
    output.error(
      t("ensCouldNotVerifyCheckURL", { ensRecordName: ensRecord.name })
    );
    output.printNewLine();
    return;
  }
  output.success(t("ensNameVerified", { ensRecordName: ensRecord.name }));
  output.printNewLine();
};
var verifyEnsRecordActionHandler = withGuards(verifyEnsRecordAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ens/index.ts
var ens_default = (program) => {
  const cmd = program.command("ens").description(t("ensCmdDescription"));
  cmd.command("create").option("--siteId <string>", t("siteIdOf")).option("--siteSlug <string>", t("siteSlugOf")).option("--name <string>", t("ensCreateName")).option("--ipnsName <string>", t("ensIPNSNameToLink")).description(t("ensCreateRecord")).action(
    (options) => createEnsActionHandler(options)
  );
  cmd.command("detail").option(
    "--id <string>",
    t("nameOfSubjectForDetails", { name: t("id"), subject: t("ens") })
  ).option(
    "--name <string>",
    t("nameOfSubjectForDetails", { name: t("name"), subject: t("ens") })
  ).description(t("ensShowDetails")).action(
    (options) => detailEnsRecordsActionHandler(options)
  );
  cmd.command("list").option("--siteId <string>", t("siteIdOf")).description(t("ensListAllForProject")).action(
    (options) => listEnsRecordsActionHandler(options)
  );
  cmd.command("delete").option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("id"),
      subject: t("ens"),
      action: t("delete")
    })
  ).option(
    "--name <string>",
    t("commonNameOfSubjectToAction", {
      name: t("name"),
      subject: t("ens"),
      action: t("delete")
    })
  ).description(t("ensDelete")).action(
    (options) => deleteEnsActionHandler(options)
  );
  cmd.command("verify").option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("id"),
      subject: t("ens"),
      action: t("verify")
    })
  ).option(
    "--name <string>",
    t("commonNameOfSubjectToAction", {
      name: t("name"),
      subject: t("ens"),
      action: t("verify")
    })
  ).description(t("ensVerifyIsConfig")).action(
    (options) => verifyEnsRecordActionHandler(options)
  );
  return cmd;
};

// src/commands/functions/prompts/getFunctionNameOrPrompt.ts
var import_errors17 = __toESM(require_dist4());
var import_utils_validation10 = __toESM(require_dist3());

// src/commands/functions/prompts/enterFunctionNamePrompt.ts
var import_utils_validation9 = __toESM(require_dist3());
var enterFunctionNamePrompt = async () => textPrompt({
  message: `${t("typeNewFunctionName")}:`,
  validate: (partialName) => (0, import_utils_validation9.isFunctionNameValid)({ name: partialName }) || t("functionInvalidName")
});

// src/commands/functions/prompts/getFunctionNameOrPrompt.ts
var getFunctionNameOrPrompt = async ({
  name
}) => {
  if (name && (0, import_utils_validation10.isFunctionNameValid)({ name })) {
    return name;
  }
  if (name && !(0, import_utils_validation10.isFunctionNameValid)({ name })) {
    throw new import_errors17.FleekFunctionNameNotValidError({ name });
  }
  return enterFunctionNamePrompt();
};

// src/commands/functions/utils/isSiteIdValid.ts
var isSiteIdValid = async ({
  siteId,
  sdk
}) => {
  try {
    await sdk.sites().get({ id: siteId });
    return true;
  } catch {
    return false;
  }
};

// src/commands/functions/create.ts
var createAction = async ({
  args,
  sdk
}) => {
  const { name, siteId } = args;
  const functionName = await getFunctionNameOrPrompt({ name });
  if (siteId && !await isSiteIdValid({ siteId, sdk })) {
    output.error(t("siteNotFound"));
    return;
  }
  const newFunction = await sdk.functions().create({
    name: functionName,
    siteId
  });
  output.printNewLine();
  output.success(t("commonNameCreateSuccess", { name: "function" }));
  output.printNewLine();
  if (!newFunction.currentDeploymentId) {
    output.log(t("youCanDoXUsingFolCmd", { action: t("deployNewFunction") }));
    output.log("fleek functions deploy");
  }
};
var createActionHandler = withGuards(createAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/prompts/getFunctionOrPrompt.ts
var import_errors18 = __toESM(require_dist4());
var getFunctionOrPrompt = async ({
  name,
  sdk
}) => {
  if (name) {
    return sdk.functions().get({ name });
  }
  const functions = await sdk.functions().list();
  if (!functions.length) {
    throw new import_errors18.FleekFunctionsNotFoundError({});
  }
  const selectedFunctionId = await selectPrompt({
    message: t("commonSelectXFromList", { subject: t("function") }),
    choices: functions.map((f) => ({ title: f.name, value: f.id }))
  });
  const fnMatch = functions.find((f) => f.id === selectedFunctionId);
  if (!fnMatch) return;
  return fnMatch;
};

// src/commands/functions/delete.ts
var deleteAction = async ({
  sdk,
  args
}) => {
  const functionToDelete = await getFunctionOrPrompt({ name: args.name, sdk });
  if (!functionToDelete) {
    output.error(t("expectedNotFoundGeneric", { name: "function" }));
    return;
  }
  await sdk.functions().delete({ id: functionToDelete.id });
  output.printNewLine();
  output.success(t("commonNameDeleteSuccess", { name: "function" }));
  output.printNewLine();
};
var deleteActionHandler = withGuards(deleteAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/deploy.ts
var import_node_fs9 = __toESM(require("node:fs"));
var import_cli_progress3 = __toESM(require("cli-progress"));

// src/utils/blake3.ts
var import_promises = __toESM(require("node:fs/promises"));
var import_hash_wasm = require("hash-wasm");
var calculateBlake3Hash = async ({
  filePath,
  onFailure
}) => {
  try {
    const buffer = await import_promises.default.readFile(filePath);
    return await (0, import_hash_wasm.blake3)(buffer);
  } catch {
    if (typeof onFailure === "function") {
      onFailure();
    }
  }
};

// src/commands/functions/prompts/getFunctionPathOrPrompt.ts
var import_errors19 = __toESM(require_dist4());
var import_utils_validation11 = __toESM(require_dist3());
var isValidPath = async (path3) => await (0, import_utils_validation11.isFunctionPathValid)({ fileOrFolderPath: path3 });
var getFunctionPathOrPrompt = async ({
  path: path3
}) => {
  let result = path3;
  if (!result) {
    const p = await textPrompt({
      message: t("typeFunctionCodePath"),
      validate: (path4) => (0, import_utils_validation11.isFunctionPathValid)({ fileOrFolderPath: path4 }) || t("filePathValidWarning")
    });
    result = p;
  }
  const hasValidPath = await isValidPath(result);
  if (!hasValidPath) {
    throw new import_errors19.FleekFunctionPathNotValidError({ path: result });
  }
  const isFolder = await (0, import_utils_validation11.isValidFolder)(result);
  if (isFolder) {
    return `${result}/index.js`;
  }
  return result;
};

// src/commands/functions/utils/getJsCodeFromPath.ts
var fs7 = __toESM(require("node:fs"));
var os = __toESM(require("node:os"));
var import_errors20 = __toESM(require_dist4());
var import_cli_progress = __toESM(require("cli-progress"));
var import_esbuild = require("esbuild");
var import_files_from_path = require("files-from-path");
var showUnsupportedModules = (args) => {
  const unsupportedModulesUsed = Array.from(args.unsupportedModulesUsed);
  if (unsupportedModulesUsed.length) {
    output.printNewLine();
    for (const packageName of unsupportedModulesUsed) {
      output.mistake(t("unsupportedPackage", { packageName }));
    }
    output.log(t("showUnsupportedModulesDocLink"));
    output.link("https://fleek.xyz/docs");
    output.printNewLine();
  }
};
var transpileCode = async (args) => {
  const {
    createFleekBuildConfig,
    nodeProtocolImportSpecifier,
    moduleChecker,
    unsupportedRuntimeModules
  } = await import("@fleek-platform/functions-esbuild-config");
  const { filePath, bundle, env, assetsCid } = args;
  const progressBar = new import_cli_progress.default.SingleBar(
    {
      format: t("uploadProgress", {
        action: t(bundle ? "bundlingCode" : "transformingCode")
      })
    },
    import_cli_progress.default.Presets.shades_grey
  );
  let tempDir;
  if (!output.debugEnabled) {
    tempDir = os.tmpdir();
  } else {
    tempDir = ".fleek";
    if (!fs7.existsSync(tempDir)) {
      fs7.mkdirSync(tempDir);
    }
  }
  const outFile = `${tempDir}/function.js`;
  const unsupportedModulesUsed = /* @__PURE__ */ new Set();
  const plugins = [
    moduleChecker({
      unsupportedModulesUsed: new Set(unsupportedRuntimeModules)
    }),
    {
      name: "ProgressBar",
      setup: (build2) => {
        build2.onStart(() => {
          progressBar.start(100, 10);
        });
      }
    }
  ];
  if (bundle) {
    plugins.push(
      nodeProtocolImportSpecifier({
        // Handle the error gracefully
        onError: () => output.error(t("failedToApplyNodeImportProtocol"))
      })
    );
  }
  let adaptedEnv = env;
  if (assetsCid) {
    adaptedEnv = {
      ...env,
      ASSETS_CID: assetsCid
    };
  }
  const buildConfig = createFleekBuildConfig({
    filePath,
    bundle,
    env: adaptedEnv
  });
  try {
    await (0, import_esbuild.build)({
      ...buildConfig,
      outfile: outFile,
      plugins,
      minify: !!bundle
    });
    progressBar.update(100);
    progressBar.stop();
  } catch (e) {
    progressBar.stop();
    const errorMessage = e && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : t("unknownTransformError");
    const transpileResponse2 = {
      path: filePath,
      unsupportedModules: unsupportedModulesUsed,
      success: false,
      error: errorMessage
    };
    return transpileResponse2;
  }
  const transpileResponse = {
    path: outFile,
    unsupportedModules: unsupportedModulesUsed,
    success: true
  };
  return transpileResponse;
};
var getFileLikeObject = async (path3) => {
  const files = await (0, import_files_from_path.filesFromPaths)([path3]);
  if (!files.length) {
    throw new import_errors20.FleekFunctionPathNotValidError({ path: path3 });
  }
  return files[0];
};
var checkUserSourceCodeSupport = async (filePath) => {
  const reRequireSyntax = /require\s*\([^)]*\)/g;
  const buffer = await fs7.promises.readFile(filePath);
  const contents = buffer.toString();
  return reRequireSyntax.test(contents);
};
var getJsCodeFromPath = async (args) => {
  const { filePath, bundle, env, assetsCid } = args;
  if (!fs7.existsSync(filePath)) {
    throw new import_errors20.FleekFunctionPathNotValidError({ path: filePath });
  }
  const isUserSourceCodeSupported = await checkUserSourceCodeSupport(filePath);
  if (isUserSourceCodeSupported) {
    output.error(t("requireDeprecatedUseES6Syntax"));
  }
  const transpileResponse = await transpileCode({
    filePath,
    bundle,
    env,
    assetsCid
  });
  showUnsupportedModules({
    unsupportedModulesUsed: transpileResponse.unsupportedModules
  });
  if (!transpileResponse.success) {
    if (!transpileResponse.error) {
      throw new import_errors20.UnknownError();
    }
    throw new import_errors20.FleekFunctionBundlingFailedError({
      error: transpileResponse.error
    });
  }
  return transpileResponse.path;
};

// src/commands/functions/utils/parseEnvironmentVariables.ts
var import_node_fs8 = __toESM(require("node:fs"));
var import_dotenv = __toESM(require("dotenv"));
var parseEnvironmentVariablesFile = (args) => {
  const { envFile } = args;
  if (!import_node_fs8.default.statSync(envFile).isFile()) {
    output.mistake(t("filePathNotFound", { envFile }));
    return {};
  }
  try {
    const envFileContent = import_node_fs8.default.readFileSync(envFile);
    const config2 = import_dotenv.default.parse(envFileContent);
    return config2;
  } catch (err) {
    output.mistake(t("envFileParseError", { envFile }));
    return {};
  }
};
var parseEnvironmentVariables = (args) => {
  const { env } = args;
  return env.reduce((acc, curr) => {
    const [key, value] = curr.split("=");
    let varValue = value;
    if (!varValue) {
      const envValue = process.env[key];
      if (!envValue) {
        output.mistake(t("missingEnvVar", { key }));
        return acc;
      }
      varValue = envValue;
    }
    acc[key] = varValue;
    return acc;
  }, {});
};
var getEnvironmentVariables = (args) => {
  const { env, envFile } = args;
  const environmentVariables = parseEnvironmentVariables({ env });
  let envFileContent = {};
  if (envFile) {
    envFileContent = parseEnvironmentVariablesFile({ envFile });
  }
  return { ...envFileContent, ...environmentVariables };
};

// src/output/utils/uploadOnProgress.ts
var uploadOnProgress = (progressBar) => {
  return ({
    loadedSize,
    totalSize
  }) => {
    if (loadedSize === 0) {
      progressBar.start(totalSize ?? loadedSize, loadedSize);
    } else if (loadedSize === totalSize) {
      progressBar.update(loadedSize);
      progressBar.stop();
    } else {
      progressBar.update(loadedSize);
    }
  };
};

// src/commands/functions/utils/upload.ts
var getUploadResult = async ({
  filePath,
  functionName,
  isPrivate,
  progressBar,
  sdk,
  onFailure
}) => {
  try {
    if (isPrivate) {
      return await sdk.storage().uploadPrivateFile({
        filePath,
        onUploadProgress: uploadOnProgress(progressBar)
      });
    }
    const fileLikeObject = await getFileLikeObject(filePath);
    return await sdk.storage().uploadFile({
      file: fileLikeObject,
      options: { functionName },
      onUploadProgress: uploadOnProgress(progressBar)
    });
  } catch {
    if (typeof onFailure === "function") {
      onFailure();
    }
  }
  return;
};

// src/commands/functions/wait/waitUntilFileAvailable.ts
var waitUntilFileAvailable = async ({
  cid
}) => {
  const timeout = 1e4;
  const gatewayPatterns = [
    "https://{cid}.ipfs.dweb.link",
    "https://{cid}.ipfs.w3s.link",
    "https://{cid}.ipfs.flk-ipfs.xyz",
    "https://ipfs.io/ipfs/{cid}",
    "https://fleek.ipfs.io/ipfs/{cid}"
  ];
  const createUrlPromises = () => gatewayPatterns.map((pattern) => {
    const url = pattern.replace(/\{(\w+)\}/g, cid);
    const fetchPromise = fetch(url).then((response) => {
      if (!response.ok) {
        throw new Error(`Request failed for ${url}`);
      }
      return response;
    });
    const timeoutPromise = new Promise(
      (_, reject) => setTimeout(
        () => reject(new Error(`timeout fetching content from ${url}`)),
        timeout
      )
    );
    return Promise.race([fetchPromise, timeoutPromise]);
  });
  return checkPeriodicallyUntil({
    conditionFn: async () => {
      const urlPromises = createUrlPromises();
      try {
        await Promise.any(urlPromises);
        return true;
      } catch {
        return false;
      }
    },
    period: 6e3,
    tries: 50
  });
};

// src/commands/functions/utils/getWasmCodeFromPath.ts
var fs9 = __toESM(require("node:fs"));
var os2 = __toESM(require("node:os"));
var import_errors21 = __toESM(require_dist4());
var import_cli_progress2 = __toESM(require("cli-progress"));
var import_eciesjs = require("eciesjs");
var PUBLIC_KEY = "02de6500ea852d2f4bdc9b6812ac76477e45eae556998d357cfa84e5a0a71bddb4";
var getWasm = async (filePath) => {
  const buffer = await fs9.promises.readFile(filePath);
  if (buffer.length < 8) {
    return null;
  }
  const wasmMagicNumber = [0, 97, 115, 109];
  for (let i = 0; i < 4; i++) {
    if (buffer[i] !== wasmMagicNumber[i]) {
      return null;
    }
  }
  return buffer;
};
var enryptCode = async (args) => {
  const { filePath } = args;
  const buffer = await getWasm(filePath);
  if (!buffer) {
    output.error(t("invalidWasmCode", { path: filePath }));
    throw new import_errors21.FleekFunctionInvalidWasmCodeError({});
  }
  const progressBar = new import_cli_progress2.default.SingleBar(
    {
      format: t("uploadProgress", {
        action: t("encryptingCode")
      })
    },
    import_cli_progress2.default.Presets.shades_grey
  );
  let tempDir;
  if (!output.debugEnabled) {
    tempDir = os2.tmpdir();
  } else {
    tempDir = ".fleek";
    if (!fs9.existsSync(tempDir)) {
      fs9.mkdirSync(tempDir);
    }
  }
  const outFile = `${tempDir}/function.wasm`;
  progressBar.start(100, 10);
  try {
    const encryptedData = (0, import_eciesjs.encrypt)(PUBLIC_KEY, buffer);
    progressBar.update(50);
    await fs9.promises.writeFile(outFile, encryptedData);
  } catch (error) {
    progressBar.stop();
    throw new import_errors21.FleekFunctionWasmEncryptionFailedError({});
  }
  progressBar.update(100);
  progressBar.stop();
  return outFile;
};
var getWasmCodeFromPath = async (args) => {
  const { filePath } = args;
  if (!fs9.existsSync(filePath)) {
    throw new import_errors21.FleekFunctionPathNotValidError({ path: filePath });
  }
  return enryptCode({ filePath });
};

// src/commands/functions/utils/uploadFunctionAssets.ts
var import_utils_validation12 = __toESM(require_dist3());
var uploadFunctionAssets = async ({
  sdk,
  assetsPath,
  functionName
}) => {
  if (!assetsPath) {
    return;
  }
  if (!await (0, import_utils_validation12.isValidFolder)(assetsPath)) {
    output.error(t("assetsPathIsNotAFolder"));
    return;
  }
  try {
    output.spinner(t("uploadingAssets"));
    const result = await sdk.storage().uploadDirectory({
      path: assetsPath,
      options: {
        functionName
      }
    });
    output.success(t("assetsUploadSuccess"));
    return result.pin.cid;
  } catch (error) {
    output.error(t("uploadAssetsFailed"));
    throw error;
  }
};

// src/commands/functions/deploy.ts
var deployAction = async ({
  sdk,
  args
}) => {
  const env = getEnvironmentVariables({ env: args.env, envFile: args.envFile });
  const functionToDeploy = await getFunctionOrPrompt({ name: args.name, sdk });
  const filePath = await getFunctionPathOrPrompt({ path: args.filePath });
  const assetsPath = args.assetsPath;
  const bundle = args.bundle !== "false";
  const isSGX = !!args.sgx;
  const isTrustedPrivateEnvironment = isSGX && args.private;
  const isUntrustedPublicEnvironment = !isSGX && !args.private;
  if (isTrustedPrivateEnvironment) {
    output.error(t("pvtFunctionInSgxNotSupported", { name: "function" }));
    return;
  }
  if (!functionToDeploy) {
    output.error(t("expectedNotFoundGeneric", { name: "function" }));
    return;
  }
  if (assetsPath && isSGX) {
    output.error(t("assetsNotSupportedInSgx"));
    return;
  }
  const assetsCid = await uploadFunctionAssets({
    sdk,
    assetsPath,
    functionName: functionToDeploy.name
  });
  const updatedEnv = {
    FLEEK_URL: functionToDeploy.invokeUrl,
    ...env
  };
  const filePathToUpload = isSGX ? await getWasmCodeFromPath({ filePath }) : await getJsCodeFromPath({
    filePath,
    bundle,
    env: updatedEnv,
    assetsCid
  });
  output.printNewLine();
  const progressBar = new import_cli_progress3.default.SingleBar(
    {
      format: t("uploadProgress", { action: t("uploadCodeToIpfs") })
    },
    import_cli_progress3.default.Presets.shades_grey
  );
  const uploadResult = await getUploadResult({
    filePath: filePathToUpload,
    functionName: functionToDeploy.name,
    isPrivate: args.private,
    progressBar,
    sdk,
    onFailure: () => {
      progressBar.stop();
    }
  });
  if (!uploadResult) {
    output.error(
      t("commonFunctionActionFailure", {
        action: "deploy",
        tryAgain: t("tryAgain"),
        message: t("uploadToIpfsFailed")
      })
    );
    return;
  }
  const blake3Hash = isSGX ? await calculateBlake3Hash({
    filePath: filePathToUpload,
    onFailure: () => {
      output.error(t("failedCalculateBlake3Hash"));
      process.exit(1);
    }
  }) : void 0;
  if (!output.debugEnabled && !args.bundle) {
    import_node_fs9.default.rmSync(filePathToUpload);
  }
  if (!uploadResult.pin.cid) {
    output.error(
      t("commonFunctionActionFailure", {
        action: "deploy",
        tryAgain: t("tryAgain"),
        message: t("uploadToIpfsFailed")
      })
    );
    return;
  }
  if (uploadResult.duplicate && functionToDeploy.currentDeployment && uploadResult.pin && functionToDeploy.currentDeployment.cid === uploadResult.pin.cid) {
    output.chore(t("noChangesDetected"));
    return;
  }
  if (!args.private) {
    output.printNewLine();
    output.spinner(t("runningAvailabilityCheck"));
    const isAvailable = await waitUntilFileAvailable({
      cid: uploadResult.pin.cid
    });
    if (!isAvailable) {
      output.error(t("availabilityCheckFailed"));
      return;
    }
  }
  try {
    await sdk.functions().deploy({
      functionId: functionToDeploy.id,
      cid: uploadResult.pin.cid,
      sgx: isSGX,
      blake3Hash,
      assetsCid
    });
  } catch {
    output.error(t("failedDeployFleekFunction"));
    process.exit(1);
  }
  if (isSGX) {
    output.spinner(t("networkFetchMappings"));
    try {
      await fetch(
        `https://fleek-test.network/services/0/ipfs/${uploadResult.pin.cid}`
      );
    } catch {
      output.error(t("networkFetchFailed"));
      return;
    }
  }
  output.success(t("commonNameCreateSuccess", { name: "deployment" }));
  output.printNewLine();
  output.log(t("callFleekFunctionByUrlReq"));
  output.link(functionToDeploy.invokeUrl);
  if (isSGX) {
    output.log(t("callFleekFunctionByNetworkUrlReq"));
    output.link("https://fleek-test.network/services/3");
    output.printNewLine();
    output.log(`Blake3 Hash: ${blake3Hash} `);
    output.log(
      `Invoke by sending request to https://fleek-test.network/services/3 with payload of {hash: <Blake3Hash>, decrypt: true, inputs: "foo"}`
    );
    output.printNewLine();
    output.hint(`Here's an example:`);
    output.link(
      `curl ${functionToDeploy.invokeUrl} --data '{"hash": "${blake3Hash}", "decrypt": true, "input": "foo"}'`
    );
  }
  if (isUntrustedPublicEnvironment) {
    output.log(t("callFleekFunctionByNetworkUrlReq"));
    output.link(
      `https://fleek-test.network/services/1/ipfs/${uploadResult.pin.cid}`
    );
  }
};
var deployActionHandler = withGuards(deployAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/list.ts
var listAction = async ({ sdk }) => {
  const functions = await sdk.functions().list();
  if (!functions?.length) {
    output.warn(t("noYYet", { name: "functions" }));
    output.log(t("youCanDoXUsingFolCmd", { action: t("createNewFunction") }));
    output.log("fleek functions create");
    return;
  }
  output.table(
    functions.map((f) => ({
      ID: f.id,
      Name: f.name,
      Slug: f.slug,
      InvokeUrl: f.invokeUrl,
      Status: f.status
    }))
  );
};
var listActionHandler = withGuards(listAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/listDeployments.ts
var listDeploymentsAction = async ({ sdk, args }) => {
  const functionToList = await getFunctionOrPrompt({ sdk, name: args.name });
  if (!functionToList) {
    output.error(t("expectedNotFoundGeneric", { name: "function" }));
    return;
  }
  const deployments = await sdk.functions().listDeployments({ functionId: functionToList.id });
  if (!deployments?.length) {
    output.warn(t("noYYet", { name: "deployments" }));
    output.log(t("youCanDoXUsingFolCmd", { action: t("deployNewFunction") }));
    output.log("fleek functions deploy");
    return;
  }
  output.table(
    deployments.map((d) => ({
      ID: d.id,
      CID: d.cid,
      "Created At": d.createdAt
    }))
  );
};
var listDeploymentsActionHandler = withGuards(listDeploymentsAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/prompts/getFunctionSlugOrPrompt.ts
var import_errors22 = __toESM(require_dist4());
var import_utils_validation13 = __toESM(require_dist3());
var getFunctionSlugOrPrompt = async ({
  slug
}) => {
  if (slug && (0, import_utils_validation13.isFunctionSlugValid)({ slug })) {
    return slug;
  }
  if (!slug) return;
  throw new import_errors22.FleekFunctionSlugNotValidError({ slug });
};

// src/commands/functions/prompts/getFunctionStatusOrPrompt.ts
var import_errors23 = __toESM(require_dist4());
var import_utils_validation14 = __toESM(require_dist3());
var getFunctionStatusOrPrompt = async ({
  status
}) => {
  if (status && (0, import_utils_validation14.isFunctionStatusValid)({ status })) {
    return status;
  }
  throw new import_errors23.FleekFunctionStatusNotValidError({});
};

// src/commands/functions/update.ts
var updateAction = async ({
  args,
  sdk
}) => {
  if (!args.name && !args.slug && !args.status) {
    output.error(
      t("functionUpdateArgsNotValid", {
        param1: "name",
        param2: "slug",
        param3: "status"
      })
    );
    return;
  }
  const name = args.name ? await getFunctionNameOrPrompt({ name: args.name }) : void 0;
  const slug = args.slug ? await getFunctionSlugOrPrompt({ slug: args.slug }) : void 0;
  const status = args.status ? await getFunctionStatusOrPrompt({ status: args.status }) : void 0;
  const fleekFunction = await getFunctionOrPrompt({
    name: args.functionName,
    sdk
  });
  if (!fleekFunction) {
    output.error(t("expectedNotFoundGeneric", { name: "function" }));
    return;
  }
  await sdk.functions().update({ id: fleekFunction.id, slug, status, name });
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: t("function"),
      action: t("updated")
    })
  );
  output.printNewLine();
};
var updateActionHandler = withGuards(updateAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/functions/index.ts
var functions_default = (program) => {
  const cmd = program.command("functions").description(t("functionsDescription"));
  cmd.command("create").option("-n, --name <functionName>", t("functionName")).option("--site <siteId>", t("functionsSite")).description(t("functionsCreateDescription")).action(
    (options) => createActionHandler({ name: options.name, siteId: options.site })
  );
  cmd.command("delete").description(t("functionsDeleteDescription")).option("-n, --name <functionName>", t("functionName")).action(
    (options) => deleteActionHandler({ name: options.name })
  );
  cmd.command("update").description(t("functionsUpdateDescription")).option("-n, --functionName <functionName>", t("functionName")).option("--name <newName>", t("functionName")).option("--slug <newSlug>", t("functionSlug")).option("--status <newStatus>", t("functionStatus")).action(
    (options) => updateActionHandler({
      functionName: options.functionName,
      name: options.name,
      slug: options.slug,
      status: options.status
    })
  );
  cmd.command("deploy").description(t("deployFunction")).option("-p, --path <functionCodePath>", t("functionCodePath")).option("-n, --name <functionName>", t("functionName")).option("-b, --bundle <bundle>", t("bundleCmd"), true).option("--private", t("functionDeployToPrivateStorage"), false).option("-e, --env <environmentVariables...>", t("environmentVariables")).option("--sgx", t("functionsUseSgx"), false).option("-a --assets <assetsPath>", t("functionsUseAssets"), false).option(
    "--envFile <environmentVariablesFilePath>",
    t("environmentVariablesFile")
  ).action(
    (options) => deployActionHandler({
      filePath: options.path,
      name: options.name,
      bundle: options.bundle,
      private: options.private,
      env: options.env ?? [],
      envFile: options.envFile,
      sgx: options.sgx,
      assetsPath: options.assets
    })
  );
  cmd.command("list").description(t("listFunctionsDesc")).action(() => listActionHandler());
  cmd.command("deployments").option("-n, --name <functionName>", t("functionName")).description(t("deploymentsListForSelectedFunction")).action(
    (options) => listDeploymentsActionHandler(options)
  );
  return cmd;
};

// src/commands/gateways/prompts/getPrivateGatewayNameOrPrompt.ts
var import_errors24 = __toESM(require_dist4());
var import_utils_validation15 = __toESM(require_dist3());
var getPrivateGatewayNameOrPrompt = async ({
  name
}) => {
  if (name && (0, import_utils_validation15.isPrivateGatewayNameValid)({ name })) {
    return name;
  }
  if (name && !(0, import_utils_validation15.isPrivateGatewayNameValid)({ name })) {
    throw new import_errors24.PrivateGatewayNameInvalidError({ name });
  }
  return textPrompt({
    message: t("gatewayEnterName"),
    validate: (partialName) => (0, import_utils_validation15.isPrivateGatewayNameValid)({ name: partialName }) || t("gatewayNameIncorrectForm")
  });
};

// src/commands/gateways/create.ts
var createPrivateGatewayAction = async ({ sdk, args }) => {
  const name = await getPrivateGatewayNameOrPrompt({ name: args.name });
  output.spinner(`${t("creatingNewGateway")}...`);
  const zone = await sdk.domains().createZoneForPrivateGateway();
  const zoneCreationResult = await waitForZoneCreationResult({ sdk, zone });
  if (zoneCreationResult !== "CREATED") {
    output.error(t("gatewayNotCreated"));
    output.printNewLine();
    return;
  }
  const privateGateway = await sdk.privateGateways().create({ name, zoneId: zone.id });
  output.printNewLine();
  output.success(
    t("commonNameCreateSuccess", { name: `${t("privateGateway")} "${name}"` })
  );
  output.printNewLine();
  await createDomainAction({
    sdk,
    args: { privateGatewayId: privateGateway.id }
  });
};
var createPrivateGatewayActionHandler = withGuards(
  createPrivateGatewayAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/gateways/delete.ts
var deletePrivateGatewayAction = async ({ sdk, args }) => {
  const privateGateway = await getPrivateGatewayOrPrompt({
    sdk,
    id: args.id,
    slug: args.slug
  });
  if (!privateGateway) {
    output.error(t("noPrivateGatewaysFoundUnexpectedly"));
    return;
  }
  output.spinner(t("deletingGateway"));
  await sdk.privateGateways().delete({ id: privateGateway.id });
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: `${t("privateGateway")} "${privateGateway.name}"`,
      action: t("deleted")
    })
  );
};
var deletePrivateGatewayActionHandler = withGuards(
  deletePrivateGatewayAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/gateways/detail.ts
var import_utils_ipfs = __toESM(require_bundle());
var detailPrivateGatewayAction = async ({ args, sdk }) => {
  const privateGateway = await getPrivateGatewayOrPrompt({
    sdk,
    id: args.id,
    slug: args.slug
  });
  if (!privateGateway) {
    output.error(t("expectedNotFoundGeneric", { name: "private gateway" }));
    return;
  }
  output.table([
    {
      ID: privateGateway.id,
      Slug: privateGateway.slug,
      Name: privateGateway.name,
      "Created At": privateGateway.createdAt
    }
  ]);
  const zoneId = privateGateway.zone?.id;
  const domains = zoneId ? await sdk.domains().listByZoneId({ zoneId }) : [];
  if (domains.length === 0) {
    output.log(t("gatewayNoDomainsAss"));
    return;
  }
  output.log(`${t("acccessContentViaDomain")}:`);
  for (const domain of domains) {
    output.link(
      (0, import_utils_ipfs.getPrivateIpfsGatewayUrl)({ hostname: domain.hostname, hash: "<cid>" })
    );
  }
  output.printNewLine();
};
var detailPrivateGatewayActionHandler = withGuards(
  detailPrivateGatewayAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/gateways/list.ts
var listPrivateGatewaysAction = async ({ sdk }) => {
  const privateGateways = await sdk.privateGateways().list();
  if (privateGateways.length === 0) {
    output.log(t("noPrivateGateways"));
    return;
  }
  output.table(
    privateGateways.map(({ id, slug, name, createdAt }) => ({
      ID: id,
      Slug: slug,
      Name: name,
      "Created At": createdAt
    }))
  );
};
var listPrivateGatewaysActionHandler = withGuards(
  listPrivateGatewaysAction,
  {
    scopes: { authenticated: true, project: true, site: false }
  }
);

// src/commands/gateways/index.ts
var gateways_default = (program) => {
  const cmd = program.command("gateways").description(t("gatewaysCmdDescription"));
  cmd.command("list").description(t("listAllPrvGwForSelectProject")).action(() => listPrivateGatewaysActionHandler());
  cmd.command("detail").option(
    "--id <string>",
    t("nameOfSubjectForDetails", {
      name: t("id"),
      subject: t("privateGateway")
    })
  ).option(
    "--slug <string>",
    t("nameOfSubjectForDetails", {
      name: t("sdkPoweredApp"),
      subject: t("privateGateway")
    })
  ).description(t("gatewayShowDetails")).action(
    (options) => detailPrivateGatewayActionHandler(options)
  );
  cmd.command("create").option("--name <string>", t("gatewayCreateName")).description(t("gatewayCreateCmdDesc")).action(
    (options) => createPrivateGatewayActionHandler(options)
  );
  cmd.command("delete").option(
    "--id <string>",
    t("commonNameOfSubjectToAction", {
      name: t("id"),
      subject: t("privateGateway"),
      action: t("delete")
    })
  ).option(
    "--slug <string>",
    t("commonNameOfSubjectToAction", {
      name: t("humanReadableSlugDesc"),
      subject: t("privateGateway"),
      action: t("delete")
    })
  ).description(t("gatewayDelete")).action(
    (options) => deletePrivateGatewayActionHandler(options)
  );
  return cmd;
};

// src/commands/ipfs/add.ts
var import_node_fs11 = __toESM(require("node:fs"));
var import_utils_ipfs2 = __toESM(require_bundle());

// src/commands/gateways/utils/getAllPrivateGatewayDomains.ts
var getAllPrivateGatewayDomains = async ({
  sdk,
  filter
}) => {
  const privateGateways = await sdk.privateGateways().list();
  if (privateGateways.length === 0) {
    return [];
  }
  const domainPromises = privateGateways.map(async (privateGateway) => {
    const zoneId = privateGateway.zone?.id;
    if (!zoneId) return [];
    return sdk.domains().listByZoneId({ zoneId });
  });
  const domains = (await Promise.all(domainPromises)).flat();
  return filter && Object.keys(filter).length > 0 ? domains.filter(
    (domain) => Object.entries(filter).every(([key, value]) => {
      return domain[key] === value;
    })
  ) : domains;
};
var getAllActivePrivateGatewayDomains = async ({
  sdk
}) => {
  return await getAllPrivateGatewayDomains({
    sdk,
    filter: { status: "ACTIVE" }
  });
};

// src/commands/ipfs/utils/uploadPathOnIpfs.ts
var import_node_fs10 = require("node:fs");
var import_node_path6 = require("node:path");
var uploadPathOnIpfs = async ({ sdk, path: path3 }) => {
  const stat = await import_node_fs10.promises.stat(path3);
  if (stat.isDirectory()) {
    const uploadResults = await sdk.ipfs().addFromPath(path3, {
      wrapWithDirectory: true,
      // We must pass plain object instead of URLSearchParams because of ipfs-http-client bug
      searchParams: { alias: (0, import_node_path6.basename)(path3) }
    });
    return uploadResults.pop();
  }
  const content = await import_node_fs10.promises.readFile(path3);
  return sdk.ipfs().add({ path: path3, content });
};

// src/commands/ipfs/add.ts
var addAction = async ({ sdk, args }) => {
  if (!import_node_fs11.default.existsSync(args.path)) {
    output.error(t("filePathNotFound", { path: args.path }));
    output.printNewLine();
    return;
  }
  output.spinner(t("uploadingFiles"));
  const root = await uploadPathOnIpfs({ sdk, path: args.path });
  if (!root) {
    output.error(t("uploadFailureSomeReason"));
    output.printNewLine();
    return;
  }
  const privateGatewayDomains = await getAllActivePrivateGatewayDomains({
    sdk
  });
  const hash = root.cid.toString();
  const successMsg = t("uploadPathSuccessWithCID", { path: args.path, hash });
  output.success(successMsg);
  output.printNewLine();
  if (privateGatewayDomains.length === 0) {
    output.hint(`${t("getFileFromPubAddr")}:`);
    output.link((0, import_utils_ipfs2.getFleekXyzIpfsGatewayUrl)(hash));
    return;
  }
  output.log(`${t("visitViaPvtGw")}:`);
  for (const privateGatewayDomain of privateGatewayDomains) {
    output.link(
      (0, import_utils_ipfs2.getPrivateIpfsGatewayUrl)({
        hostname: privateGatewayDomain.hostname,
        hash
      })
    );
  }
};
var addActionHandler = withGuards(addAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipfs/index.ts
var ipfs_default = (program) => {
  const cmd = program.command("ipfs").description(t("ipfsDescription"));
  cmd.command("add").description(t("ipfsAddDescription")).argument("<path>", t("ipfsAddPathDescription")).action((path3) => addActionHandler({ path: path3 }));
  return cmd;
};

// src/commands/ipns/create.ts
var import_utils_ipns = __toESM(require_dist5());

// src/commands/ipns/prompts/getSiteToAssignRecordOrPrompt.ts
var getSiteToAssignRecordOrPrompt = async ({
  sdk,
  siteId,
  siteSlug
}) => {
  if (!siteId && !siteSlug) {
    const shouldSiteAssignToRecord = await confirmPrompt({
      message: "Do you want to assign new IPNS record to the site?",
      initial: false
    });
    if (!shouldSiteAssignToRecord) {
      return null;
    }
  }
  return getSiteOrPrompt({ sdk, id: siteId, slug: siteSlug });
};

// src/commands/ipns/create.ts
var createAction2 = async ({
  sdk,
  args
}) => {
  const site = await getSiteToAssignRecordOrPrompt({
    sdk,
    siteId: args.siteId,
    siteSlug: args.siteSlug
  });
  const record = site ? await sdk.ipns().createRecordForSite({ siteId: site.id }) : await sdk.ipns().createRecord();
  output.printNewLine();
  output.success(t("ipnsCreatedIPNSHash", { hash: record.name }));
  output.printNewLine();
  if (site) {
    output.chore(t("ipnsRecordToPublishAuto", { name: site.name }));
  } else {
    output.hint(t("youCanDoXUsingFolCmd", { action: t("publishIPNSRecord") }));
    output.log(`fleek ipns publish --name ${record.name} --hash <ipfsCid>`);
    output.printNewLine();
  }
  output.hint(`${t("ipnsAfterPubRecordVisitGw")}:`);
  output.link((0, import_utils_ipns.getIpnsGatewayUrl)(record.name));
};
var createActionHandler2 = withGuards(createAction2, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipns/prompts/confirmDeleteRecordPrompt.ts
var confirmDeleteRecordPrompt = async () => confirmPrompt({
  message: "Are you sure you want to delete the record?",
  initial: false
});

// src/commands/ipns/prompts/getRecordOrPrompt.ts
var import_errors25 = __toESM(require_dist4());
var getRecordOrPrompt = async ({
  sdk,
  name
}) => {
  if (name) {
    return await sdk.ipns().getRecord({ name });
  }
  const records = await sdk.ipns().listRecords();
  if (records.length === 0) {
    throw new import_errors25.IpnsRecordsNotFoundError();
  }
  const ipnsRecordId = await selectPrompt({
    message: `${t("ipnsSelectRecord")}:`,
    choices: records.map((record) => ({
      title: record.name,
      value: record.id
    }))
  });
  const ipnsRecordMatch = records.find((record) => record.id === ipnsRecordId);
  if (!ipnsRecordMatch) return;
  return ipnsRecordMatch;
};

// src/commands/ipns/delete.ts
var deleteAction2 = async ({
  sdk,
  args
}) => {
  const foundRecord = await getRecordOrPrompt({ sdk, name: args.name });
  if (!foundRecord) {
    output.error(t("expectedNotFoundGeneric", { name: "record" }));
    return;
  }
  const shouldDeleteRecord = await confirmDeleteRecordPrompt();
  if (!shouldDeleteRecord) {
    return;
  }
  await sdk.ipns().deleteRecord({ id: foundRecord.id });
  output.printNewLine();
  output.success(
    t("commonItemActionSuccess", {
      subject: t("ipnsRecord"),
      action: t("deleted")
    })
  );
};
var deleteActionHandler2 = withGuards(deleteAction2, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipns/list.ts
var listAction2 = async ({ sdk }) => {
  const records = await sdk.ipns().listRecords();
  if (records.length > 0) {
    return output.table(
      records.map((record) => ({
        Name: record.name,
        CID: record.hash,
        ID: record.id
      }))
    );
  }
  return output.log(t("recordsNotFound"));
};
var listActionHandler2 = withGuards(listAction2, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipns/publish.ts
var import_utils_ipns2 = __toESM(require_dist5());

// src/commands/ipns/prompts/getHashOrPrompt.ts
var getHashOrPrompt = async ({ hash }) => {
  if (hash) {
    return hash;
  }
  return textPrompt({ message: `${t("ipnsTypeValidIPFSHash")}:` });
};

// src/commands/ipns/publish.ts
var publishAction = async ({
  sdk,
  args
}) => {
  const record = await getRecordOrPrompt({ sdk, name: args.name });
  if (!record) {
    output.error(t("recordsNotFoundUnexpectedly"));
    return;
  }
  const hash = await getHashOrPrompt({ hash: args.hash });
  await sdk.ipns().publishRecord({ id: record.id, hash });
  output.printNewLine();
  output.log(`${t("ipnsVisitPublishedIPNSGw")}:`);
  output.link((0, import_utils_ipns2.getIpnsGatewayUrl)(record.name));
  output.printNewLine();
  output.hint(t("ipnsPropagationTimeWarn"));
};
var publishActionHandler = withGuards(publishAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipns/resolve.ts
var resolveAction = async ({
  sdk,
  args
}) => {
  const res = await sdk.ipns().resolveName({ name: args.name });
  const hash = res.replace("/ipfs/", "");
  output.success(t("ipnsResultHashIs", { hash }));
  output.printNewLine();
};
var resolveActionHandler = withGuards(resolveAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/ipns/index.ts
var ipns_default = (program) => {
  const cmd = program.command("ipns").description(t("ipnsDescription"));
  cmd.command("create").description(t("ipnsCreateDescription")).option(
    "--siteSlug <string>",
    t("commonIdentifierXAssignedToSubjectY", {
      name: "humanReadableSlugDesc",
      subject: t("ipnsRecord")
    })
  ).option(
    "--siteId <string>",
    t("commonIdentifierXAssignedToSubjectY", {
      name: t("uniqueIdentifier"),
      subject: t("ipnsRecord")
    })
  ).action(
    (options) => createActionHandler2(options)
  );
  cmd.command("publish").description(t("ipnsPublishDescription")).option("--name <string>", t("ipnsPublishOptionNameDesc")).option("--hash <string>", t("ipnsPublishOptionHashDesc")).action(
    (options) => publishActionHandler(options)
  );
  cmd.command("list").description(t("ipnsListDescription")).action(() => listActionHandler2());
  cmd.command("delete").description(t("ipnsDeleteDescription")).option(
    "--name <string>",
    t("commonNameOfSubjectToAction", {
      name: t("name"),
      subject: t("ipnsRecord"),
      action: t("delete")
    })
  ).action((options) => deleteActionHandler2(options));
  cmd.command("resolve").description(t("ipnsResolveDescription")).argument("<name>", t("ipnsResolveArgName")).action((name) => resolveActionHandler({ name }));
  return cmd;
};

// src/commands/pat/index.ts
var import_errors26 = __toESM(require_dist4());

// src/commands/pat/create.ts
var import_node3 = require("@fleek-platform/sdk/node");

// src/utils/prompts/getPersonalAccessTokenNameOrPrompt.ts
var getPersonalAccessTokenNameOrPrompt = async ({
  name
}) => {
  if (name) {
    return name;
  }
  const personalAccessTokenName = await textPrompt({
    message: "Do you want to name your new personal access token? Keep empty to skip."
  });
  return personalAccessTokenName;
};

// src/commands/pat/create.ts
var createPersonalAccessTokenActionHandler = async ({
  uiAppUrl,
  authApiUrl,
  ...args
}) => {
  const verificationSessionId = generateVerificationSessionId();
  const name = await getPersonalAccessTokenNameOrPrompt({
    name: args?.name
  });
  output.printNewLine();
  showVerificationSessionLink({ output, uiAppUrl, verificationSessionId });
  const personalAccessToken = await waitForPersonalAccessTokenFromVerificationSession({
    verificationSessionId,
    client: (0, import_node3.createClient)({ url: authApiUrl }),
    name
  });
  if (!personalAccessToken) {
    output.error(t("patFetchTimeout"));
    return;
  }
  output.success(
    t("newPatIs", { pat: output.textColor(personalAccessToken, "redBright") })
  );
};

// src/commands/pat/utils/deletePersonalAccessToken.ts
var deletePersonalAccessToken = async ({
  output: output2,
  sdk,
  id
}) => {
  const success = await sdk.user().deletePersonalAccessToken({ id }).catch(() => false);
  if (!success) {
    output2.error(t("patIdNotExistForUsr"));
    return;
  }
  output2.printNewLine();
  output2.success(
    t("commonItemActionSuccess", {
      subject: t("personalAccessToken"),
      action: t("deleted")
    })
  );
};

// src/commands/pat/delete.ts
var deletePersonalAccessTokenAction = async ({ sdk, args }) => {
  await deletePersonalAccessToken({
    id: args.personalAccessTokenId,
    output,
    sdk
  });
};
var deletePersonalAccessTokenActionHandler = withGuards(
  deletePersonalAccessTokenAction,
  {
    scopes: {
      authenticated: true,
      project: false,
      site: false
    }
  }
);

// src/commands/pat/list.ts
var listPersonalAccessTokensAction = async ({
  sdk
}) => {
  const personalAccessTokens = await sdk.user().listPersonalAccessTokens();
  if (personalAccessTokens.length === 0) {
    output.warn(t("noYYet", { name: t("personalAccessToken") }));
    return;
  }
  output.table(
    personalAccessTokens.map(({ id, createdAt, name, maskedToken }) => ({
      ID: id,
      "Created At": createdAt,
      Name: name ?? "",
      Token: maskedToken
    }))
  );
};
var listPersonalAccessTokensActionHandler = withGuards(
  listPersonalAccessTokensAction,
  {
    scopes: {
      authenticated: true,
      project: false,
      site: false
    }
  }
);

// src/commands/pat/index.ts
var pat_default = (program) => {
  const cmd = program.command("pat").description(t("patDescription"));
  cmd.command("list").description(t("patListDesc")).action(listPersonalAccessTokensActionHandler);
  cmd.command("create").description(t("createNewPat")).option("-n, --name <name>", t("patName")).action(async (args) => {
    const uiAppUrl = getDefined("UI__APP_URL");
    const authApiUrl = getDefined("SDK__GRAPHQL_API_URL");
    if (!uiAppUrl || !authApiUrl) {
      throw new import_errors26.MissingExpectedDataError();
    }
    await createPersonalAccessTokenActionHandler({
      uiAppUrl,
      authApiUrl,
      ...args
    });
  });
  cmd.command("delete").description(t("patDelete")).argument(
    "<personalAccessTokenId>",
    t("commonNameOfSubjectToAction", {
      name: t("id"),
      subject: t("personalAccessToken"),
      action: t("delete")
    })
  ).action(
    (personalAccessTokenId) => deletePersonalAccessTokenActionHandler({ personalAccessTokenId })
  );
  return cmd;
};

// src/output/Output.ts
var import_as_table = __toESM(require("as-table"));
var import_boxen = __toESM(require("boxen"));
var import_chalk3 = __toESM(require("chalk"));

// src/output/utils/wait.ts
var import_chalk2 = __toESM(require("chalk"));
var import_ora = __toESM(require("ora"));
var Waiter = class {
  constructor({ opts, delay = 300 }) {
    this.spinner = null;
    this.text = opts.text?.slice() ?? "";
    this.timeout = setTimeout(() => {
      this.spinner = (0, import_ora.default)(opts);
      this.spinner.text = import_chalk2.default.cyan(this.text);
      this.spinner.color = "cyan";
      this.spinner.start();
    }, delay);
  }
  stop() {
    clearTimeout(this.timeout);
    if (this.spinner) {
      this.spinner.stop();
      this.spinner = null;
      process.stderr.write(eraseLines(1));
    }
  }
  setText(newText) {
    this.text = newText;
    if (this.spinner) {
      this.spinner.text = import_chalk2.default.gray(newText);
    }
  }
};

// src/output/Output.ts
var Output = class {
  constructor({ stream, debug: debugEnabled = false } = {
    stream: process.stdout
  }) {
    this.spinnerMessage = "";
    this._spinner = null;
    this.print = (message, options = {}) => {
      this.stopSpinner();
      if (this.debugEnabled) {
        import_chalk3.default.level = 0;
      }
      const preparedMessage = options.prefix ? `${options.prefix.color ? import_chalk3.default[options.prefix.color](options.prefix.message) : options.prefix.message} ${options.prefix.bold ? import_chalk3.default.bold(message) : message}` : message;
      return this.stream.write(preparedMessage);
    };
    this.printNewLine = (count = 1) => {
      this.print("\n".repeat(count));
    };
    this.log = (message) => {
      this.print(message, { prefix: { color: "gray", message: ">" } });
      this.printNewLine();
    };
    this.chore = (message) => {
      this.print(message, { prefix: { message: "\u{1F916}" /* Robot */, bold: false } });
      this.printNewLine();
    };
    this.hint = (message) => {
      this.print(message, { prefix: { message: "\u{1F4A1}" /* Lamp */, bold: true } });
      this.printNewLine();
    };
    this.warn = (message) => {
      this.print(message, {
        prefix: { message: `${"\u26A0\uFE0F" /* Warning */} ${t("warning")}!` }
      });
      this.printNewLine();
    };
    this.mistake = (message) => {
      this.print(message, {
        prefix: { message: `${"\u{1F479}" /* Devil */} ${t("mistake")}!`, bold: false }
      });
      this.printNewLine();
    };
    this.error = (message) => {
      this.print(message, {
        prefix: { message: `${"\u274C" /* Cross */} ${t("error")}:` }
      });
      this.printNewLine();
    };
    this.ready = (message) => {
      this.print(message, {
        prefix: { message: `${"\u{1F3C1}" /* ChequeredFlag */} ${t("ready")}!` }
      });
      this.printNewLine();
    };
    this.success = (message) => {
      this.print(message, {
        prefix: { message: `${"\u2705" /* Checkmark */} ${t("success")}!` }
      });
      this.printNewLine();
    };
    this.link = (url) => {
      this.print(`${"\u{1F517}" /* Chain */} ${import_chalk3.default.cyan.underline(url)}`);
      this.printNewLine();
    };
    this.debug = (message) => {
      if (this.debugEnabled) {
        this.print(message, {
          prefix: { color: "gray", message: `${t("debug")}:` }
        });
        this.printNewLine();
      }
    };
    this.table = (data) => {
      this.printNewLine();
      this.print((0, import_as_table.default)(data));
      this.printNewLine(2);
    };
    this.box = (lines, options = {}) => {
      const defaultOptions = {
        textAlignment: "center",
        margin: 1,
        padding: 3,
        float: "left",
        borderColor: "yellow"
      };
      this.printNewLine();
      this.print((0, import_boxen.default)(lines.join("\n"), { ...defaultOptions, ...options }));
      this.printNewLine();
    };
    this.textColor = (message, color) => import_chalk3.default[color](message);
    this.quoted = (message) => `"${message}"`;
    this.spinner = (message, delay = 300) => {
      if (this.debugEnabled) {
        this.debug(
          t("spinnerInvokedDelay", { message, delay: delay.toString() })
        );
        return;
      }
      this.spinnerMessage = message;
      if (this._spinner) {
        this._spinner.setText(message);
      } else {
        this._spinner = new Waiter({
          opts: {
            text: message,
            stream: this.stream
          },
          delay
        });
      }
    };
    this.stopSpinner = () => {
      if (this.debugEnabled && this.spinnerMessage) {
        this.debug(t("spinnerStopped", { spinnerMessage: this.spinnerMessage }));
        this.spinnerMessage = "";
      }
      if (this._spinner) {
        this._spinner.stop();
        this._spinner = null;
        this.spinnerMessage = "";
      }
    };
    this.raw = (msg) => {
      this.stream.write(msg);
    };
    this.stream = stream;
    this.debugEnabled = debugEnabled;
  }
};

// src/commands/projects/list.ts
var listProjectsAction = async ({ sdk }) => {
  const projects = await sdk.projects().list();
  if (projects.length === 0) {
    output.log(t("noYYet", { name: t("projects") }));
    return;
  }
  const currentProjectId = config.projectId.get();
  output.table(
    projects.map(({ id, name, createdAt }) => ({
      ID: id,
      Name: name,
      "Created At": createdAt,
      Current: currentProjectId === id ? "\u2705" /* Checkmark */ : ""
    }))
  );
};
var listProjectsActionHandler = sdkGuard(listProjectsAction);

// src/commands/projects/index.ts
var projects_default = (program) => {
  const cmd = program.command("projects").description(t("projectsDescription"));
  cmd.command("list").description(t("projectsListDesc")).action(() => listProjectsActionHandler());
  cmd.command("switch").option("--id <string>", t("projectsSwitchOptId")).description(t("projectsSwitchBetween")).action((options) => switchProjectActionHandler(options));
  cmd.command("create").option("--name <string>", t("projectsWhatNameOfProject")).description(t("projectsCreateNewDesc")).action((options) => createProjectActionHandler(options));
  return cmd;
};

// src/commands/sites/prompts/getCIProviderOrPrompt.ts
var providerChoices = [
  {
    title: "GitHub Actions",
    description: t("githubActionGenDescription"),
    value: "github"
  }
];
var getCIProviderOrPrompt = async (args) => {
  if (args?.provider) {
    return args.provider;
  }
  const provider = await selectPrompt({
    message: `${t("selectProviderForBuildDeploySite")}:`,
    choices: providerChoices,
    initial: 0
  });
  return provider;
};

// src/commands/sites/utils/prepareGitHubActionsIntegration.ts
var import_node_path8 = require("node:path");
var import_utils_github = __toESM(require_dist7());
var import_semver = require("semver");

// src/commands/sites/prompts/confirmFileOverridePrompt.ts
var confirmFileOverridePrompt = async ({
  path: path3
}) => confirmPrompt({
  message: t("fileExistAskIfOverwrite", { path: path3 }),
  initial: true
});

// src/commands/sites/utils/getDeploymentWorkflowYamlLocation.ts
var import_node_path7 = require("node:path");

// src/commands/sites/prompts/confirmWorkflowCustomPathPrompt.ts
var confirmWorkflowCustomPathPrompt = async ({
  path: path3
}) => confirmPrompt({
  message: t("workflowToBeSavePathOrOther", { path: path3 }),
  initial: false
});

// src/commands/sites/utils/getDeploymentWorkflowYamlLocation.ts
var getDeploymentWorkflowYamlLocation = async () => {
  const useCustomLocation = await confirmWorkflowCustomPathPrompt({
    path: ghActionsDeploySitesYamlPath
  });
  if (useCustomLocation === false) {
    return ghActionsDeploySitesYamlPath;
  }
  const directory = await enterDirectoryPathPrompt({
    message: t("specifyDirToSaveWorkConf")
  });
  const yamlPath = (0, import_node_path7.join)(directory, ghWorkflowFilename);
  return yamlPath;
};

// src/commands/sites/utils/initializeDeploymentWorkflowDirectory.ts
var import_node_fs12 = require("node:fs");
var initializeDeploymentWorkflowDirectory = async ({
  output: output2,
  ghActionsWorflowsDirectory: ghActionsWorflowsDirectory2
}) => {
  const exists = await directoryExists(ghActionsWorflowsDirectory2);
  if (exists) {
    return;
  }
  output2.warn(t("cantFindGithubWorkfl"));
  output2.warn(t("creatingGithubWorkflDir"));
  await import_node_fs12.promises.mkdir(ghActionsWorflowsDirectory2, { recursive: true });
};

// src/commands/sites/prompts/confirmInstallCommandPrompt.ts
var confirmInstallCommandPrompt = async ({
  installCommand
}) => confirmPrompt({
  message: t("isGenInstallCmdCorrect", { installCommand }),
  initial: true
});

// src/commands/sites/prompts/confirmUserWantsInstallCommandPrompt.ts
var confirmUserWantsInstallCommandPrompt = async () => confirmPrompt({
  message: t("runInstallCmdBeforeBuild"),
  initial: false
});

// src/commands/sites/prompts/confirmUserWantsToSpecifyInstallCommandPrompt.ts
var confirmUserWantsToSpecifyInstallCommandPrompt = async () => confirmPrompt({
  message: t("specifyinstallCmdOpt"),
  initial: true
});

// src/commands/sites/prompts/enterInstallCommandPrompt.ts
var enterInstallCommandPrompt = async () => textPrompt({
  message: `${t("specifyInstallCmd")}:`
});

// src/commands/sites/utils/deriveInstallCommandFromLockfile.ts
var import_node_fs13 = require("node:fs");
var lockToInstallCommandMap = {
  "yarn.lock": "npm install -g yarn && yarn install",
  "pnpm-lock.yaml": "npm install -g pnpm && pnpm install",
  "package-lock.json": "npm install"
};
var deriveInstallCommandFromLockfile = async () => {
  const directoryContents = await import_node_fs13.promises.readdir(process.cwd());
  const lockFile = directoryContents.find((file) => file.includes("lock"));
  if (!lockFile) {
    output.warn(t("noLockfileFound"));
    return;
  }
  return lockToInstallCommandMap[lockFile];
};

// src/commands/sites/utils/requestDeploymentWorkflowInstallCommand.ts
var requestDeploymentWorkflowInstallCommand = async () => {
  const config2 = await loadConfiguration({}).catch(() => null);
  if (config2 === null || !config2.sites[0]?.buildCommand) {
    return;
  }
  const wantsInstallCommand = await confirmUserWantsInstallCommandPrompt();
  if (!wantsInstallCommand) {
    return;
  }
  const wantsToSpecifyCommand = await confirmUserWantsToSpecifyInstallCommandPrompt();
  if (wantsToSpecifyCommand) {
    return enterInstallCommandPrompt();
  }
  const installCommand = await deriveInstallCommandFromLockfile();
  if (!installCommand || !await confirmInstallCommandPrompt({ installCommand })) {
    return enterInstallCommandPrompt();
  }
  return installCommand;
};

// src/commands/sites/utils/saveDeploymentWorkflowYaml.ts
var import_node_fs14 = require("node:fs");
var import_chalk4 = __toESM(require("chalk"));
var saveDeploymentWorkflowYaml = async ({
  yamlContent,
  yamlPath,
  personalAccessToken,
  projectId,
  output: output2
}) => {
  try {
    await import_node_fs14.promises.writeFile(yamlPath, yamlContent);
    output2.printNewLine();
    output2.success(
      t("githubActionWrkflSavedTo", {
        path: import_chalk4.default.underline(import_chalk4.default.cyan(yamlPath))
      })
    );
    output2.printNewLine();
    output2.chore(`${t("setSecretsInGithugRepoSettings")}:`);
    output2.table([
      {
        Name: "FLEEK_TOKEN",
        Value: personalAccessToken
      },
      {
        Name: "FLEEK_PROJECT_ID",
        Value: projectId
      }
    ]);
    output2.printNewLine();
  } catch (e) {
    output2.error(t("failSaveGenYaml", { yamlPath }));
  }
};

// src/commands/sites/utils/prepareGitHubActionsIntegration.ts
var ghWorkflowFilename = "fleek-deploy.yaml";
var ghActionsWorflowsDirectory = (0, import_node_path8.join)(
  process.cwd(),
  ".github/workflows"
);
var ghActionsDeploySitesYamlPath = (0, import_node_path8.join)(
  ghActionsWorflowsDirectory,
  ghWorkflowFilename
);
var prepareGitHubActionsIntegration = async ({
  personalAccessToken,
  projectId,
  fleekConfigPath,
  output: output2
}) => {
  let nodeVersion;
  try {
    const nodeSemver = loadJSONFromPackageRoot(
      "package.json"
    ).engines.node.replace(/[^0-9\.]+/, "");
    nodeVersion = (0, import_semver.parse)(nodeSemver)?.major ?? 18;
  } catch {
    nodeVersion = 18;
  }
  const installCommand = await requestDeploymentWorkflowInstallCommand();
  const yamlContent = (0, import_utils_github.generateDeploymentWorkflowYaml)({
    nodeVersion,
    fleekConfigPath,
    installCommand
  });
  const yamlPath = await getDeploymentWorkflowYamlLocation();
  const pathExists = await fileExists(yamlPath);
  if (pathExists && !await confirmFileOverridePrompt({ path: yamlPath })) {
    return;
  }
  if (yamlPath === ghActionsDeploySitesYamlPath) {
    await initializeDeploymentWorkflowDirectory({
      output: output2,
      ghActionsWorflowsDirectory
    });
  }
  await saveDeploymentWorkflowYaml({
    yamlPath,
    yamlContent,
    personalAccessToken,
    projectId,
    output: output2
  });
};

// src/commands/sites/ci.ts
var ciAction = async ({ args }) => {
  const provider = await getCIProviderOrPrompt({
    provider: args?.provider
  });
  const personalAccessToken = config.personalAccessToken.get();
  const projectId = config.projectId.get();
  if (!personalAccessToken) {
    output.error(t("noPatFoundUnexpectedly"));
    return;
  }
  if (!projectId) {
    output.error(t("noProjectIdFoundUnexpectedly"));
    return;
  }
  switch (provider) {
    case "github":
      await prepareGitHubActionsIntegration({
        projectId,
        personalAccessToken,
        fleekConfigPath: args.predefinedConfigPath,
        output
      });
      break;
    default:
      output.error(t("providerNotSupported"));
      return;
  }
};
var ciActionHandler = withGuards(ciAction, {
  scopes: {
    project: true,
    site: true,
    authenticated: true
  }
});

// src/commands/sites/utils/runCommandAndForwardOutput.ts
var import_node_child_process = require("node:child_process");
var runCommandAndForwardOutput = async (buildCommand) => {
  const buildCommandProcess = (0, import_node_child_process.exec)(buildCommand);
  buildCommandProcess.stdout?.on("data", console.log);
  buildCommandProcess.stderr?.on("data", console.log);
  return new Promise((resolve) => {
    buildCommandProcess.on("close", (exitCode) => resolve(exitCode ?? 0));
  });
};

// src/commands/sites/utils/waitUntilDeploymentFinishedAndInformUser.ts
var import_utils_gateways = __toESM(require_dist8());

// src/commands/sites/utils/returnDeploymentWhenFinished.ts
var returnDeploymentWhenFinished = ({ sdk, deploymentId }) => async () => {
  const deployment = await sdk.sites().getDeployment({ id: deploymentId });
  if (deployment.status === "RELEASE_COMPLETED" || deployment.status === "RELEASE_FAILED") {
    return deployment.status;
  }
  return null;
};

// src/commands/sites/utils/waitUntilDeploymentFinishedAndInformUser.ts
var waitUntilDeploymentFinishedAndInformUser = async ({
  sdk,
  siteId,
  slug,
  hostname,
  deploymentId,
  hash,
  output: output2
}) => {
  const deploymentStatus = await checkPeriodicallyUntil({
    conditionFn: returnDeploymentWhenFinished({ sdk, deploymentId }),
    period: 6e3,
    tries: 30
  });
  if (!deploymentStatus) {
    output2.warn(
      t("warnSubjectProcessIsLong", { subject: t("processOfDeployment") })
    );
    output2.printNewLine();
    output2.log(
      `${t("commonWaitAndCheckStatusViaCmd", { subject: t("deploymentStatus") })}`
    );
    output2.log(
      output2.textColor(`fleek sites deployments --id ${siteId}`, "cyan")
    );
    return;
  }
  if (deploymentStatus === "RELEASE_FAILED") {
    output2.error(t("deployNotFinishTryAgain"));
    output2.printNewLine();
    process.exit(1);
  }
  output2.success(`${t("deployed")}!`);
  output2.printNewLine();
  output2.log(t("siteIPFSCid", { hash }));
  output2.hint(`${t("visitViaGateway")}:`);
  output2.link(
    hostname ? `https://${hostname}` : (0, import_utils_gateways.getFleekDefaultGatewayBySlug)({ slug })
  );
};

// src/commands/sites/deploy.ts
var deployAction2 = async ({
  sdk,
  args: { predefinedConfigPath }
}) => {
  const config2 = await loadConfiguration({ predefinedConfigPath });
  const siteConfig = config2.sites[0];
  const site = await sdk.sites().getBySlug({ slug: siteConfig.slug });
  if (siteConfig.buildCommand) {
    const exitCode = await runCommandAndForwardOutput(siteConfig.buildCommand);
    if (exitCode !== 0) {
      output.error(t("buildCmdFailedSeeErr", { cmd: siteConfig.buildCommand }));
      output.printNewLine();
      process.exit(exitCode);
    }
  }
  output.spinner(t("uploadingFiles"));
  const uploadResults = await sdk.ipfs().addSitesToIpfs(siteConfig.distDir, {
    wrapWithDirectory: true,
    // We must pass plain object instead of URLSearchParams because of ipfs-http-client bug
    searchParams: { site_id: site.id }
  });
  const root = uploadResults.pop();
  if (!root) {
    output.error(t("somethingWrongDurUpload"));
    output.printNewLine();
    process.exit(1);
  }
  output.spinner(t("startingSiteDeployment"));
  const hash = root.cid.toString();
  const deployment = await sdk.sites().createCustomIpfsDeployment({ cid: hash, siteId: site.id });
  await waitUntilDeploymentFinishedAndInformUser({
    sdk,
    deploymentId: deployment.id,
    siteId: site.id,
    slug: site.slug,
    hostname: site.primaryDomain?.hostname,
    hash,
    output
  });
};
var deployActionHandler2 = withGuards(deployAction2, {
  scopes: {
    authenticated: true,
    project: true,
    site: true
  }
});

// src/commands/sites/init.ts
var import_errors27 = __toESM(require_dist4());
var initAction = async ({ sdk }) => {
  const configLoadingResult = await loadConfiguration({}).then(() => {
    return { isContentValid: true, isFilePresent: true };
  }).catch((e) => {
    if (e instanceof import_errors27.FleekConfigInvalidContentError) {
      return {
        isContentValid: false,
        isFilePresent: true,
        configPath: e.data.configPath
      };
    }
    if (e instanceof import_errors27.FleekConfigMissingFileError) {
      return { isContentValid: false, isFilePresent: false };
    }
    throw e;
  });
  if (configLoadingResult.isContentValid && configLoadingResult.isFilePresent) {
    output.error(t("configFileExists"));
    output.printNewLine();
    output.log(t("siteAlreadyExists"));
    return;
  }
  if (!configLoadingResult.isContentValid && configLoadingResult.isFilePresent) {
    const overrideInvalidConfig = await confirmFileOverridePrompt({
      path: configLoadingResult.configPath
    });
    if (!overrideInvalidConfig) {
      return;
    }
  }
  const site = await chooseOrCreateSite({ sdk });
  if (!site) {
    output.error(t("unexpectedError"));
    return;
  }
  await initConfiguration({
    site,
    onUnexpectedFormatError: (format) => {
      output.warn(t("unexpectedFileFormat", { format }));
      process.exit(1);
    },
    onSaveConfigurationError: () => {
      output.warn(t("fsFailedToWriteConfig"));
      process.exit(1);
    }
  });
  output.printNewLine();
  output.success(t("fleekConfigSaved"));
  output.printNewLine();
};
var initActionHandler = withGuards(initAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/sites/list.ts
var listAction3 = async ({ sdk }) => {
  const sites = await sdk.sites().list();
  if (!sites?.length) {
    output.warn(t("noSitesYet"));
    output.log(t("youCanDoXUsingFolCmd", { action: t("createNewSite") }));
    output.log("fleek sites init");
    return;
  }
  output.table(
    sites.map((site) => ({
      Name: site.name,
      Slug: site.slug,
      ID: site.id
    }))
  );
};
var listActionHandler3 = withGuards(listAction3, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/sites/utils/printDeploymentsTable.ts
var printDeploymentsTable = ({
  output: output2,
  deployments
}) => {
  if (deployments.length === 0) {
    output2.warn(
      t("noYForXYet", { name: t("deployments"), subject: t("site") })
    );
    return;
  }
  output2.table(
    deployments.map(({ id, createdAt, updatedAt, status, cid }) => ({
      ID: id,
      "Created At": createdAt,
      "Updated At": updatedAt,
      Status: status,
      CID: cid
    }))
  );
};

// src/commands/sites/listDeployments.ts
var listDeploymentsAction2 = async ({ sdk, args }) => {
  const site = await getSiteOrPrompt({ id: args.id, slug: args.slug, sdk });
  if (!site) {
    output.error(t("expectedNotFoundGeneric", { name: "site" }));
    return;
  }
  printDeploymentsTable({ output, deployments: site.deployments });
};
var listDeploymentsActionHandler2 = withGuards(listDeploymentsAction2, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/sites/index.ts
var sites_default = (program) => {
  const cmd = program.command("sites").description(t("sitesDescription"));
  cmd.command("init").description(t("sitesInitDescription")).action(() => initActionHandler());
  cmd.command("ci").description(t("genConfForCIProviders")).option("-c, --config <fleekConfigPath>", t("specifyFleekJsonPath")).option("-p, --provider <provider>", t("specifyCIProvider")).action(
    (options) => ciActionHandler({
      predefinedConfigPath: options.config,
      provider: options.provider
    })
  );
  cmd.command("deploy").description(t("deploySite")).option("-c, --config <fleekConfigPath>", t("deploySpecifyPathJson")).action(
    (options) => deployActionHandler2({ predefinedConfigPath: options.config })
  );
  cmd.command("list").description(t("listSitesDesc")).action(() => listActionHandler3());
  cmd.command("deployments").option(
    "--slug <string>",
    t("nameOfWichDeploymentsBelong", { name: t("humanReadableSlugDesc") })
  ).option(
    "--id <string>",
    t("nameOfWichDeploymentsBelong", { name: t("uniqueIdentifier") })
  ).description(t("deploymentsListForSelectedSite")).action(
    (options) => listDeploymentsActionHandler2(options)
  );
  return cmd;
};

// src/commands/storage/add.ts
var import_node_fs15 = require("node:fs");
var import_node_path9 = require("node:path");
var import_utils_ipfs3 = __toESM(require_bundle());
var import_cli_progress4 = __toESM(require("cli-progress"));
var import_files_from_path2 = require("files-from-path");

// src/commands/storage/utils/upload.ts
var import_promises2 = __toESM(require("node:fs/promises"));
var uploadStorage = async ({
  path: path3,
  sdk,
  files,
  directoryName,
  progressBar,
  onFailure
}) => {
  try {
    const stat = await import_promises2.default.stat(path3);
    if (stat.isDirectory()) {
      return sdk.storage().uploadVirtualDirectory({
        files,
        directoryName,
        onUploadProgress: uploadOnProgress(progressBar)
      });
    }
    return sdk.storage().uploadFile({
      file: files[0],
      onUploadProgress: uploadOnProgress(progressBar)
    });
  } catch {
    if (typeof onFailure === "function") {
      onFailure();
    }
  }
  return;
};

// src/commands/storage/add.ts
var addStorageAction = async ({ sdk, args }) => {
  if (!(0, import_node_fs15.existsSync)(args.path)) {
    output.error(t("filePathNotFound", { path: args.path }));
    return;
  }
  const progressBar = new import_cli_progress4.default.SingleBar(
    {
      format: "Upload Progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}"
    },
    import_cli_progress4.default.Presets.shades_grey
  );
  const directoryName = (0, import_node_path9.basename)(args.path);
  const files = await (0, import_files_from_path2.filesFromPaths)([args.path]);
  const storage = await uploadStorage({
    path: args.path,
    sdk,
    files,
    directoryName,
    progressBar,
    onFailure: () => {
      progressBar.stop();
    }
  });
  if (!storage) {
    output.error(t("somethingWrongDurUpload"));
    return;
  }
  const hash = storage?.pin.cid.toString();
  if (storage.duplicate) {
    output.warn(t("fileAlreadyExistWarn", { path: args.path }));
    output.printNewLine();
  } else {
    output.success(t("storageUploadSuccessCid", { cid: hash }));
    output.printNewLine();
  }
  const privateGatewayDomains = await getAllActivePrivateGatewayDomains({
    sdk
  });
  if (privateGatewayDomains.length === 0) {
    output.log(t("visitViaGateway"));
    output.link((0, import_utils_ipfs3.getFleekXyzIpfsGatewayUrl)(hash));
    return;
  }
  output.log(t("visitViaPvtGw"));
  for (const privateGatewayDomain of privateGatewayDomains) {
    output.link(
      (0, import_utils_ipfs3.getPrivateIpfsGatewayUrl)({
        hostname: privateGatewayDomain.hostname,
        hash
      })
    );
  }
  output.printNewLine();
};
var addStorageActionHandler = withGuards(addStorageAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/storage/delete.ts
var import_errors28 = __toESM(require_dist4());
var import_multiformats = require("multiformats");

// src/utils/processPromisesBatch.ts
var processPromisesBatch = async (items, fn, batchSize = 10) => {
  let results = [];
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(
      i,
      i + batchSize > items.length ? items.length : i + batchSize
    );
    const batchResults = await Promise.all(batch.map((item) => fn(item)));
    results = [...results, ...batchResults];
  }
  return results;
};

// src/commands/storage/delete.ts
var deleteStorageAction = async ({ sdk, args }) => {
  const { cid, name } = args;
  const cidsToDelete = [];
  if (typeof name === "string") {
    const splitFilename = name.split(".");
    const extension = splitFilename.length > 1 && splitFilename.pop() || "";
    const filename = splitFilename.join(".");
    const storage = await sdk.storage().getByFilename({ filename, extension });
    for (const s of storage) {
      cidsToDelete.push(s.cid);
    }
  } else if (cid) {
    try {
      import_multiformats.CID.parse(cid);
    } catch (err) {
      throw new import_errors28.InvalidCidError({ name: cid });
    }
    cidsToDelete.push(cid);
  }
  try {
    await processPromisesBatch(
      cidsToDelete,
      async (cid2) => {
        const response = await sdk.storage().delete({ cid: cid2 });
        output.log(
          `${t("processing")}${cid2 ? ` cid: ${cid2}` : ""}${name ? ` name: ${name}` : ""}`
        );
        if (response.status === 200) {
          output.success(
            t("commonItemActionSuccess", {
              subject: cid2 ? `CID ${cid2}` : `filename ${name}`,
              action: t("deleted")
            })
          );
        } else if (response.status === 500) {
          output.error(
            t("commonItemActionFailure", {
              action: t("delete"),
              subject: `${t("storage")} "`,
              message: `${response.body.message}`
            })
          );
        } else {
          throw new Error(response.body.message);
        }
        return;
      }
    );
  } catch (error) {
    if (error instanceof Error) {
      output.error(error.message);
    } else {
      console.error(error);
    }
  }
};
var deleteStorageActionHandler = withGuards(deleteStorageAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/storage/get.ts
var import_errors29 = __toESM(require_dist4());
var import_multiformats2 = require("multiformats");

// src/commands/storage/utils/CreateOutputTable.ts
var import_utils_ipfs4 = __toESM(require_bundle());
var createOutputTable = async ({
  sdk,
  storage
}) => {
  const privateGatewayDomains = await getAllActivePrivateGatewayDomains({
    sdk
  });
  const privateGatewayExists = privateGatewayDomains.length > 0;
  return storage.flatMap((s) => {
    const filename = `${s.filename}${s.extension ? `.${s.extension}` : ""}`;
    const gatewayUrls = privateGatewayExists ? privateGatewayDomains.map(
      (privateGatewayDomain) => (0, import_utils_ipfs4.getPrivateIpfsGatewayUrl)({
        hostname: privateGatewayDomain.hostname,
        hash: s.cid
      })
    ) : [(0, import_utils_ipfs4.getFleekXyzIpfsGatewayUrl)(s.cid)];
    return gatewayUrls.map((link) => ({
      filename,
      cid: s.cid,
      "filecoin id": s.filecoinDealIds,
      "arweave id": s.arweaveId,
      link
    }));
  });
};

// src/commands/storage/get.ts
var getStorageAction = async ({
  sdk,
  args
}) => {
  const { cid, name } = args;
  let storage;
  if (typeof name === "string") {
    const splitFilename = name.split(".");
    const extension = splitFilename.length > 1 && splitFilename.pop() || "";
    const filename = splitFilename.join(".");
    storage = await sdk.storage().getByFilename({ filename, extension });
  } else if (cid) {
    try {
      import_multiformats2.CID.parse(cid);
    } catch (err) {
      throw new import_errors29.InvalidCidError({ name: cid });
    }
    try {
      storage = [await sdk.storage().get({ cid })];
    } catch (err) {
      storage = void 0;
    }
  }
  if (!storage || storage?.length === 0) {
    output.warn(
      t("storageGetNotFound", {
        type: `${cid ? "cid" : "name"}`,
        value: cid || name || ""
      })
    );
    output.log(t("storageAddSuggestion"));
    output.log("fleek storage add <file_path>");
    return;
  }
  const table = await createOutputTable({ sdk, storage });
  output.table(table);
};
var getStorageActionHandler = withGuards(getStorageAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/storage/list.ts
var listStorageAction = async ({ sdk }) => {
  const storage = await sdk.storage().list();
  if (!storage?.length) {
    output.warn(t("storageListNotFound"));
    output.log(t("storageAddSuggestion"));
    output.log("fleek storage add <file_path>");
    return;
  }
  const table = await createOutputTable({ sdk, storage });
  output.table(table);
};
var listStorageActionHandler = withGuards(listStorageAction, {
  scopes: {
    authenticated: true,
    project: true,
    site: false
  }
});

// src/commands/storage/index.ts
var storage_default = (program) => {
  const cmd = program.command("storage").description(t("storageCmdDescription"));
  cmd.command("list").description(t("storageListDescription")).action(() => listStorageActionHandler());
  const getStorage = cmd.command("get").description(t("storageDescription", { action: t("get") })).option("-c, --cid <cid>", t("storageCidOption", { action: t("get") })).option(
    "-n, --name <filenameWithExtension>",
    t("storageNameOption", { action: t("get") })
  );
  getStorage.action((options) => {
    if (!options.name && !options.cid || options.name && options.cid) {
      if (!getStorage.args.includes("help") && !getStorage.optsWithGlobals().help) {
        output.error(t("storageMissingOptCidOrName"));
      }
      output.printNewLine();
      getStorage.outputHelp();
      return;
    }
    return getStorageActionHandler({ cid: options.cid, name: options.name });
  });
  const deleteStorage = cmd.command("delete").description(t("storageDescription", { action: t("delete") })).option("-c, --cid <cid>", t("storageCidOption", { action: t("delete") })).option(
    "-n, --name <filenameWithExtension>",
    t("storageNameOption", { action: t("delete") })
  );
  deleteStorage.action((options) => {
    if (!options.name && !options.cid || options.name && options.cid) {
      if (!getStorage.args.includes("help") && !getStorage.optsWithGlobals().help) {
        output.error(t("storageMissingOptCidOrName"));
      }
      output.printNewLine();
      deleteStorage.outputHelp();
      return;
    }
    return deleteStorageActionHandler({ cid: options.cid, name: options.name });
  });
  cmd.command("add").description(t("storageAddDescription")).argument("<path>", t("ipfsAddPathDescription")).action((path3) => addStorageActionHandler({ path: path3 }));
  return cmd;
};

// src/cli.ts
var isDebugging = process.argv.includes("--debug");
var output = new Output({
  stream: process.stdout,
  debug: isDebugging
});
var logo = `
                                                
       ad88  88                          88         
      d8"    88                          88         
      88     88                          88         
    MM88MMM  88   ,adPPYba,   ,adPPYba,  88   ,d8   
      88     88  a8P_____88  a8P_____88  88 ,a8"    
      88     88  8PP"""""""  8PP"""""""  8888[      
      88     88  "8b,   ,aa  "8b,   ,aa  88'"Yba,   
      88     88   '"Ybbd8"    '"Ybbd8"   88   'Y8a  

    \u26A1 ${t("aboutFleek")} \u26A1
`;
var init = ({ version, parser }) => {
  const program = new import_commander.Command().name("fleek").option("--debug", t("enableDebugMode")).action(() => program.outputHelp()).version(version);
  program.addHelpText("beforeAll", logo).showHelpAfterError();
  const cmdVersion = (program2) => program2.command("version").action(() => {
    output.raw(version);
    output.printNewLine();
  });
  const commands = [
    auth_default,
    applications_default,
    domains_default,
    ens_default,
    gateways_default,
    ipfs_default,
    ipns_default,
    pat_default,
    projects_default,
    sites_default,
    storage_default,
    functions_default,
    cmdVersion
  ];
  for (const cmd of commands) {
    const subCmd = cmd(program);
    if (subCmd) {
      for (const opt of subCmd.commands) {
        opt.addHelpCommand();
      }
    }
  }
  parser(program);
  return program;
};
var asyncParser = async (program) => {
  try {
    await program.parseAsync(process.argv);
    process.exit(0);
  } catch (err) {
    console.error(err.message || err);
    if (err.stack) {
      console.error(err.stack);
    }
    process.exit(1);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  asyncParser,
  init,
  output
});
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=bundle.js.map
